// @generated by protobuf-ts 2.9.5
// @generated from protobuf file "google/protobuf/unittest.proto" (package "protobuf_unittest", syntax proto2)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// A proto file we will use for unit testing.
//
// LINT: ALLOW_GROUPS, LEGACY_NAMES
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PublicImportMessage } from "./unittest_import_public";
import { ImportEnum } from "./unittest_import";
import { ImportMessage } from "./unittest_import";
/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 *
 * @generated from protobuf message protobuf_unittest.TestAllTypes
 */
export interface TestAllTypes {
    /**
     * Singular
     *
     * @generated from protobuf field: optional int32 optional_int32 = 1;
     */
    optionalInt32?: number;
    /**
     * @generated from protobuf field: optional int64 optional_int64 = 2;
     */
    optionalInt64?: bigint;
    /**
     * @generated from protobuf field: optional uint32 optional_uint32 = 3;
     */
    optionalUint32?: number;
    /**
     * @generated from protobuf field: optional uint64 optional_uint64 = 4;
     */
    optionalUint64?: bigint;
    /**
     * @generated from protobuf field: optional sint32 optional_sint32 = 5;
     */
    optionalSint32?: number;
    /**
     * @generated from protobuf field: optional sint64 optional_sint64 = 6;
     */
    optionalSint64?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 optional_fixed32 = 7;
     */
    optionalFixed32?: number;
    /**
     * @generated from protobuf field: optional fixed64 optional_fixed64 = 8;
     */
    optionalFixed64?: bigint;
    /**
     * @generated from protobuf field: optional sfixed32 optional_sfixed32 = 9;
     */
    optionalSfixed32?: number;
    /**
     * @generated from protobuf field: optional sfixed64 optional_sfixed64 = 10;
     */
    optionalSfixed64?: bigint;
    /**
     * @generated from protobuf field: optional float optional_float = 11;
     */
    optionalFloat?: number;
    /**
     * @generated from protobuf field: optional double optional_double = 12;
     */
    optionalDouble?: number;
    /**
     * @generated from protobuf field: optional bool optional_bool = 13;
     */
    optionalBool?: boolean;
    /**
     * @generated from protobuf field: optional string optional_string = 14;
     */
    optionalString?: string;
    /**
     * @generated from protobuf field: optional bytes optional_bytes = 15;
     */
    optionalBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
     */
    optionalNestedMessage?: TestAllTypes_NestedMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignMessage optional_foreign_message = 19;
     */
    optionalForeignMessage?: ForeignMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest_import.ImportMessage optional_import_message = 20;
     */
    optionalImportMessage?: ImportMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
     */
    optionalNestedEnum?: TestAllTypes_NestedEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
     */
    optionalForeignEnum?: ForeignEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest_import.ImportEnum optional_import_enum = 23;
     */
    optionalImportEnum?: ImportEnum;
    /**
     * @generated from protobuf field: optional string optional_string_piece = 24;
     */
    optionalStringPiece?: string;
    /**
     * @generated from protobuf field: optional string optional_cord = 25;
     */
    optionalCord?: string;
    /**
     * Defined in unittest_import_public.proto
     *
     * @generated from protobuf field: optional protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
     */
    optionalPublicImportMessage?: PublicImportMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27;
     */
    optionalLazyMessage?: TestAllTypes_NestedMessage;
    /**
     * Repeated
     *
     * @generated from protobuf field: repeated int32 repeated_int32 = 31;
     */
    repeatedInt32: number[];
    /**
     * @generated from protobuf field: repeated int64 repeated_int64 = 32;
     */
    repeatedInt64: bigint[];
    /**
     * @generated from protobuf field: repeated uint32 repeated_uint32 = 33;
     */
    repeatedUint32: number[];
    /**
     * @generated from protobuf field: repeated uint64 repeated_uint64 = 34;
     */
    repeatedUint64: bigint[];
    /**
     * @generated from protobuf field: repeated sint32 repeated_sint32 = 35;
     */
    repeatedSint32: number[];
    /**
     * @generated from protobuf field: repeated sint64 repeated_sint64 = 36;
     */
    repeatedSint64: bigint[];
    /**
     * @generated from protobuf field: repeated fixed32 repeated_fixed32 = 37;
     */
    repeatedFixed32: number[];
    /**
     * @generated from protobuf field: repeated fixed64 repeated_fixed64 = 38;
     */
    repeatedFixed64: bigint[];
    /**
     * @generated from protobuf field: repeated sfixed32 repeated_sfixed32 = 39;
     */
    repeatedSfixed32: number[];
    /**
     * @generated from protobuf field: repeated sfixed64 repeated_sfixed64 = 40;
     */
    repeatedSfixed64: bigint[];
    /**
     * @generated from protobuf field: repeated float repeated_float = 41;
     */
    repeatedFloat: number[];
    /**
     * @generated from protobuf field: repeated double repeated_double = 42;
     */
    repeatedDouble: number[];
    /**
     * @generated from protobuf field: repeated bool repeated_bool = 43;
     */
    repeatedBool: boolean[];
    /**
     * @generated from protobuf field: repeated string repeated_string = 44;
     */
    repeatedString: string[];
    /**
     * @generated from protobuf field: repeated bytes repeated_bytes = 45;
     */
    repeatedBytes: Uint8Array[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
     */
    repeatedNestedMessage: TestAllTypes_NestedMessage[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
     */
    repeatedForeignMessage: ForeignMessage[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest_import.ImportMessage repeated_import_message = 50;
     */
    repeatedImportMessage: ImportMessage[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
     */
    repeatedNestedEnum: TestAllTypes_NestedEnum[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
     */
    repeatedForeignEnum: ForeignEnum[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
     */
    repeatedImportEnum: ImportEnum[];
    /**
     * @generated from protobuf field: repeated string repeated_string_piece = 54;
     */
    repeatedStringPiece: string[];
    /**
     * @generated from protobuf field: repeated string repeated_cord = 55;
     */
    repeatedCord: string[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57;
     */
    repeatedLazyMessage: TestAllTypes_NestedMessage[];
    /**
     * Singular with defaults
     *
     * @generated from protobuf field: optional int32 default_int32 = 61;
     */
    defaultInt32?: number;
    /**
     * @generated from protobuf field: optional int64 default_int64 = 62;
     */
    defaultInt64?: bigint;
    /**
     * @generated from protobuf field: optional uint32 default_uint32 = 63;
     */
    defaultUint32?: number;
    /**
     * @generated from protobuf field: optional uint64 default_uint64 = 64;
     */
    defaultUint64?: bigint;
    /**
     * @generated from protobuf field: optional sint32 default_sint32 = 65;
     */
    defaultSint32?: number;
    /**
     * @generated from protobuf field: optional sint64 default_sint64 = 66;
     */
    defaultSint64?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 default_fixed32 = 67;
     */
    defaultFixed32?: number;
    /**
     * @generated from protobuf field: optional fixed64 default_fixed64 = 68;
     */
    defaultFixed64?: bigint;
    /**
     * @generated from protobuf field: optional sfixed32 default_sfixed32 = 69;
     */
    defaultSfixed32?: number;
    /**
     * @generated from protobuf field: optional sfixed64 default_sfixed64 = 70;
     */
    defaultSfixed64?: bigint;
    /**
     * @generated from protobuf field: optional float default_float = 71;
     */
    defaultFloat?: number;
    /**
     * @generated from protobuf field: optional double default_double = 72;
     */
    defaultDouble?: number;
    /**
     * @generated from protobuf field: optional bool default_bool = 73;
     */
    defaultBool?: boolean;
    /**
     * @generated from protobuf field: optional string default_string = 74;
     */
    defaultString?: string;
    /**
     * @generated from protobuf field: optional bytes default_bytes = 75;
     */
    defaultBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81;
     */
    defaultNestedEnum?: TestAllTypes_NestedEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum default_foreign_enum = 82;
     */
    defaultForeignEnum?: ForeignEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest_import.ImportEnum default_import_enum = 83;
     */
    defaultImportEnum?: ImportEnum;
    /**
     * @generated from protobuf field: optional string default_string_piece = 84;
     */
    defaultStringPiece?: string;
    /**
     * @generated from protobuf field: optional string default_cord = 85;
     */
    defaultCord?: string;
    /**
     * @generated from protobuf oneof: oneof_field
     */
    oneofField: {
        oneofKind: "oneofUint32";
        /**
         * @generated from protobuf field: uint32 oneof_uint32 = 111;
         */
        oneofUint32: number;
    } | {
        oneofKind: "oneofNestedMessage";
        /**
         * @generated from protobuf field: protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message = 112;
         */
        oneofNestedMessage: TestAllTypes_NestedMessage;
    } | {
        oneofKind: "oneofString";
        /**
         * @generated from protobuf field: string oneof_string = 113;
         */
        oneofString: string;
    } | {
        oneofKind: "oneofBytes";
        /**
         * @generated from protobuf field: bytes oneof_bytes = 114;
         */
        oneofBytes: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestAllTypes.NestedMessage
 */
export interface TestAllTypes_NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     *
     * @generated from protobuf field: optional int32 bb = 1;
     */
    bb?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestAllTypes.OptionalGroup
 */
export interface TestAllTypes_OptionalGroup {
    /**
     * @generated from protobuf field: optional int32 a = 17;
     */
    a?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestAllTypes.RepeatedGroup
 */
export interface TestAllTypes_RepeatedGroup {
    /**
     * @generated from protobuf field: optional int32 a = 47;
     */
    a?: number;
}
/**
 * @generated from protobuf enum protobuf_unittest.TestAllTypes.NestedEnum
 */
export enum TestAllTypes_NestedEnum {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FOO = 1;
     */
    FOO = 1,
    /**
     * @generated from protobuf enum value: BAR = 2;
     */
    BAR = 2,
    /**
     * @generated from protobuf enum value: BAZ = 3;
     */
    BAZ = 3,
    /**
     * Intentionally negative.
     *
     * @generated from protobuf enum value: NEG = -1;
     */
    NEG = -1
}
/**
 * This proto includes a recursively nested message.
 *
 * @generated from protobuf message protobuf_unittest.NestedTestAllTypes
 */
export interface NestedTestAllTypes {
    /**
     * @generated from protobuf field: optional protobuf_unittest.NestedTestAllTypes child = 1;
     */
    child?: NestedTestAllTypes;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes payload = 2;
     */
    payload?: TestAllTypes;
    /**
     * @generated from protobuf field: repeated protobuf_unittest.NestedTestAllTypes repeated_child = 3;
     */
    repeatedChild: NestedTestAllTypes[];
}
/**
 * @generated from protobuf message protobuf_unittest.TestDeprecatedFields
 */
export interface TestDeprecatedFields {
    /**
     * @deprecated
     * @generated from protobuf field: optional int32 deprecated_int32 = 1 [deprecated = true];
     */
    deprecatedInt32?: number;
    /**
     * @generated from protobuf oneof: oneof_fields
     */
    oneofFields: {
        oneofKind: "deprecatedInt32InOneof";
        /**
         * @deprecated
         * @generated from protobuf field: int32 deprecated_int32_in_oneof = 2 [deprecated = true];
         */
        deprecatedInt32InOneof: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @deprecated
 * @generated from protobuf message protobuf_unittest.TestDeprecatedMessage
 */
export interface TestDeprecatedMessage {
}
/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 *
 * @generated from protobuf message protobuf_unittest.ForeignMessage
 */
export interface ForeignMessage {
    /**
     * @generated from protobuf field: optional int32 c = 1;
     */
    c?: number;
    /**
     * @generated from protobuf field: optional int32 d = 2;
     */
    d?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestReservedFields
 */
export interface TestReservedFields {
}
/**
 * @generated from protobuf message protobuf_unittest.TestAllExtensions
 */
export interface TestAllExtensions {
}
/**
 * @generated from protobuf message protobuf_unittest.OptionalGroup_extension
 */
export interface OptionalGroup_extension {
    /**
     * @generated from protobuf field: optional int32 a = 17;
     */
    a?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.RepeatedGroup_extension
 */
export interface RepeatedGroup_extension {
    /**
     * @generated from protobuf field: optional int32 a = 47;
     */
    a?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestGroup
 */
export interface TestGroup {
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
     */
    optionalForeignEnum?: ForeignEnum;
}
/**
 * @generated from protobuf message protobuf_unittest.TestGroup.OptionalGroup
 */
export interface TestGroup_OptionalGroup {
    /**
     * @generated from protobuf field: optional int32 a = 17;
     */
    a?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestGroupExtension
 */
export interface TestGroupExtension {
}
/**
 * @generated from protobuf message protobuf_unittest.TestNestedExtension
 */
export interface TestNestedExtension {
}
/**
 * @generated from protobuf message protobuf_unittest.TestNestedExtension.OptionalGroup_extension
 */
export interface TestNestedExtension_OptionalGroup_extension {
    /**
     * @generated from protobuf field: optional int32 a = 17;
     */
    a?: number;
}
/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 *
 * @generated from protobuf message protobuf_unittest.TestRequired
 */
export interface TestRequired {
    /**
     * @generated from protobuf field: int32 a = 1;
     */
    a: number;
    /**
     * @generated from protobuf field: optional int32 dummy2 = 2;
     */
    dummy2?: number;
    /**
     * @generated from protobuf field: int32 b = 3;
     */
    b: number;
    /**
     * Pad the field count to 32 so that we can test that IsInitialized()
     * properly checks multiple elements of has_bits_.
     *
     * @generated from protobuf field: optional int32 dummy4 = 4;
     */
    dummy4?: number;
    /**
     * @generated from protobuf field: optional int32 dummy5 = 5;
     */
    dummy5?: number;
    /**
     * @generated from protobuf field: optional int32 dummy6 = 6;
     */
    dummy6?: number;
    /**
     * @generated from protobuf field: optional int32 dummy7 = 7;
     */
    dummy7?: number;
    /**
     * @generated from protobuf field: optional int32 dummy8 = 8;
     */
    dummy8?: number;
    /**
     * @generated from protobuf field: optional int32 dummy9 = 9;
     */
    dummy9?: number;
    /**
     * @generated from protobuf field: optional int32 dummy10 = 10;
     */
    dummy10?: number;
    /**
     * @generated from protobuf field: optional int32 dummy11 = 11;
     */
    dummy11?: number;
    /**
     * @generated from protobuf field: optional int32 dummy12 = 12;
     */
    dummy12?: number;
    /**
     * @generated from protobuf field: optional int32 dummy13 = 13;
     */
    dummy13?: number;
    /**
     * @generated from protobuf field: optional int32 dummy14 = 14;
     */
    dummy14?: number;
    /**
     * @generated from protobuf field: optional int32 dummy15 = 15;
     */
    dummy15?: number;
    /**
     * @generated from protobuf field: optional int32 dummy16 = 16;
     */
    dummy16?: number;
    /**
     * @generated from protobuf field: optional int32 dummy17 = 17;
     */
    dummy17?: number;
    /**
     * @generated from protobuf field: optional int32 dummy18 = 18;
     */
    dummy18?: number;
    /**
     * @generated from protobuf field: optional int32 dummy19 = 19;
     */
    dummy19?: number;
    /**
     * @generated from protobuf field: optional int32 dummy20 = 20;
     */
    dummy20?: number;
    /**
     * @generated from protobuf field: optional int32 dummy21 = 21;
     */
    dummy21?: number;
    /**
     * @generated from protobuf field: optional int32 dummy22 = 22;
     */
    dummy22?: number;
    /**
     * @generated from protobuf field: optional int32 dummy23 = 23;
     */
    dummy23?: number;
    /**
     * @generated from protobuf field: optional int32 dummy24 = 24;
     */
    dummy24?: number;
    /**
     * @generated from protobuf field: optional int32 dummy25 = 25;
     */
    dummy25?: number;
    /**
     * @generated from protobuf field: optional int32 dummy26 = 26;
     */
    dummy26?: number;
    /**
     * @generated from protobuf field: optional int32 dummy27 = 27;
     */
    dummy27?: number;
    /**
     * @generated from protobuf field: optional int32 dummy28 = 28;
     */
    dummy28?: number;
    /**
     * @generated from protobuf field: optional int32 dummy29 = 29;
     */
    dummy29?: number;
    /**
     * @generated from protobuf field: optional int32 dummy30 = 30;
     */
    dummy30?: number;
    /**
     * @generated from protobuf field: optional int32 dummy31 = 31;
     */
    dummy31?: number;
    /**
     * @generated from protobuf field: optional int32 dummy32 = 32;
     */
    dummy32?: number;
    /**
     * @generated from protobuf field: int32 c = 33;
     */
    c: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestRequiredForeign
 */
export interface TestRequiredForeign {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestRequired optional_message = 1;
     */
    optionalMessage?: TestRequired;
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestRequired repeated_message = 2;
     */
    repeatedMessage: TestRequired[];
    /**
     * @generated from protobuf field: optional int32 dummy = 3;
     */
    dummy?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestRequiredMessage
 */
export interface TestRequiredMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestRequired optional_message = 1;
     */
    optionalMessage?: TestRequired;
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestRequired repeated_message = 2;
     */
    repeatedMessage: TestRequired[];
    /**
     * @generated from protobuf field: protobuf_unittest.TestRequired required_message = 3;
     */
    requiredMessage?: TestRequired;
}
/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 *
 * @generated from protobuf message protobuf_unittest.TestForeignNested
 */
export interface TestForeignNested {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes.NestedMessage foreign_nested = 1;
     */
    foreignNested?: TestAllTypes_NestedMessage;
}
/**
 * TestEmptyMessage is used to test unknown field support.
 *
 * @generated from protobuf message protobuf_unittest.TestEmptyMessage
 */
export interface TestEmptyMessage {
}
/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 *
 * @generated from protobuf message protobuf_unittest.TestEmptyMessageWithExtensions
 */
export interface TestEmptyMessageWithExtensions {
}
/**
 * Needed for a Python test.
 *
 * @generated from protobuf message protobuf_unittest.TestPickleNestedMessage
 */
export interface TestPickleNestedMessage {
}
/**
 * @generated from protobuf message protobuf_unittest.TestPickleNestedMessage.NestedMessage
 */
export interface TestPickleNestedMessage_NestedMessage {
    /**
     * @generated from protobuf field: optional int32 bb = 1;
     */
    bb?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestPickleNestedMessage.NestedMessage.NestedNestedMessage
 */
export interface TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
    /**
     * @generated from protobuf field: optional int32 cc = 1;
     */
    cc?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestMultipleExtensionRanges
 */
export interface TestMultipleExtensionRanges {
}
/**
 * Test that really large tag numbers don't break anything.
 *
 * @generated from protobuf message protobuf_unittest.TestReallyLargeTagNumber
 */
export interface TestReallyLargeTagNumber {
    /**
     * The largest possible tag number is 2^28 - 1, since the wire format uses
     * three bits to communicate wire type.
     *
     * @generated from protobuf field: optional int32 a = 1;
     */
    a?: number;
    /**
     * @generated from protobuf field: optional int32 bb = 268435455;
     */
    bb?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestRecursiveMessage
 */
export interface TestRecursiveMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestRecursiveMessage a = 1;
     */
    a?: TestRecursiveMessage;
    /**
     * @generated from protobuf field: optional int32 i = 2;
     */
    i?: number;
}
/**
 * Test that mutual recursion works.
 *
 * @generated from protobuf message protobuf_unittest.TestMutualRecursionA
 */
export interface TestMutualRecursionA {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestMutualRecursionB bb = 1;
     */
    bb?: TestMutualRecursionB;
}
/**
 * @generated from protobuf message protobuf_unittest.TestMutualRecursionA.SubMessage
 */
export interface TestMutualRecursionA_SubMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestMutualRecursionB b = 1;
     */
    b?: TestMutualRecursionB;
}
/**
 * @generated from protobuf message protobuf_unittest.TestMutualRecursionA.SubGroup
 */
export interface TestMutualRecursionA_SubGroup {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestMutualRecursionA.SubMessage sub_message = 3;
     */
    subMessage?: TestMutualRecursionA_SubMessage; // Needed because of bug in javatest
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes not_in_this_scc = 4;
     */
    notInThisScc?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestMutualRecursionB
 */
export interface TestMutualRecursionB {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestMutualRecursionA a = 1;
     */
    a?: TestMutualRecursionA;
    /**
     * @generated from protobuf field: optional int32 optional_int32 = 2;
     */
    optionalInt32?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestIsInitialized
 */
export interface TestIsInitialized {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestIsInitialized.SubMessage sub_message = 1;
     */
    subMessage?: TestIsInitialized_SubMessage;
}
/**
 * @generated from protobuf message protobuf_unittest.TestIsInitialized.SubMessage
 */
export interface TestIsInitialized_SubMessage {
}
/**
 * @generated from protobuf message protobuf_unittest.TestIsInitialized.SubMessage.SubGroup
 */
export interface TestIsInitialized_SubMessage_SubGroup {
    /**
     * @generated from protobuf field: int32 i = 2;
     */
    i: number;
}
/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 *
 * NO_PROTO1
 *
 * @generated from protobuf message protobuf_unittest.TestDupFieldNumber
 */
export interface TestDupFieldNumber {
    /**
     * @generated from protobuf field: optional int32 a = 1;
     */
    a?: number; // NO_PROTO1
}
/**
 * @generated from protobuf message protobuf_unittest.TestDupFieldNumber.Foo
 */
export interface TestDupFieldNumber_Foo {
    /**
     * @generated from protobuf field: optional int32 a = 1;
     */
    a?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestDupFieldNumber.Bar
 */
export interface TestDupFieldNumber_Bar {
    /**
     * @generated from protobuf field: optional int32 a = 1;
     */
    a?: number;
}
/**
 * Additional messages for testing lazy fields.
 *
 * @generated from protobuf message protobuf_unittest.TestEagerMessage
 */
export interface TestEagerMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes sub_message = 1;
     */
    subMessage?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestLazyMessage
 */
export interface TestLazyMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes sub_message = 1;
     */
    subMessage?: TestAllTypes;
}
/**
 * Needed for a Python test.
 *
 * @generated from protobuf message protobuf_unittest.TestNestedMessageHasBits
 */
export interface TestNestedMessageHasBits {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestNestedMessageHasBits.NestedMessage optional_nested_message = 1;
     */
    optionalNestedMessage?: TestNestedMessageHasBits_NestedMessage;
}
/**
 * @generated from protobuf message protobuf_unittest.TestNestedMessageHasBits.NestedMessage
 */
export interface TestNestedMessageHasBits_NestedMessage {
    /**
     * @generated from protobuf field: repeated int32 nestedmessage_repeated_int32 = 1;
     */
    nestedmessageRepeatedInt32: number[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignMessage nestedmessage_repeated_foreignmessage = 2;
     */
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
}
/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 *
 * @generated from protobuf message protobuf_unittest.TestCamelCaseFieldNames
 */
export interface TestCamelCaseFieldNames {
    /**
     * @generated from protobuf field: optional int32 PrimitiveField = 1 [json_name = "PrimitiveField"];
     */
    primitiveField?: number;
    /**
     * @generated from protobuf field: optional string StringField = 2 [json_name = "StringField"];
     */
    stringField?: string;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum EnumField = 3 [json_name = "EnumField"];
     */
    enumField?: ForeignEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignMessage MessageField = 4 [json_name = "MessageField"];
     */
    messageField?: ForeignMessage;
    /**
     * @generated from protobuf field: optional string StringPieceField = 5 [json_name = "StringPieceField"];
     */
    stringPieceField?: string;
    /**
     * @generated from protobuf field: optional string CordField = 6 [json_name = "CordField"];
     */
    cordField?: string;
    /**
     * @generated from protobuf field: repeated int32 RepeatedPrimitiveField = 7 [json_name = "RepeatedPrimitiveField"];
     */
    repeatedPrimitiveField: number[];
    /**
     * @generated from protobuf field: repeated string RepeatedStringField = 8 [json_name = "RepeatedStringField"];
     */
    repeatedStringField: string[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignEnum RepeatedEnumField = 9 [json_name = "RepeatedEnumField"];
     */
    repeatedEnumField: ForeignEnum[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignMessage RepeatedMessageField = 10 [json_name = "RepeatedMessageField"];
     */
    repeatedMessageField: ForeignMessage[];
    /**
     * @generated from protobuf field: repeated string RepeatedStringPieceField = 11 [json_name = "RepeatedStringPieceField"];
     */
    repeatedStringPieceField: string[];
    /**
     * @generated from protobuf field: repeated string RepeatedCordField = 12 [json_name = "RepeatedCordField"];
     */
    repeatedCordField: string[];
}
/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 *
 * @generated from protobuf message protobuf_unittest.TestFieldOrderings
 */
export interface TestFieldOrderings {
    /**
     * @generated from protobuf field: optional string my_string = 11;
     */
    myString?: string;
    /**
     * @generated from protobuf field: optional int64 my_int = 1;
     */
    myInt?: bigint;
    /**
     * @generated from protobuf field: optional float my_float = 101;
     */
    myFloat?: number;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestFieldOrderings.NestedMessage optional_nested_message = 200;
     */
    optionalNestedMessage?: TestFieldOrderings_NestedMessage;
}
/**
 * @generated from protobuf message protobuf_unittest.TestFieldOrderings.NestedMessage
 */
export interface TestFieldOrderings_NestedMessage {
    /**
     * @generated from protobuf field: optional int64 oo = 2;
     */
    oo?: bigint;
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     *
     * @generated from protobuf field: optional int32 bb = 1;
     */
    bb?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestExtensionOrderings1
 */
export interface TestExtensionOrderings1 {
    /**
     * @generated from protobuf field: optional string my_string = 1;
     */
    myString?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestExtensionOrderings2
 */
export interface TestExtensionOrderings2 {
    /**
     * @generated from protobuf field: optional string my_string = 1;
     */
    myString?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3
 */
export interface TestExtensionOrderings2_TestExtensionOrderings3 {
    /**
     * @generated from protobuf field: optional string my_string = 1;
     */
    myString?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestExtremeDefaultValues
 */
export interface TestExtremeDefaultValues {
    /**
     * @generated from protobuf field: optional bytes escaped_bytes = 1;
     */
    escapedBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 large_uint32 = 2;
     */
    largeUint32?: number;
    /**
     * @generated from protobuf field: optional uint64 large_uint64 = 3;
     */
    largeUint64?: bigint;
    /**
     * @generated from protobuf field: optional int32 small_int32 = 4;
     */
    smallInt32?: number;
    /**
     * @generated from protobuf field: optional int64 small_int64 = 5;
     */
    smallInt64?: bigint;
    /**
     * @generated from protobuf field: optional int32 really_small_int32 = 21;
     */
    reallySmallInt32?: number;
    /**
     * @generated from protobuf field: optional int64 really_small_int64 = 22;
     */
    reallySmallInt64?: bigint;
    /**
     * The default value here is UTF-8 for "\u1234".  (We could also just type
     * the UTF-8 text directly into this text file rather than escape it, but
     * lots of people use editors that would be confused by this.)
     *
     * @generated from protobuf field: optional string utf8_string = 6;
     */
    utf8String?: string;
    /**
     * Tests for single-precision floating-point values.
     *
     * @generated from protobuf field: optional float zero_float = 7;
     */
    zeroFloat?: number;
    /**
     * @generated from protobuf field: optional float one_float = 8;
     */
    oneFloat?: number;
    /**
     * @generated from protobuf field: optional float small_float = 9;
     */
    smallFloat?: number;
    /**
     * @generated from protobuf field: optional float negative_one_float = 10;
     */
    negativeOneFloat?: number;
    /**
     * @generated from protobuf field: optional float negative_float = 11;
     */
    negativeFloat?: number;
    /**
     * Using exponents
     *
     * @generated from protobuf field: optional float large_float = 12;
     */
    largeFloat?: number;
    /**
     * @generated from protobuf field: optional float small_negative_float = 13;
     */
    smallNegativeFloat?: number;
    /**
     * Text for nonfinite floating-point values.
     *
     * @generated from protobuf field: optional double inf_double = 14;
     */
    infDouble?: number;
    /**
     * @generated from protobuf field: optional double neg_inf_double = 15;
     */
    negInfDouble?: number;
    /**
     * @generated from protobuf field: optional double nan_double = 16;
     */
    nanDouble?: number;
    /**
     * @generated from protobuf field: optional float inf_float = 17;
     */
    infFloat?: number;
    /**
     * @generated from protobuf field: optional float neg_inf_float = 18;
     */
    negInfFloat?: number;
    /**
     * @generated from protobuf field: optional float nan_float = 19;
     */
    nanFloat?: number;
    /**
     * Tests for C++ trigraphs.
     * Trigraphs should be escaped in C++ generated files, but they should not be
     * escaped for other languages.
     * Note that in .proto file, "\?" is a valid way to escape ? in string
     * literals.
     *
     * @generated from protobuf field: optional string cpp_trigraph = 20;
     */
    cppTrigraph?: string;
    /**
     * String defaults containing the character '\000'
     *
     * @generated from protobuf field: optional string string_with_zero = 23;
     */
    stringWithZero?: string;
    /**
     * @generated from protobuf field: optional bytes bytes_with_zero = 24;
     */
    bytesWithZero?: Uint8Array;
    /**
     * @generated from protobuf field: optional string string_piece_with_zero = 25;
     */
    stringPieceWithZero?: string;
    /**
     * @generated from protobuf field: optional string cord_with_zero = 26;
     */
    cordWithZero?: string;
    /**
     * @generated from protobuf field: optional string replacement_string = 27;
     */
    replacementString?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.SparseEnumMessage
 */
export interface SparseEnumMessage {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestSparseEnum sparse_enum = 1;
     */
    sparseEnum?: TestSparseEnum;
}
/**
 * Test String and Bytes: string is for valid UTF-8 strings
 *
 * @generated from protobuf message protobuf_unittest.OneString
 */
export interface OneString {
    /**
     * @generated from protobuf field: optional string data = 1;
     */
    data?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.MoreString
 */
export interface MoreString {
    /**
     * @generated from protobuf field: repeated string data = 1;
     */
    data: string[];
}
/**
 * @generated from protobuf message protobuf_unittest.OneBytes
 */
export interface OneBytes {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message protobuf_unittest.MoreBytes
 */
export interface MoreBytes {
    /**
     * @generated from protobuf field: repeated bytes data = 1;
     */
    data: Uint8Array[];
}
/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 *
 * @generated from protobuf message protobuf_unittest.Int32Message
 */
export interface Int32Message {
    /**
     * @generated from protobuf field: optional int32 data = 1;
     */
    data?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.Uint32Message
 */
export interface Uint32Message {
    /**
     * @generated from protobuf field: optional uint32 data = 1;
     */
    data?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.Int64Message
 */
export interface Int64Message {
    /**
     * @generated from protobuf field: optional int64 data = 1;
     */
    data?: bigint;
}
/**
 * @generated from protobuf message protobuf_unittest.Uint64Message
 */
export interface Uint64Message {
    /**
     * @generated from protobuf field: optional uint64 data = 1;
     */
    data?: bigint;
}
/**
 * @generated from protobuf message protobuf_unittest.BoolMessage
 */
export interface BoolMessage {
    /**
     * @generated from protobuf field: optional bool data = 1;
     */
    data?: boolean;
}
/**
 * Test oneofs.
 *
 * @generated from protobuf message protobuf_unittest.TestOneof
 */
export interface TestOneof {
    /**
     * @generated from protobuf oneof: foo
     */
    foo: {
        oneofKind: "fooInt";
        /**
         * @generated from protobuf field: int32 foo_int = 1;
         */
        fooInt: number;
    } | {
        oneofKind: "fooString";
        /**
         * @generated from protobuf field: string foo_string = 2;
         */
        fooString: string;
    } | {
        oneofKind: "fooMessage";
        /**
         * @generated from protobuf field: protobuf_unittest.TestAllTypes foo_message = 3;
         */
        fooMessage: TestAllTypes;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneof.FooGroup
 */
export interface TestOneof_FooGroup {
    /**
     * @generated from protobuf field: optional int32 a = 5;
     */
    a?: number;
    /**
     * @generated from protobuf field: optional string b = 6;
     */
    b?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneofBackwardsCompatible
 */
export interface TestOneofBackwardsCompatible {
    /**
     * @generated from protobuf field: optional int32 foo_int = 1;
     */
    fooInt?: number;
    /**
     * @generated from protobuf field: optional string foo_string = 2;
     */
    fooString?: string;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes foo_message = 3;
     */
    fooMessage?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneofBackwardsCompatible.FooGroup
 */
export interface TestOneofBackwardsCompatible_FooGroup {
    /**
     * @generated from protobuf field: optional int32 a = 5;
     */
    a?: number;
    /**
     * @generated from protobuf field: optional string b = 6;
     */
    b?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneof2
 */
export interface TestOneof2 {
    /**
     * @generated from protobuf oneof: foo
     */
    foo: {
        oneofKind: "fooInt";
        /**
         * @generated from protobuf field: int32 foo_int = 1;
         */
        fooInt: number;
    } | {
        oneofKind: "fooString";
        /**
         * @generated from protobuf field: string foo_string = 2;
         */
        fooString: string;
    } | {
        oneofKind: "fooCord";
        /**
         * @generated from protobuf field: string foo_cord = 3;
         */
        fooCord: string;
    } | {
        oneofKind: "fooStringPiece";
        /**
         * @generated from protobuf field: string foo_string_piece = 4;
         */
        fooStringPiece: string;
    } | {
        oneofKind: "fooBytes";
        /**
         * @generated from protobuf field: bytes foo_bytes = 5;
         */
        fooBytes: Uint8Array;
    } | {
        oneofKind: "fooEnum";
        /**
         * @generated from protobuf field: protobuf_unittest.TestOneof2.NestedEnum foo_enum = 6;
         */
        fooEnum: TestOneof2_NestedEnum;
    } | {
        oneofKind: "fooMessage";
        /**
         * @generated from protobuf field: protobuf_unittest.TestOneof2.NestedMessage foo_message = 7;
         */
        fooMessage: TestOneof2_NestedMessage;
    } | {
        oneofKind: "fooLazyMessage";
        /**
         * @generated from protobuf field: protobuf_unittest.TestOneof2.NestedMessage foo_lazy_message = 11;
         */
        fooLazyMessage: TestOneof2_NestedMessage;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: bar
     */
    bar: {
        oneofKind: "barInt";
        /**
         * @generated from protobuf field: int32 bar_int = 12;
         */
        barInt: number;
    } | {
        oneofKind: "barString";
        /**
         * @generated from protobuf field: string bar_string = 13;
         */
        barString: string;
    } | {
        oneofKind: "barCord";
        /**
         * @generated from protobuf field: string bar_cord = 14;
         */
        barCord: string;
    } | {
        oneofKind: "barStringPiece";
        /**
         * @generated from protobuf field: string bar_string_piece = 15;
         */
        barStringPiece: string;
    } | {
        oneofKind: "barBytes";
        /**
         * @generated from protobuf field: bytes bar_bytes = 16;
         */
        barBytes: Uint8Array;
    } | {
        oneofKind: "barEnum";
        /**
         * @generated from protobuf field: protobuf_unittest.TestOneof2.NestedEnum bar_enum = 17;
         */
        barEnum: TestOneof2_NestedEnum;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: optional int32 baz_int = 18;
     */
    bazInt?: number;
    /**
     * @generated from protobuf field: optional string baz_string = 19;
     */
    bazString?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneof2.FooGroup
 */
export interface TestOneof2_FooGroup {
    /**
     * @generated from protobuf field: optional int32 a = 9;
     */
    a?: number;
    /**
     * @generated from protobuf field: optional string b = 10;
     */
    b?: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestOneof2.NestedMessage
 */
export interface TestOneof2_NestedMessage {
    /**
     * @generated from protobuf field: optional int64 qux_int = 1;
     */
    quxInt?: bigint;
    /**
     * @generated from protobuf field: repeated int32 corge_int = 2;
     */
    corgeInt: number[];
}
/**
 * @generated from protobuf enum protobuf_unittest.TestOneof2.NestedEnum
 */
export enum TestOneof2_NestedEnum {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FOO = 1;
     */
    FOO = 1,
    /**
     * @generated from protobuf enum value: BAR = 2;
     */
    BAR = 2,
    /**
     * @generated from protobuf enum value: BAZ = 3;
     */
    BAZ = 3
}
/**
 * @generated from protobuf message protobuf_unittest.TestRequiredOneof
 */
export interface TestRequiredOneof {
    /**
     * @generated from protobuf oneof: foo
     */
    foo: {
        oneofKind: "fooInt";
        /**
         * @generated from protobuf field: int32 foo_int = 1;
         */
        fooInt: number;
    } | {
        oneofKind: "fooString";
        /**
         * @generated from protobuf field: string foo_string = 2;
         */
        fooString: string;
    } | {
        oneofKind: "fooMessage";
        /**
         * @generated from protobuf field: protobuf_unittest.TestRequiredOneof.NestedMessage foo_message = 3;
         */
        fooMessage: TestRequiredOneof_NestedMessage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestRequiredOneof.NestedMessage
 */
export interface TestRequiredOneof_NestedMessage {
    /**
     * @generated from protobuf field: double required_double = 1;
     */
    requiredDouble: number;
}
// Test messages for packed fields

/**
 * @generated from protobuf message protobuf_unittest.TestPackedTypes
 */
export interface TestPackedTypes {
    /**
     * @generated from protobuf field: repeated int32 packed_int32 = 90 [packed = true];
     */
    packedInt32: number[];
    /**
     * @generated from protobuf field: repeated int64 packed_int64 = 91 [packed = true];
     */
    packedInt64: bigint[];
    /**
     * @generated from protobuf field: repeated uint32 packed_uint32 = 92 [packed = true];
     */
    packedUint32: number[];
    /**
     * @generated from protobuf field: repeated uint64 packed_uint64 = 93 [packed = true];
     */
    packedUint64: bigint[];
    /**
     * @generated from protobuf field: repeated sint32 packed_sint32 = 94 [packed = true];
     */
    packedSint32: number[];
    /**
     * @generated from protobuf field: repeated sint64 packed_sint64 = 95 [packed = true];
     */
    packedSint64: bigint[];
    /**
     * @generated from protobuf field: repeated fixed32 packed_fixed32 = 96 [packed = true];
     */
    packedFixed32: number[];
    /**
     * @generated from protobuf field: repeated fixed64 packed_fixed64 = 97 [packed = true];
     */
    packedFixed64: bigint[];
    /**
     * @generated from protobuf field: repeated sfixed32 packed_sfixed32 = 98 [packed = true];
     */
    packedSfixed32: number[];
    /**
     * @generated from protobuf field: repeated sfixed64 packed_sfixed64 = 99 [packed = true];
     */
    packedSfixed64: bigint[];
    /**
     * @generated from protobuf field: repeated float packed_float = 100 [packed = true];
     */
    packedFloat: number[];
    /**
     * @generated from protobuf field: repeated double packed_double = 101 [packed = true];
     */
    packedDouble: number[];
    /**
     * @generated from protobuf field: repeated bool packed_bool = 102 [packed = true];
     */
    packedBool: boolean[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignEnum packed_enum = 103 [packed = true];
     */
    packedEnum: ForeignEnum[];
}
/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 *
 * @generated from protobuf message protobuf_unittest.TestUnpackedTypes
 */
export interface TestUnpackedTypes {
    /**
     * @generated from protobuf field: repeated int32 unpacked_int32 = 90 [packed = false];
     */
    unpackedInt32: number[];
    /**
     * @generated from protobuf field: repeated int64 unpacked_int64 = 91 [packed = false];
     */
    unpackedInt64: bigint[];
    /**
     * @generated from protobuf field: repeated uint32 unpacked_uint32 = 92 [packed = false];
     */
    unpackedUint32: number[];
    /**
     * @generated from protobuf field: repeated uint64 unpacked_uint64 = 93 [packed = false];
     */
    unpackedUint64: bigint[];
    /**
     * @generated from protobuf field: repeated sint32 unpacked_sint32 = 94 [packed = false];
     */
    unpackedSint32: number[];
    /**
     * @generated from protobuf field: repeated sint64 unpacked_sint64 = 95 [packed = false];
     */
    unpackedSint64: bigint[];
    /**
     * @generated from protobuf field: repeated fixed32 unpacked_fixed32 = 96 [packed = false];
     */
    unpackedFixed32: number[];
    /**
     * @generated from protobuf field: repeated fixed64 unpacked_fixed64 = 97 [packed = false];
     */
    unpackedFixed64: bigint[];
    /**
     * @generated from protobuf field: repeated sfixed32 unpacked_sfixed32 = 98 [packed = false];
     */
    unpackedSfixed32: number[];
    /**
     * @generated from protobuf field: repeated sfixed64 unpacked_sfixed64 = 99 [packed = false];
     */
    unpackedSfixed64: bigint[];
    /**
     * @generated from protobuf field: repeated float unpacked_float = 100 [packed = false];
     */
    unpackedFloat: number[];
    /**
     * @generated from protobuf field: repeated double unpacked_double = 101 [packed = false];
     */
    unpackedDouble: number[];
    /**
     * @generated from protobuf field: repeated bool unpacked_bool = 102 [packed = false];
     */
    unpackedBool: boolean[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.ForeignEnum unpacked_enum = 103 [packed = false];
     */
    unpackedEnum: ForeignEnum[];
}
/**
 * @generated from protobuf message protobuf_unittest.TestPackedExtensions
 */
export interface TestPackedExtensions {
}
/**
 * @generated from protobuf message protobuf_unittest.TestUnpackedExtensions
 */
export interface TestUnpackedExtensions {
}
/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 *
 * @generated from protobuf message protobuf_unittest.TestDynamicExtensions
 */
export interface TestDynamicExtensions {
    /**
     * @generated from protobuf field: optional fixed32 scalar_extension = 2000;
     */
    scalarExtension?: number;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum enum_extension = 2001;
     */
    enumExtension?: ForeignEnum;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestDynamicExtensions.DynamicEnumType dynamic_enum_extension = 2002;
     */
    dynamicEnumExtension?: TestDynamicExtensions_DynamicEnumType;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignMessage message_extension = 2003;
     */
    messageExtension?: ForeignMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestDynamicExtensions.DynamicMessageType dynamic_message_extension = 2004;
     */
    dynamicMessageExtension?: TestDynamicExtensions_DynamicMessageType;
    /**
     * @generated from protobuf field: repeated string repeated_extension = 2005;
     */
    repeatedExtension: string[];
    /**
     * @generated from protobuf field: repeated sint32 packed_extension = 2006 [packed = true];
     */
    packedExtension: number[];
}
/**
 * @generated from protobuf message protobuf_unittest.TestDynamicExtensions.DynamicMessageType
 */
export interface TestDynamicExtensions_DynamicMessageType {
    /**
     * @generated from protobuf field: optional int32 dynamic_field = 2100;
     */
    dynamicField?: number;
}
/**
 * @generated from protobuf enum protobuf_unittest.TestDynamicExtensions.DynamicEnumType
 */
export enum TestDynamicExtensions_DynamicEnumType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: DYNAMIC_FOO = 2200;
     */
    DYNAMIC_FOO = 2200,
    /**
     * @generated from protobuf enum value: DYNAMIC_BAR = 2201;
     */
    DYNAMIC_BAR = 2201,
    /**
     * @generated from protobuf enum value: DYNAMIC_BAZ = 2202;
     */
    DYNAMIC_BAZ = 2202
}
/**
 * @generated from protobuf message protobuf_unittest.TestRepeatedScalarDifferentTagSizes
 */
export interface TestRepeatedScalarDifferentTagSizes {
    /**
     * Parsing repeated fixed size values used to fail. This message needs to be
     * used in order to get a tag of the right size; all of the repeated fields
     * in TestAllTypes didn't trigger the check.
     *
     * @generated from protobuf field: repeated fixed32 repeated_fixed32 = 12;
     */
    repeatedFixed32: number[];
    /**
     * Check for a varint type, just for good measure.
     *
     * @generated from protobuf field: repeated int32 repeated_int32 = 13;
     */
    repeatedInt32: number[];
    /**
     * These have two-byte tags.
     *
     * @generated from protobuf field: repeated fixed64 repeated_fixed64 = 2046;
     */
    repeatedFixed64: bigint[];
    /**
     * @generated from protobuf field: repeated int64 repeated_int64 = 2047;
     */
    repeatedInt64: bigint[];
    /**
     * Three byte tags.
     *
     * @generated from protobuf field: repeated float repeated_float = 262142;
     */
    repeatedFloat: number[];
    /**
     * @generated from protobuf field: repeated uint64 repeated_uint64 = 262143;
     */
    repeatedUint64: bigint[];
}
/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 *
 * @generated from protobuf message protobuf_unittest.TestParsingMerge
 */
export interface TestParsingMerge {
    /**
     * @generated from protobuf field: protobuf_unittest.TestAllTypes required_all_types = 1;
     */
    requiredAllTypes?: TestAllTypes;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes optional_all_types = 2;
     */
    optionalAllTypes?: TestAllTypes;
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 3;
     */
    repeatedAllTypes: TestAllTypes[];
}
/**
 * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
 * except that all fields are repeated. In the tests, we will serialize the
 * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
 * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
 * the corresponding required/optional fields in TestParsingMerge.
 *
 * @generated from protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator
 */
export interface TestParsingMerge_RepeatedFieldsGenerator {
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes field1 = 1;
     */
    field1: TestAllTypes[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes field2 = 2;
     */
    field2: TestAllTypes[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes field3 = 3;
     */
    field3: TestAllTypes[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes ext1 = 1000;
     */
    ext1: TestAllTypes[];
    /**
     * @generated from protobuf field: repeated protobuf_unittest.TestAllTypes ext2 = 1001;
     */
    ext2: TestAllTypes[];
}
/**
 * @generated from protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1
 */
export interface TestParsingMerge_RepeatedFieldsGenerator_Group1 {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes field1 = 11;
     */
    field1?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2
 */
export interface TestParsingMerge_RepeatedFieldsGenerator_Group2 {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes field1 = 21;
     */
    field1?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestParsingMerge.OptionalGroup
 */
export interface TestParsingMerge_OptionalGroup {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes optional_group_all_types = 11;
     */
    optionalGroupAllTypes?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestParsingMerge.RepeatedGroup
 */
export interface TestParsingMerge_RepeatedGroup {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestAllTypes repeated_group_all_types = 21;
     */
    repeatedGroupAllTypes?: TestAllTypes;
}
/**
 * @generated from protobuf message protobuf_unittest.TestCommentInjectionMessage
 */
export interface TestCommentInjectionMessage {
    /**
     * *\/ <- This should not close the generated doc comment
     *
     * @generated from protobuf field: optional string a = 1;
     */
    a?: string;
}
/**
 * Test that RPC services work.
 *
 * @generated from protobuf message protobuf_unittest.FooRequest
 */
export interface FooRequest {
}
/**
 * @generated from protobuf message protobuf_unittest.FooResponse
 */
export interface FooResponse {
}
/**
 * @generated from protobuf message protobuf_unittest.FooClientMessage
 */
export interface FooClientMessage {
}
/**
 * @generated from protobuf message protobuf_unittest.FooServerMessage
 */
export interface FooServerMessage {
}
/**
 * @generated from protobuf message protobuf_unittest.BarRequest
 */
export interface BarRequest {
}
/**
 * @generated from protobuf message protobuf_unittest.BarResponse
 */
export interface BarResponse {
}
/**
 * @generated from protobuf message protobuf_unittest.TestJsonName
 */
export interface TestJsonName {
    /**
     * @generated from protobuf field: optional int32 field_name1 = 1;
     */
    fieldName1?: number;
    /**
     * @generated from protobuf field: optional int32 fieldName2 = 2;
     */
    fieldName2?: number;
    /**
     * @generated from protobuf field: optional int32 FieldName3 = 3 [json_name = "FieldName3"];
     */
    fieldName3?: number;
    /**
     * @generated from protobuf field: optional int32 _field_name4 = 4;
     */
    FieldName4?: number;
    /**
     * @generated from protobuf field: optional int32 FIELD_NAME5 = 5 [json_name = "FIELDNAME5"];
     */
    fIELDNAME5?: number;
    /**
     * @generated from protobuf field: optional int32 field_name6 = 6 [json_name = "@type"];
     */
    fieldName6?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestHugeFieldNumbers
 */
export interface TestHugeFieldNumbers {
    /**
     * @generated from protobuf field: optional int32 optional_int32 = 536870000;
     */
    optionalInt32?: number;
    /**
     * @generated from protobuf field: optional int32 fixed_32 = 536870001;
     */
    fixed32?: number;
    /**
     * @generated from protobuf field: repeated int32 repeated_int32 = 536870002 [packed = false];
     */
    repeatedInt32: number[];
    /**
     * @generated from protobuf field: repeated int32 packed_int32 = 536870003 [packed = true];
     */
    packedInt32: number[];
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignEnum optional_enum = 536870004;
     */
    optionalEnum?: ForeignEnum;
    /**
     * @generated from protobuf field: optional string optional_string = 536870005;
     */
    optionalString?: string;
    /**
     * @generated from protobuf field: optional bytes optional_bytes = 536870006;
     */
    optionalBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional protobuf_unittest.ForeignMessage optional_message = 536870007;
     */
    optionalMessage?: ForeignMessage;
    /**
     * @generated from protobuf field: map<string, string> string_string_map = 536870010;
     */
    stringStringMap: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf oneof: oneof_field
     */
    oneofField: {
        oneofKind: "oneofUint32";
        /**
         * @generated from protobuf field: uint32 oneof_uint32 = 536870011;
         */
        oneofUint32: number;
    } | {
        oneofKind: "oneofTestAllTypes";
        /**
         * @generated from protobuf field: protobuf_unittest.TestAllTypes oneof_test_all_types = 536870012;
         */
        oneofTestAllTypes: TestAllTypes;
    } | {
        oneofKind: "oneofString";
        /**
         * @generated from protobuf field: string oneof_string = 536870013;
         */
        oneofString: string;
    } | {
        oneofKind: "oneofBytes";
        /**
         * @generated from protobuf field: bytes oneof_bytes = 536870014;
         */
        oneofBytes: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestHugeFieldNumbers.OptionalGroup
 */
export interface TestHugeFieldNumbers_OptionalGroup {
    /**
     * @generated from protobuf field: optional int32 group_a = 536870009;
     */
    groupA?: number;
}
/**
 * @generated from protobuf message protobuf_unittest.TestExtensionInsideTable
 */
export interface TestExtensionInsideTable {
    /**
     * @generated from protobuf field: optional int32 field1 = 1;
     */
    field1?: number;
    /**
     * @generated from protobuf field: optional int32 field2 = 2;
     */
    field2?: number;
    /**
     * @generated from protobuf field: optional int32 field3 = 3;
     */
    field3?: number;
    /**
     * @generated from protobuf field: optional int32 field4 = 4;
     */
    field4?: number;
    /**
     * @generated from protobuf field: optional int32 field6 = 6;
     */
    field6?: number;
    /**
     * @generated from protobuf field: optional int32 field7 = 7;
     */
    field7?: number;
    /**
     * @generated from protobuf field: optional int32 field8 = 8;
     */
    field8?: number;
    /**
     * @generated from protobuf field: optional int32 field9 = 9;
     */
    field9?: number;
    /**
     * @generated from protobuf field: optional int32 field10 = 10;
     */
    field10?: number;
}
/**
 * @generated from protobuf enum protobuf_unittest.ForeignEnum
 */
export enum ForeignEnum {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FOREIGN_FOO = 4;
     */
    FOREIGN_FOO = 4,
    /**
     * @generated from protobuf enum value: FOREIGN_BAR = 5;
     */
    FOREIGN_BAR = 5,
    /**
     * @generated from protobuf enum value: FOREIGN_BAZ = 6;
     */
    FOREIGN_BAZ = 6
}
/**
 * Test an enum that has multiple values with the same number.
 *
 * @generated from protobuf enum protobuf_unittest.TestEnumWithDupValue
 */
export enum TestEnumWithDupValue {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FOO1 = 1;
     */
    FOO1 = 1,
    /**
     * @generated from protobuf enum value: BAR1 = 2;
     */
    BAR1 = 2,
    /**
     * @generated from protobuf enum value: BAZ = 3;
     */
    BAZ = 3,
    /**
     * @generated from protobuf enum value: FOO1 = 1;
     */
    FOO2 = 1,
    /**
     * @generated from protobuf enum value: BAR1 = 2;
     */
    BAR2 = 2
}
/**
 * Test an enum with large, unordered values.
 *
 * @generated from protobuf enum protobuf_unittest.TestSparseEnum
 */
export enum TestSparseEnum {
    /**
     * @generated from protobuf enum value: SPARSE_A = 123;
     */
    SPARSE_A = 123,
    /**
     * @generated from protobuf enum value: SPARSE_B = 62374;
     */
    SPARSE_B = 62374,
    /**
     * @generated from protobuf enum value: SPARSE_C = 12589234;
     */
    SPARSE_C = 12589234,
    /**
     * @generated from protobuf enum value: SPARSE_D = -15;
     */
    SPARSE_D = -15,
    /**
     * @generated from protobuf enum value: SPARSE_E = -53452;
     */
    SPARSE_E = -53452,
    /**
     * @generated from protobuf enum value: SPARSE_F = 0;
     */
    SPARSE_F = 0,
    /**
     * @generated from protobuf enum value: SPARSE_G = 2;
     */
    SPARSE_G = 2
}
/**
 * @generated from protobuf enum protobuf_unittest.VeryLargeEnum
 */
export enum VeryLargeEnum {
    /**
     * @generated from protobuf enum value: ENUM_LABEL_DEFAULT = 0;
     */
    ENUM_LABEL_DEFAULT = 0,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_1 = 1;
     */
    ENUM_LABEL_1 = 1,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_2 = 2;
     */
    ENUM_LABEL_2 = 2,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_3 = 3;
     */
    ENUM_LABEL_3 = 3,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_4 = 4;
     */
    ENUM_LABEL_4 = 4,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_5 = 5;
     */
    ENUM_LABEL_5 = 5,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_6 = 6;
     */
    ENUM_LABEL_6 = 6,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_7 = 7;
     */
    ENUM_LABEL_7 = 7,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_8 = 8;
     */
    ENUM_LABEL_8 = 8,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_9 = 9;
     */
    ENUM_LABEL_9 = 9,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_10 = 10;
     */
    ENUM_LABEL_10 = 10,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_11 = 11;
     */
    ENUM_LABEL_11 = 11,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_12 = 12;
     */
    ENUM_LABEL_12 = 12,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_13 = 13;
     */
    ENUM_LABEL_13 = 13,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_14 = 14;
     */
    ENUM_LABEL_14 = 14,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_15 = 15;
     */
    ENUM_LABEL_15 = 15,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_16 = 16;
     */
    ENUM_LABEL_16 = 16,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_17 = 17;
     */
    ENUM_LABEL_17 = 17,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_18 = 18;
     */
    ENUM_LABEL_18 = 18,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_19 = 19;
     */
    ENUM_LABEL_19 = 19,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_20 = 20;
     */
    ENUM_LABEL_20 = 20,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_21 = 21;
     */
    ENUM_LABEL_21 = 21,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_22 = 22;
     */
    ENUM_LABEL_22 = 22,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_23 = 23;
     */
    ENUM_LABEL_23 = 23,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_24 = 24;
     */
    ENUM_LABEL_24 = 24,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_25 = 25;
     */
    ENUM_LABEL_25 = 25,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_26 = 26;
     */
    ENUM_LABEL_26 = 26,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_27 = 27;
     */
    ENUM_LABEL_27 = 27,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_28 = 28;
     */
    ENUM_LABEL_28 = 28,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_29 = 29;
     */
    ENUM_LABEL_29 = 29,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_30 = 30;
     */
    ENUM_LABEL_30 = 30,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_31 = 31;
     */
    ENUM_LABEL_31 = 31,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_32 = 32;
     */
    ENUM_LABEL_32 = 32,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_33 = 33;
     */
    ENUM_LABEL_33 = 33,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_34 = 34;
     */
    ENUM_LABEL_34 = 34,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_35 = 35;
     */
    ENUM_LABEL_35 = 35,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_36 = 36;
     */
    ENUM_LABEL_36 = 36,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_37 = 37;
     */
    ENUM_LABEL_37 = 37,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_38 = 38;
     */
    ENUM_LABEL_38 = 38,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_39 = 39;
     */
    ENUM_LABEL_39 = 39,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_40 = 40;
     */
    ENUM_LABEL_40 = 40,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_41 = 41;
     */
    ENUM_LABEL_41 = 41,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_42 = 42;
     */
    ENUM_LABEL_42 = 42,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_43 = 43;
     */
    ENUM_LABEL_43 = 43,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_44 = 44;
     */
    ENUM_LABEL_44 = 44,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_45 = 45;
     */
    ENUM_LABEL_45 = 45,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_46 = 46;
     */
    ENUM_LABEL_46 = 46,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_47 = 47;
     */
    ENUM_LABEL_47 = 47,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_48 = 48;
     */
    ENUM_LABEL_48 = 48,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_49 = 49;
     */
    ENUM_LABEL_49 = 49,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_50 = 50;
     */
    ENUM_LABEL_50 = 50,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_51 = 51;
     */
    ENUM_LABEL_51 = 51,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_52 = 52;
     */
    ENUM_LABEL_52 = 52,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_53 = 53;
     */
    ENUM_LABEL_53 = 53,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_54 = 54;
     */
    ENUM_LABEL_54 = 54,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_55 = 55;
     */
    ENUM_LABEL_55 = 55,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_56 = 56;
     */
    ENUM_LABEL_56 = 56,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_57 = 57;
     */
    ENUM_LABEL_57 = 57,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_58 = 58;
     */
    ENUM_LABEL_58 = 58,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_59 = 59;
     */
    ENUM_LABEL_59 = 59,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_60 = 60;
     */
    ENUM_LABEL_60 = 60,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_61 = 61;
     */
    ENUM_LABEL_61 = 61,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_62 = 62;
     */
    ENUM_LABEL_62 = 62,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_63 = 63;
     */
    ENUM_LABEL_63 = 63,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_64 = 64;
     */
    ENUM_LABEL_64 = 64,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_65 = 65;
     */
    ENUM_LABEL_65 = 65,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_66 = 66;
     */
    ENUM_LABEL_66 = 66,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_67 = 67;
     */
    ENUM_LABEL_67 = 67,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_68 = 68;
     */
    ENUM_LABEL_68 = 68,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_69 = 69;
     */
    ENUM_LABEL_69 = 69,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_70 = 70;
     */
    ENUM_LABEL_70 = 70,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_71 = 71;
     */
    ENUM_LABEL_71 = 71,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_72 = 72;
     */
    ENUM_LABEL_72 = 72,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_73 = 73;
     */
    ENUM_LABEL_73 = 73,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_74 = 74;
     */
    ENUM_LABEL_74 = 74,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_75 = 75;
     */
    ENUM_LABEL_75 = 75,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_76 = 76;
     */
    ENUM_LABEL_76 = 76,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_77 = 77;
     */
    ENUM_LABEL_77 = 77,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_78 = 78;
     */
    ENUM_LABEL_78 = 78,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_79 = 79;
     */
    ENUM_LABEL_79 = 79,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_80 = 80;
     */
    ENUM_LABEL_80 = 80,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_81 = 81;
     */
    ENUM_LABEL_81 = 81,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_82 = 82;
     */
    ENUM_LABEL_82 = 82,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_83 = 83;
     */
    ENUM_LABEL_83 = 83,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_84 = 84;
     */
    ENUM_LABEL_84 = 84,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_85 = 85;
     */
    ENUM_LABEL_85 = 85,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_86 = 86;
     */
    ENUM_LABEL_86 = 86,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_87 = 87;
     */
    ENUM_LABEL_87 = 87,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_88 = 88;
     */
    ENUM_LABEL_88 = 88,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_89 = 89;
     */
    ENUM_LABEL_89 = 89,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_90 = 90;
     */
    ENUM_LABEL_90 = 90,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_91 = 91;
     */
    ENUM_LABEL_91 = 91,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_92 = 92;
     */
    ENUM_LABEL_92 = 92,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_93 = 93;
     */
    ENUM_LABEL_93 = 93,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_94 = 94;
     */
    ENUM_LABEL_94 = 94,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_95 = 95;
     */
    ENUM_LABEL_95 = 95,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_96 = 96;
     */
    ENUM_LABEL_96 = 96,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_97 = 97;
     */
    ENUM_LABEL_97 = 97,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_98 = 98;
     */
    ENUM_LABEL_98 = 98,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_99 = 99;
     */
    ENUM_LABEL_99 = 99,
    /**
     * @generated from protobuf enum value: ENUM_LABEL_100 = 100;
     */
    ENUM_LABEL_100 = 100
}
// @generated message type with reflection information, may provide speed optimized methods
class TestAllTypes$Type extends MessageType<TestAllTypes> {
    constructor() {
        super("protobuf_unittest.TestAllTypes", [
            { no: 1, name: "optional_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "optional_int64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "optional_uint32", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "optional_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "optional_sint32", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "optional_sint64", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "optional_fixed32", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "optional_fixed64", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "optional_sfixed32", kind: "scalar", opt: true, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 10, name: "optional_sfixed64", kind: "scalar", opt: true, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "optional_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "optional_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "optional_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "optional_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "optional_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 18, name: "optional_nested_message", kind: "message", T: () => TestAllTypes_NestedMessage },
            { no: 19, name: "optional_foreign_message", kind: "message", T: () => ForeignMessage },
            { no: 20, name: "optional_import_message", kind: "message", T: () => ImportMessage },
            { no: 21, name: "optional_nested_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.TestAllTypes.NestedEnum", TestAllTypes_NestedEnum] },
            { no: 22, name: "optional_foreign_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 23, name: "optional_import_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest_import.ImportEnum", ImportEnum] },
            { no: 24, name: "optional_string_piece", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "optional_cord", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "optional_public_import_message", kind: "message", T: () => PublicImportMessage },
            { no: 27, name: "optional_lazy_message", kind: "message", T: () => TestAllTypes_NestedMessage },
            { no: 31, name: "repeated_int32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "repeated_int64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 33, name: "repeated_uint32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 34, name: "repeated_uint64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 35, name: "repeated_sint32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 36, name: "repeated_sint64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 37, name: "repeated_fixed32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 38, name: "repeated_fixed64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 39, name: "repeated_sfixed32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 40, name: "repeated_sfixed64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 41, name: "repeated_float", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 42, name: "repeated_double", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 43, name: "repeated_bool", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "repeated_string", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "repeated_bytes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 48, name: "repeated_nested_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes_NestedMessage },
            { no: 49, name: "repeated_foreign_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ForeignMessage },
            { no: 50, name: "repeated_import_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImportMessage },
            { no: 51, name: "repeated_nested_enum", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["protobuf_unittest.TestAllTypes.NestedEnum", TestAllTypes_NestedEnum] },
            { no: 52, name: "repeated_foreign_enum", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 53, name: "repeated_import_enum", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["protobuf_unittest_import.ImportEnum", ImportEnum] },
            { no: 54, name: "repeated_string_piece", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 55, name: "repeated_cord", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 57, name: "repeated_lazy_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes_NestedMessage },
            { no: 61, name: "default_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 62, name: "default_int64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 63, name: "default_uint32", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 64, name: "default_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 65, name: "default_sint32", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 66, name: "default_sint64", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 67, name: "default_fixed32", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 68, name: "default_fixed64", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 69, name: "default_sfixed32", kind: "scalar", opt: true, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 70, name: "default_sfixed64", kind: "scalar", opt: true, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 71, name: "default_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 72, name: "default_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 73, name: "default_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 74, name: "default_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 75, name: "default_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 81, name: "default_nested_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.TestAllTypes.NestedEnum", TestAllTypes_NestedEnum] },
            { no: 82, name: "default_foreign_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 83, name: "default_import_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest_import.ImportEnum", ImportEnum] },
            { no: 84, name: "default_string_piece", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 85, name: "default_cord", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 111, name: "oneof_uint32", kind: "scalar", oneof: "oneofField", T: 13 /*ScalarType.UINT32*/ },
            { no: 112, name: "oneof_nested_message", kind: "message", oneof: "oneofField", T: () => TestAllTypes_NestedMessage },
            { no: 113, name: "oneof_string", kind: "scalar", oneof: "oneofField", T: 9 /*ScalarType.STRING*/ },
            { no: 114, name: "oneof_bytes", kind: "scalar", oneof: "oneofField", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TestAllTypes>): TestAllTypes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedInt32 = [];
        message.repeatedInt64 = [];
        message.repeatedUint32 = [];
        message.repeatedUint64 = [];
        message.repeatedSint32 = [];
        message.repeatedSint64 = [];
        message.repeatedFixed32 = [];
        message.repeatedFixed64 = [];
        message.repeatedSfixed32 = [];
        message.repeatedSfixed64 = [];
        message.repeatedFloat = [];
        message.repeatedDouble = [];
        message.repeatedBool = [];
        message.repeatedString = [];
        message.repeatedBytes = [];
        message.repeatedNestedMessage = [];
        message.repeatedForeignMessage = [];
        message.repeatedImportMessage = [];
        message.repeatedNestedEnum = [];
        message.repeatedForeignEnum = [];
        message.repeatedImportEnum = [];
        message.repeatedStringPiece = [];
        message.repeatedCord = [];
        message.repeatedLazyMessage = [];
        message.oneofField = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestAllTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAllTypes): TestAllTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 optional_int32 */ 1:
                    message.optionalInt32 = reader.int32();
                    break;
                case /* optional int64 optional_int64 */ 2:
                    message.optionalInt64 = reader.int64().toBigInt();
                    break;
                case /* optional uint32 optional_uint32 */ 3:
                    message.optionalUint32 = reader.uint32();
                    break;
                case /* optional uint64 optional_uint64 */ 4:
                    message.optionalUint64 = reader.uint64().toBigInt();
                    break;
                case /* optional sint32 optional_sint32 */ 5:
                    message.optionalSint32 = reader.sint32();
                    break;
                case /* optional sint64 optional_sint64 */ 6:
                    message.optionalSint64 = reader.sint64().toBigInt();
                    break;
                case /* optional fixed32 optional_fixed32 */ 7:
                    message.optionalFixed32 = reader.fixed32();
                    break;
                case /* optional fixed64 optional_fixed64 */ 8:
                    message.optionalFixed64 = reader.fixed64().toBigInt();
                    break;
                case /* optional sfixed32 optional_sfixed32 */ 9:
                    message.optionalSfixed32 = reader.sfixed32();
                    break;
                case /* optional sfixed64 optional_sfixed64 */ 10:
                    message.optionalSfixed64 = reader.sfixed64().toBigInt();
                    break;
                case /* optional float optional_float */ 11:
                    message.optionalFloat = reader.float();
                    break;
                case /* optional double optional_double */ 12:
                    message.optionalDouble = reader.double();
                    break;
                case /* optional bool optional_bool */ 13:
                    message.optionalBool = reader.bool();
                    break;
                case /* optional string optional_string */ 14:
                    message.optionalString = reader.string();
                    break;
                case /* optional bytes optional_bytes */ 15:
                    message.optionalBytes = reader.bytes();
                    break;
                case /* optional protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message */ 18:
                    message.optionalNestedMessage = TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalNestedMessage);
                    break;
                case /* optional protobuf_unittest.ForeignMessage optional_foreign_message */ 19:
                    message.optionalForeignMessage = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalForeignMessage);
                    break;
                case /* optional protobuf_unittest_import.ImportMessage optional_import_message */ 20:
                    message.optionalImportMessage = ImportMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalImportMessage);
                    break;
                case /* optional protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum */ 21:
                    message.optionalNestedEnum = reader.int32();
                    break;
                case /* optional protobuf_unittest.ForeignEnum optional_foreign_enum */ 22:
                    message.optionalForeignEnum = reader.int32();
                    break;
                case /* optional protobuf_unittest_import.ImportEnum optional_import_enum */ 23:
                    message.optionalImportEnum = reader.int32();
                    break;
                case /* optional string optional_string_piece */ 24:
                    message.optionalStringPiece = reader.string();
                    break;
                case /* optional string optional_cord */ 25:
                    message.optionalCord = reader.string();
                    break;
                case /* optional protobuf_unittest_import.PublicImportMessage optional_public_import_message */ 26:
                    message.optionalPublicImportMessage = PublicImportMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalPublicImportMessage);
                    break;
                case /* optional protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message */ 27:
                    message.optionalLazyMessage = TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalLazyMessage);
                    break;
                case /* repeated int32 repeated_int32 */ 31:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt32.push(reader.int32());
                    else
                        message.repeatedInt32.push(reader.int32());
                    break;
                case /* repeated int64 repeated_int64 */ 32:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt64.push(reader.int64().toBigInt());
                    else
                        message.repeatedInt64.push(reader.int64().toBigInt());
                    break;
                case /* repeated uint32 repeated_uint32 */ 33:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedUint32.push(reader.uint32());
                    else
                        message.repeatedUint32.push(reader.uint32());
                    break;
                case /* repeated uint64 repeated_uint64 */ 34:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedUint64.push(reader.uint64().toBigInt());
                    else
                        message.repeatedUint64.push(reader.uint64().toBigInt());
                    break;
                case /* repeated sint32 repeated_sint32 */ 35:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedSint32.push(reader.sint32());
                    else
                        message.repeatedSint32.push(reader.sint32());
                    break;
                case /* repeated sint64 repeated_sint64 */ 36:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedSint64.push(reader.sint64().toBigInt());
                    else
                        message.repeatedSint64.push(reader.sint64().toBigInt());
                    break;
                case /* repeated fixed32 repeated_fixed32 */ 37:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFixed32.push(reader.fixed32());
                    else
                        message.repeatedFixed32.push(reader.fixed32());
                    break;
                case /* repeated fixed64 repeated_fixed64 */ 38:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFixed64.push(reader.fixed64().toBigInt());
                    else
                        message.repeatedFixed64.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated sfixed32 repeated_sfixed32 */ 39:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedSfixed32.push(reader.sfixed32());
                    else
                        message.repeatedSfixed32.push(reader.sfixed32());
                    break;
                case /* repeated sfixed64 repeated_sfixed64 */ 40:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedSfixed64.push(reader.sfixed64().toBigInt());
                    else
                        message.repeatedSfixed64.push(reader.sfixed64().toBigInt());
                    break;
                case /* repeated float repeated_float */ 41:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFloat.push(reader.float());
                    else
                        message.repeatedFloat.push(reader.float());
                    break;
                case /* repeated double repeated_double */ 42:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedDouble.push(reader.double());
                    else
                        message.repeatedDouble.push(reader.double());
                    break;
                case /* repeated bool repeated_bool */ 43:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedBool.push(reader.bool());
                    else
                        message.repeatedBool.push(reader.bool());
                    break;
                case /* repeated string repeated_string */ 44:
                    message.repeatedString.push(reader.string());
                    break;
                case /* repeated bytes repeated_bytes */ 45:
                    message.repeatedBytes.push(reader.bytes());
                    break;
                case /* repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message */ 48:
                    message.repeatedNestedMessage.push(TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.ForeignMessage repeated_foreign_message */ 49:
                    message.repeatedForeignMessage.push(ForeignMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest_import.ImportMessage repeated_import_message */ 50:
                    message.repeatedImportMessage.push(ImportMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum */ 51:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedNestedEnum.push(reader.int32());
                    else
                        message.repeatedNestedEnum.push(reader.int32());
                    break;
                case /* repeated protobuf_unittest.ForeignEnum repeated_foreign_enum */ 52:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedForeignEnum.push(reader.int32());
                    else
                        message.repeatedForeignEnum.push(reader.int32());
                    break;
                case /* repeated protobuf_unittest_import.ImportEnum repeated_import_enum */ 53:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedImportEnum.push(reader.int32());
                    else
                        message.repeatedImportEnum.push(reader.int32());
                    break;
                case /* repeated string repeated_string_piece */ 54:
                    message.repeatedStringPiece.push(reader.string());
                    break;
                case /* repeated string repeated_cord */ 55:
                    message.repeatedCord.push(reader.string());
                    break;
                case /* repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message */ 57:
                    message.repeatedLazyMessage.push(TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 default_int32 */ 61:
                    message.defaultInt32 = reader.int32();
                    break;
                case /* optional int64 default_int64 */ 62:
                    message.defaultInt64 = reader.int64().toBigInt();
                    break;
                case /* optional uint32 default_uint32 */ 63:
                    message.defaultUint32 = reader.uint32();
                    break;
                case /* optional uint64 default_uint64 */ 64:
                    message.defaultUint64 = reader.uint64().toBigInt();
                    break;
                case /* optional sint32 default_sint32 */ 65:
                    message.defaultSint32 = reader.sint32();
                    break;
                case /* optional sint64 default_sint64 */ 66:
                    message.defaultSint64 = reader.sint64().toBigInt();
                    break;
                case /* optional fixed32 default_fixed32 */ 67:
                    message.defaultFixed32 = reader.fixed32();
                    break;
                case /* optional fixed64 default_fixed64 */ 68:
                    message.defaultFixed64 = reader.fixed64().toBigInt();
                    break;
                case /* optional sfixed32 default_sfixed32 */ 69:
                    message.defaultSfixed32 = reader.sfixed32();
                    break;
                case /* optional sfixed64 default_sfixed64 */ 70:
                    message.defaultSfixed64 = reader.sfixed64().toBigInt();
                    break;
                case /* optional float default_float */ 71:
                    message.defaultFloat = reader.float();
                    break;
                case /* optional double default_double */ 72:
                    message.defaultDouble = reader.double();
                    break;
                case /* optional bool default_bool */ 73:
                    message.defaultBool = reader.bool();
                    break;
                case /* optional string default_string */ 74:
                    message.defaultString = reader.string();
                    break;
                case /* optional bytes default_bytes */ 75:
                    message.defaultBytes = reader.bytes();
                    break;
                case /* optional protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum */ 81:
                    message.defaultNestedEnum = reader.int32();
                    break;
                case /* optional protobuf_unittest.ForeignEnum default_foreign_enum */ 82:
                    message.defaultForeignEnum = reader.int32();
                    break;
                case /* optional protobuf_unittest_import.ImportEnum default_import_enum */ 83:
                    message.defaultImportEnum = reader.int32();
                    break;
                case /* optional string default_string_piece */ 84:
                    message.defaultStringPiece = reader.string();
                    break;
                case /* optional string default_cord */ 85:
                    message.defaultCord = reader.string();
                    break;
                case /* uint32 oneof_uint32 */ 111:
                    message.oneofField = {
                        oneofKind: "oneofUint32",
                        oneofUint32: reader.uint32()
                    };
                    break;
                case /* protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message */ 112:
                    message.oneofField = {
                        oneofKind: "oneofNestedMessage",
                        oneofNestedMessage: TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, (message.oneofField as any).oneofNestedMessage)
                    };
                    break;
                case /* string oneof_string */ 113:
                    message.oneofField = {
                        oneofKind: "oneofString",
                        oneofString: reader.string()
                    };
                    break;
                case /* bytes oneof_bytes */ 114:
                    message.oneofField = {
                        oneofKind: "oneofBytes",
                        oneofBytes: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAllTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 optional_int32 = 1; */
        if (message.optionalInt32 !== undefined)
            writer.tag(1, WireType.Varint).int32(message.optionalInt32);
        /* optional int64 optional_int64 = 2; */
        if (message.optionalInt64 !== undefined)
            writer.tag(2, WireType.Varint).int64(message.optionalInt64);
        /* optional uint32 optional_uint32 = 3; */
        if (message.optionalUint32 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.optionalUint32);
        /* optional uint64 optional_uint64 = 4; */
        if (message.optionalUint64 !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.optionalUint64);
        /* optional sint32 optional_sint32 = 5; */
        if (message.optionalSint32 !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.optionalSint32);
        /* optional sint64 optional_sint64 = 6; */
        if (message.optionalSint64 !== undefined)
            writer.tag(6, WireType.Varint).sint64(message.optionalSint64);
        /* optional fixed32 optional_fixed32 = 7; */
        if (message.optionalFixed32 !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.optionalFixed32);
        /* optional fixed64 optional_fixed64 = 8; */
        if (message.optionalFixed64 !== undefined)
            writer.tag(8, WireType.Bit64).fixed64(message.optionalFixed64);
        /* optional sfixed32 optional_sfixed32 = 9; */
        if (message.optionalSfixed32 !== undefined)
            writer.tag(9, WireType.Bit32).sfixed32(message.optionalSfixed32);
        /* optional sfixed64 optional_sfixed64 = 10; */
        if (message.optionalSfixed64 !== undefined)
            writer.tag(10, WireType.Bit64).sfixed64(message.optionalSfixed64);
        /* optional float optional_float = 11; */
        if (message.optionalFloat !== undefined)
            writer.tag(11, WireType.Bit32).float(message.optionalFloat);
        /* optional double optional_double = 12; */
        if (message.optionalDouble !== undefined)
            writer.tag(12, WireType.Bit64).double(message.optionalDouble);
        /* optional bool optional_bool = 13; */
        if (message.optionalBool !== undefined)
            writer.tag(13, WireType.Varint).bool(message.optionalBool);
        /* optional string optional_string = 14; */
        if (message.optionalString !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.optionalString);
        /* optional bytes optional_bytes = 15; */
        if (message.optionalBytes !== undefined)
            writer.tag(15, WireType.LengthDelimited).bytes(message.optionalBytes);
        /* optional protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18; */
        if (message.optionalNestedMessage)
            TestAllTypes_NestedMessage.internalBinaryWrite(message.optionalNestedMessage, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.ForeignMessage optional_foreign_message = 19; */
        if (message.optionalForeignMessage)
            ForeignMessage.internalBinaryWrite(message.optionalForeignMessage, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest_import.ImportMessage optional_import_message = 20; */
        if (message.optionalImportMessage)
            ImportMessage.internalBinaryWrite(message.optionalImportMessage, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21; */
        if (message.optionalNestedEnum !== undefined)
            writer.tag(21, WireType.Varint).int32(message.optionalNestedEnum);
        /* optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22; */
        if (message.optionalForeignEnum !== undefined)
            writer.tag(22, WireType.Varint).int32(message.optionalForeignEnum);
        /* optional protobuf_unittest_import.ImportEnum optional_import_enum = 23; */
        if (message.optionalImportEnum !== undefined)
            writer.tag(23, WireType.Varint).int32(message.optionalImportEnum);
        /* optional string optional_string_piece = 24; */
        if (message.optionalStringPiece !== undefined)
            writer.tag(24, WireType.LengthDelimited).string(message.optionalStringPiece);
        /* optional string optional_cord = 25; */
        if (message.optionalCord !== undefined)
            writer.tag(25, WireType.LengthDelimited).string(message.optionalCord);
        /* optional protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26; */
        if (message.optionalPublicImportMessage)
            PublicImportMessage.internalBinaryWrite(message.optionalPublicImportMessage, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27; */
        if (message.optionalLazyMessage)
            TestAllTypes_NestedMessage.internalBinaryWrite(message.optionalLazyMessage, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 repeated_int32 = 31; */
        for (let i = 0; i < message.repeatedInt32.length; i++)
            writer.tag(31, WireType.Varint).int32(message.repeatedInt32[i]);
        /* repeated int64 repeated_int64 = 32; */
        for (let i = 0; i < message.repeatedInt64.length; i++)
            writer.tag(32, WireType.Varint).int64(message.repeatedInt64[i]);
        /* repeated uint32 repeated_uint32 = 33; */
        for (let i = 0; i < message.repeatedUint32.length; i++)
            writer.tag(33, WireType.Varint).uint32(message.repeatedUint32[i]);
        /* repeated uint64 repeated_uint64 = 34; */
        for (let i = 0; i < message.repeatedUint64.length; i++)
            writer.tag(34, WireType.Varint).uint64(message.repeatedUint64[i]);
        /* repeated sint32 repeated_sint32 = 35; */
        for (let i = 0; i < message.repeatedSint32.length; i++)
            writer.tag(35, WireType.Varint).sint32(message.repeatedSint32[i]);
        /* repeated sint64 repeated_sint64 = 36; */
        for (let i = 0; i < message.repeatedSint64.length; i++)
            writer.tag(36, WireType.Varint).sint64(message.repeatedSint64[i]);
        /* repeated fixed32 repeated_fixed32 = 37; */
        for (let i = 0; i < message.repeatedFixed32.length; i++)
            writer.tag(37, WireType.Bit32).fixed32(message.repeatedFixed32[i]);
        /* repeated fixed64 repeated_fixed64 = 38; */
        for (let i = 0; i < message.repeatedFixed64.length; i++)
            writer.tag(38, WireType.Bit64).fixed64(message.repeatedFixed64[i]);
        /* repeated sfixed32 repeated_sfixed32 = 39; */
        for (let i = 0; i < message.repeatedSfixed32.length; i++)
            writer.tag(39, WireType.Bit32).sfixed32(message.repeatedSfixed32[i]);
        /* repeated sfixed64 repeated_sfixed64 = 40; */
        for (let i = 0; i < message.repeatedSfixed64.length; i++)
            writer.tag(40, WireType.Bit64).sfixed64(message.repeatedSfixed64[i]);
        /* repeated float repeated_float = 41; */
        for (let i = 0; i < message.repeatedFloat.length; i++)
            writer.tag(41, WireType.Bit32).float(message.repeatedFloat[i]);
        /* repeated double repeated_double = 42; */
        for (let i = 0; i < message.repeatedDouble.length; i++)
            writer.tag(42, WireType.Bit64).double(message.repeatedDouble[i]);
        /* repeated bool repeated_bool = 43; */
        for (let i = 0; i < message.repeatedBool.length; i++)
            writer.tag(43, WireType.Varint).bool(message.repeatedBool[i]);
        /* repeated string repeated_string = 44; */
        for (let i = 0; i < message.repeatedString.length; i++)
            writer.tag(44, WireType.LengthDelimited).string(message.repeatedString[i]);
        /* repeated bytes repeated_bytes = 45; */
        for (let i = 0; i < message.repeatedBytes.length; i++)
            writer.tag(45, WireType.LengthDelimited).bytes(message.repeatedBytes[i]);
        /* repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48; */
        for (let i = 0; i < message.repeatedNestedMessage.length; i++)
            TestAllTypes_NestedMessage.internalBinaryWrite(message.repeatedNestedMessage[i], writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.ForeignMessage repeated_foreign_message = 49; */
        for (let i = 0; i < message.repeatedForeignMessage.length; i++)
            ForeignMessage.internalBinaryWrite(message.repeatedForeignMessage[i], writer.tag(49, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest_import.ImportMessage repeated_import_message = 50; */
        for (let i = 0; i < message.repeatedImportMessage.length; i++)
            ImportMessage.internalBinaryWrite(message.repeatedImportMessage[i], writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51; */
        for (let i = 0; i < message.repeatedNestedEnum.length; i++)
            writer.tag(51, WireType.Varint).int32(message.repeatedNestedEnum[i]);
        /* repeated protobuf_unittest.ForeignEnum repeated_foreign_enum = 52; */
        for (let i = 0; i < message.repeatedForeignEnum.length; i++)
            writer.tag(52, WireType.Varint).int32(message.repeatedForeignEnum[i]);
        /* repeated protobuf_unittest_import.ImportEnum repeated_import_enum = 53; */
        for (let i = 0; i < message.repeatedImportEnum.length; i++)
            writer.tag(53, WireType.Varint).int32(message.repeatedImportEnum[i]);
        /* repeated string repeated_string_piece = 54; */
        for (let i = 0; i < message.repeatedStringPiece.length; i++)
            writer.tag(54, WireType.LengthDelimited).string(message.repeatedStringPiece[i]);
        /* repeated string repeated_cord = 55; */
        for (let i = 0; i < message.repeatedCord.length; i++)
            writer.tag(55, WireType.LengthDelimited).string(message.repeatedCord[i]);
        /* repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57; */
        for (let i = 0; i < message.repeatedLazyMessage.length; i++)
            TestAllTypes_NestedMessage.internalBinaryWrite(message.repeatedLazyMessage[i], writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 default_int32 = 61; */
        if (message.defaultInt32 !== undefined)
            writer.tag(61, WireType.Varint).int32(message.defaultInt32);
        /* optional int64 default_int64 = 62; */
        if (message.defaultInt64 !== undefined)
            writer.tag(62, WireType.Varint).int64(message.defaultInt64);
        /* optional uint32 default_uint32 = 63; */
        if (message.defaultUint32 !== undefined)
            writer.tag(63, WireType.Varint).uint32(message.defaultUint32);
        /* optional uint64 default_uint64 = 64; */
        if (message.defaultUint64 !== undefined)
            writer.tag(64, WireType.Varint).uint64(message.defaultUint64);
        /* optional sint32 default_sint32 = 65; */
        if (message.defaultSint32 !== undefined)
            writer.tag(65, WireType.Varint).sint32(message.defaultSint32);
        /* optional sint64 default_sint64 = 66; */
        if (message.defaultSint64 !== undefined)
            writer.tag(66, WireType.Varint).sint64(message.defaultSint64);
        /* optional fixed32 default_fixed32 = 67; */
        if (message.defaultFixed32 !== undefined)
            writer.tag(67, WireType.Bit32).fixed32(message.defaultFixed32);
        /* optional fixed64 default_fixed64 = 68; */
        if (message.defaultFixed64 !== undefined)
            writer.tag(68, WireType.Bit64).fixed64(message.defaultFixed64);
        /* optional sfixed32 default_sfixed32 = 69; */
        if (message.defaultSfixed32 !== undefined)
            writer.tag(69, WireType.Bit32).sfixed32(message.defaultSfixed32);
        /* optional sfixed64 default_sfixed64 = 70; */
        if (message.defaultSfixed64 !== undefined)
            writer.tag(70, WireType.Bit64).sfixed64(message.defaultSfixed64);
        /* optional float default_float = 71; */
        if (message.defaultFloat !== undefined)
            writer.tag(71, WireType.Bit32).float(message.defaultFloat);
        /* optional double default_double = 72; */
        if (message.defaultDouble !== undefined)
            writer.tag(72, WireType.Bit64).double(message.defaultDouble);
        /* optional bool default_bool = 73; */
        if (message.defaultBool !== undefined)
            writer.tag(73, WireType.Varint).bool(message.defaultBool);
        /* optional string default_string = 74; */
        if (message.defaultString !== undefined)
            writer.tag(74, WireType.LengthDelimited).string(message.defaultString);
        /* optional bytes default_bytes = 75; */
        if (message.defaultBytes !== undefined)
            writer.tag(75, WireType.LengthDelimited).bytes(message.defaultBytes);
        /* optional protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81; */
        if (message.defaultNestedEnum !== undefined)
            writer.tag(81, WireType.Varint).int32(message.defaultNestedEnum);
        /* optional protobuf_unittest.ForeignEnum default_foreign_enum = 82; */
        if (message.defaultForeignEnum !== undefined)
            writer.tag(82, WireType.Varint).int32(message.defaultForeignEnum);
        /* optional protobuf_unittest_import.ImportEnum default_import_enum = 83; */
        if (message.defaultImportEnum !== undefined)
            writer.tag(83, WireType.Varint).int32(message.defaultImportEnum);
        /* optional string default_string_piece = 84; */
        if (message.defaultStringPiece !== undefined)
            writer.tag(84, WireType.LengthDelimited).string(message.defaultStringPiece);
        /* optional string default_cord = 85; */
        if (message.defaultCord !== undefined)
            writer.tag(85, WireType.LengthDelimited).string(message.defaultCord);
        /* uint32 oneof_uint32 = 111; */
        if (message.oneofField.oneofKind === "oneofUint32")
            writer.tag(111, WireType.Varint).uint32(message.oneofField.oneofUint32);
        /* protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message = 112; */
        if (message.oneofField.oneofKind === "oneofNestedMessage")
            TestAllTypes_NestedMessage.internalBinaryWrite(message.oneofField.oneofNestedMessage, writer.tag(112, WireType.LengthDelimited).fork(), options).join();
        /* string oneof_string = 113; */
        if (message.oneofField.oneofKind === "oneofString")
            writer.tag(113, WireType.LengthDelimited).string(message.oneofField.oneofString);
        /* bytes oneof_bytes = 114; */
        if (message.oneofField.oneofKind === "oneofBytes")
            writer.tag(114, WireType.LengthDelimited).bytes(message.oneofField.oneofBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestAllTypes
 */
export const TestAllTypes = new TestAllTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestAllTypes_NestedMessage$Type extends MessageType<TestAllTypes_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestAllTypes.NestedMessage", [
            { no: 1, name: "bb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestAllTypes_NestedMessage>): TestAllTypes_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestAllTypes_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAllTypes_NestedMessage): TestAllTypes_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 bb */ 1:
                    message.bb = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAllTypes_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 bb = 1; */
        if (message.bb !== undefined)
            writer.tag(1, WireType.Varint).int32(message.bb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestAllTypes.NestedMessage
 */
export const TestAllTypes_NestedMessage = new TestAllTypes_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestAllTypes_OptionalGroup$Type extends MessageType<TestAllTypes_OptionalGroup> {
    constructor() {
        super("protobuf_unittest.TestAllTypes.OptionalGroup", [
            { no: 17, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestAllTypes_OptionalGroup>): TestAllTypes_OptionalGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestAllTypes_OptionalGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAllTypes_OptionalGroup): TestAllTypes_OptionalGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 17:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAllTypes_OptionalGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 17; */
        if (message.a !== undefined)
            writer.tag(17, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestAllTypes.OptionalGroup
 */
export const TestAllTypes_OptionalGroup = new TestAllTypes_OptionalGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestAllTypes_RepeatedGroup$Type extends MessageType<TestAllTypes_RepeatedGroup> {
    constructor() {
        super("protobuf_unittest.TestAllTypes.RepeatedGroup", [
            { no: 47, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestAllTypes_RepeatedGroup>): TestAllTypes_RepeatedGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestAllTypes_RepeatedGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAllTypes_RepeatedGroup): TestAllTypes_RepeatedGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 47:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAllTypes_RepeatedGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 47; */
        if (message.a !== undefined)
            writer.tag(47, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestAllTypes.RepeatedGroup
 */
export const TestAllTypes_RepeatedGroup = new TestAllTypes_RepeatedGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NestedTestAllTypes$Type extends MessageType<NestedTestAllTypes> {
    constructor() {
        super("protobuf_unittest.NestedTestAllTypes", [
            { no: 1, name: "child", kind: "message", T: () => NestedTestAllTypes },
            { no: 2, name: "payload", kind: "message", T: () => TestAllTypes },
            { no: 3, name: "repeated_child", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => NestedTestAllTypes }
        ]);
    }
    create(value?: PartialMessage<NestedTestAllTypes>): NestedTestAllTypes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedChild = [];
        if (value !== undefined)
            reflectionMergePartial<NestedTestAllTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NestedTestAllTypes): NestedTestAllTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.NestedTestAllTypes child */ 1:
                    message.child = NestedTestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                case /* optional protobuf_unittest.TestAllTypes payload */ 2:
                    message.payload = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* repeated protobuf_unittest.NestedTestAllTypes repeated_child */ 3:
                    message.repeatedChild.push(NestedTestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NestedTestAllTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.NestedTestAllTypes child = 1; */
        if (message.child)
            NestedTestAllTypes.internalBinaryWrite(message.child, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestAllTypes payload = 2; */
        if (message.payload)
            TestAllTypes.internalBinaryWrite(message.payload, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.NestedTestAllTypes repeated_child = 3; */
        for (let i = 0; i < message.repeatedChild.length; i++)
            NestedTestAllTypes.internalBinaryWrite(message.repeatedChild[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.NestedTestAllTypes
 */
export const NestedTestAllTypes = new NestedTestAllTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDeprecatedFields$Type extends MessageType<TestDeprecatedFields> {
    constructor() {
        super("protobuf_unittest.TestDeprecatedFields", [
            { no: 1, name: "deprecated_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "deprecated_int32_in_oneof", kind: "scalar", oneof: "oneofFields", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDeprecatedFields>): TestDeprecatedFields {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oneofFields = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestDeprecatedFields>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDeprecatedFields): TestDeprecatedFields {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 deprecated_int32 = 1 [deprecated = true];*/ 1:
                    message.deprecatedInt32 = reader.int32();
                    break;
                case /* int32 deprecated_int32_in_oneof = 2 [deprecated = true];*/ 2:
                    message.oneofFields = {
                        oneofKind: "deprecatedInt32InOneof",
                        deprecatedInt32InOneof: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDeprecatedFields, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 deprecated_int32 = 1 [deprecated = true]; */
        if (message.deprecatedInt32 !== undefined)
            writer.tag(1, WireType.Varint).int32(message.deprecatedInt32);
        /* int32 deprecated_int32_in_oneof = 2 [deprecated = true]; */
        if (message.oneofFields.oneofKind === "deprecatedInt32InOneof")
            writer.tag(2, WireType.Varint).int32(message.oneofFields.deprecatedInt32InOneof);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDeprecatedFields
 */
export const TestDeprecatedFields = new TestDeprecatedFields$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDeprecatedMessage$Type extends MessageType<TestDeprecatedMessage> {
    constructor() {
        super("protobuf_unittest.TestDeprecatedMessage", []);
    }
    create(value?: PartialMessage<TestDeprecatedMessage>): TestDeprecatedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestDeprecatedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDeprecatedMessage): TestDeprecatedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDeprecatedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @deprecated
 * @generated MessageType for protobuf message protobuf_unittest.TestDeprecatedMessage
 */
export const TestDeprecatedMessage = new TestDeprecatedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForeignMessage$Type extends MessageType<ForeignMessage> {
    constructor() {
        super("protobuf_unittest.ForeignMessage", [
            { no: 1, name: "c", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "d", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForeignMessage>): ForeignMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ForeignMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForeignMessage): ForeignMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 c */ 1:
                    message.c = reader.int32();
                    break;
                case /* optional int32 d */ 2:
                    message.d = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForeignMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 c = 1; */
        if (message.c !== undefined)
            writer.tag(1, WireType.Varint).int32(message.c);
        /* optional int32 d = 2; */
        if (message.d !== undefined)
            writer.tag(2, WireType.Varint).int32(message.d);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.ForeignMessage
 */
export const ForeignMessage = new ForeignMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReservedFields$Type extends MessageType<TestReservedFields> {
    constructor() {
        super("protobuf_unittest.TestReservedFields", []);
    }
    create(value?: PartialMessage<TestReservedFields>): TestReservedFields {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestReservedFields>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReservedFields): TestReservedFields {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReservedFields, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestReservedFields
 */
export const TestReservedFields = new TestReservedFields$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestAllExtensions$Type extends MessageType<TestAllExtensions> {
    constructor() {
        super("protobuf_unittest.TestAllExtensions", []);
    }
    create(value?: PartialMessage<TestAllExtensions>): TestAllExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestAllExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAllExtensions): TestAllExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAllExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestAllExtensions
 */
export const TestAllExtensions = new TestAllExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionalGroup_extension$Type extends MessageType<OptionalGroup_extension> {
    constructor() {
        super("protobuf_unittest.OptionalGroup_extension", [
            { no: 17, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OptionalGroup_extension>): OptionalGroup_extension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OptionalGroup_extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionalGroup_extension): OptionalGroup_extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 17:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionalGroup_extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 17; */
        if (message.a !== undefined)
            writer.tag(17, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.OptionalGroup_extension
 */
export const OptionalGroup_extension = new OptionalGroup_extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedGroup_extension$Type extends MessageType<RepeatedGroup_extension> {
    constructor() {
        super("protobuf_unittest.RepeatedGroup_extension", [
            { no: 47, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RepeatedGroup_extension>): RepeatedGroup_extension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RepeatedGroup_extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedGroup_extension): RepeatedGroup_extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 47:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RepeatedGroup_extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 47; */
        if (message.a !== undefined)
            writer.tag(47, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.RepeatedGroup_extension
 */
export const RepeatedGroup_extension = new RepeatedGroup_extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestGroup$Type extends MessageType<TestGroup> {
    constructor() {
        super("protobuf_unittest.TestGroup", [
            { no: 22, name: "optional_foreign_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] }
        ]);
    }
    create(value?: PartialMessage<TestGroup>): TestGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestGroup): TestGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.ForeignEnum optional_foreign_enum */ 22:
                    message.optionalForeignEnum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22; */
        if (message.optionalForeignEnum !== undefined)
            writer.tag(22, WireType.Varint).int32(message.optionalForeignEnum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestGroup
 */
export const TestGroup = new TestGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestGroup_OptionalGroup$Type extends MessageType<TestGroup_OptionalGroup> {
    constructor() {
        super("protobuf_unittest.TestGroup.OptionalGroup", [
            { no: 17, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestGroup_OptionalGroup>): TestGroup_OptionalGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestGroup_OptionalGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestGroup_OptionalGroup): TestGroup_OptionalGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 17:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestGroup_OptionalGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 17; */
        if (message.a !== undefined)
            writer.tag(17, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestGroup.OptionalGroup
 */
export const TestGroup_OptionalGroup = new TestGroup_OptionalGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestGroupExtension$Type extends MessageType<TestGroupExtension> {
    constructor() {
        super("protobuf_unittest.TestGroupExtension", []);
    }
    create(value?: PartialMessage<TestGroupExtension>): TestGroupExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestGroupExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestGroupExtension): TestGroupExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestGroupExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestGroupExtension
 */
export const TestGroupExtension = new TestGroupExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNestedExtension$Type extends MessageType<TestNestedExtension> {
    constructor() {
        super("protobuf_unittest.TestNestedExtension", []);
    }
    create(value?: PartialMessage<TestNestedExtension>): TestNestedExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestNestedExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNestedExtension): TestNestedExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNestedExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestNestedExtension
 */
export const TestNestedExtension = new TestNestedExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNestedExtension_OptionalGroup_extension$Type extends MessageType<TestNestedExtension_OptionalGroup_extension> {
    constructor() {
        super("protobuf_unittest.TestNestedExtension.OptionalGroup_extension", [
            { no: 17, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestNestedExtension_OptionalGroup_extension>): TestNestedExtension_OptionalGroup_extension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestNestedExtension_OptionalGroup_extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNestedExtension_OptionalGroup_extension): TestNestedExtension_OptionalGroup_extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 17:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNestedExtension_OptionalGroup_extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 17; */
        if (message.a !== undefined)
            writer.tag(17, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestNestedExtension.OptionalGroup_extension
 */
export const TestNestedExtension_OptionalGroup_extension = new TestNestedExtension_OptionalGroup_extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequired$Type extends MessageType<TestRequired> {
    constructor() {
        super("protobuf_unittest.TestRequired", [
            { no: 1, name: "a", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dummy2", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "b", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "dummy4", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "dummy5", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "dummy6", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "dummy7", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "dummy8", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "dummy9", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "dummy10", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "dummy11", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "dummy12", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "dummy13", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "dummy14", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "dummy15", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "dummy16", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "dummy17", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "dummy18", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "dummy19", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "dummy20", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "dummy21", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "dummy22", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "dummy23", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "dummy24", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "dummy25", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "dummy26", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "dummy27", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "dummy28", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "dummy29", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "dummy30", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "dummy31", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "dummy32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 33, name: "c", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestRequired>): TestRequired {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.a = 0;
        message.b = 0;
        message.c = 0;
        if (value !== undefined)
            reflectionMergePartial<TestRequired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequired): TestRequired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 a */ 1:
                    message.a = reader.int32();
                    break;
                case /* optional int32 dummy2 */ 2:
                    message.dummy2 = reader.int32();
                    break;
                case /* int32 b */ 3:
                    message.b = reader.int32();
                    break;
                case /* optional int32 dummy4 */ 4:
                    message.dummy4 = reader.int32();
                    break;
                case /* optional int32 dummy5 */ 5:
                    message.dummy5 = reader.int32();
                    break;
                case /* optional int32 dummy6 */ 6:
                    message.dummy6 = reader.int32();
                    break;
                case /* optional int32 dummy7 */ 7:
                    message.dummy7 = reader.int32();
                    break;
                case /* optional int32 dummy8 */ 8:
                    message.dummy8 = reader.int32();
                    break;
                case /* optional int32 dummy9 */ 9:
                    message.dummy9 = reader.int32();
                    break;
                case /* optional int32 dummy10 */ 10:
                    message.dummy10 = reader.int32();
                    break;
                case /* optional int32 dummy11 */ 11:
                    message.dummy11 = reader.int32();
                    break;
                case /* optional int32 dummy12 */ 12:
                    message.dummy12 = reader.int32();
                    break;
                case /* optional int32 dummy13 */ 13:
                    message.dummy13 = reader.int32();
                    break;
                case /* optional int32 dummy14 */ 14:
                    message.dummy14 = reader.int32();
                    break;
                case /* optional int32 dummy15 */ 15:
                    message.dummy15 = reader.int32();
                    break;
                case /* optional int32 dummy16 */ 16:
                    message.dummy16 = reader.int32();
                    break;
                case /* optional int32 dummy17 */ 17:
                    message.dummy17 = reader.int32();
                    break;
                case /* optional int32 dummy18 */ 18:
                    message.dummy18 = reader.int32();
                    break;
                case /* optional int32 dummy19 */ 19:
                    message.dummy19 = reader.int32();
                    break;
                case /* optional int32 dummy20 */ 20:
                    message.dummy20 = reader.int32();
                    break;
                case /* optional int32 dummy21 */ 21:
                    message.dummy21 = reader.int32();
                    break;
                case /* optional int32 dummy22 */ 22:
                    message.dummy22 = reader.int32();
                    break;
                case /* optional int32 dummy23 */ 23:
                    message.dummy23 = reader.int32();
                    break;
                case /* optional int32 dummy24 */ 24:
                    message.dummy24 = reader.int32();
                    break;
                case /* optional int32 dummy25 */ 25:
                    message.dummy25 = reader.int32();
                    break;
                case /* optional int32 dummy26 */ 26:
                    message.dummy26 = reader.int32();
                    break;
                case /* optional int32 dummy27 */ 27:
                    message.dummy27 = reader.int32();
                    break;
                case /* optional int32 dummy28 */ 28:
                    message.dummy28 = reader.int32();
                    break;
                case /* optional int32 dummy29 */ 29:
                    message.dummy29 = reader.int32();
                    break;
                case /* optional int32 dummy30 */ 30:
                    message.dummy30 = reader.int32();
                    break;
                case /* optional int32 dummy31 */ 31:
                    message.dummy31 = reader.int32();
                    break;
                case /* optional int32 dummy32 */ 32:
                    message.dummy32 = reader.int32();
                    break;
                case /* int32 c */ 33:
                    message.c = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 a = 1; */
        if (message.a !== 0)
            writer.tag(1, WireType.Varint).int32(message.a);
        /* optional int32 dummy2 = 2; */
        if (message.dummy2 !== undefined)
            writer.tag(2, WireType.Varint).int32(message.dummy2);
        /* int32 b = 3; */
        if (message.b !== 0)
            writer.tag(3, WireType.Varint).int32(message.b);
        /* optional int32 dummy4 = 4; */
        if (message.dummy4 !== undefined)
            writer.tag(4, WireType.Varint).int32(message.dummy4);
        /* optional int32 dummy5 = 5; */
        if (message.dummy5 !== undefined)
            writer.tag(5, WireType.Varint).int32(message.dummy5);
        /* optional int32 dummy6 = 6; */
        if (message.dummy6 !== undefined)
            writer.tag(6, WireType.Varint).int32(message.dummy6);
        /* optional int32 dummy7 = 7; */
        if (message.dummy7 !== undefined)
            writer.tag(7, WireType.Varint).int32(message.dummy7);
        /* optional int32 dummy8 = 8; */
        if (message.dummy8 !== undefined)
            writer.tag(8, WireType.Varint).int32(message.dummy8);
        /* optional int32 dummy9 = 9; */
        if (message.dummy9 !== undefined)
            writer.tag(9, WireType.Varint).int32(message.dummy9);
        /* optional int32 dummy10 = 10; */
        if (message.dummy10 !== undefined)
            writer.tag(10, WireType.Varint).int32(message.dummy10);
        /* optional int32 dummy11 = 11; */
        if (message.dummy11 !== undefined)
            writer.tag(11, WireType.Varint).int32(message.dummy11);
        /* optional int32 dummy12 = 12; */
        if (message.dummy12 !== undefined)
            writer.tag(12, WireType.Varint).int32(message.dummy12);
        /* optional int32 dummy13 = 13; */
        if (message.dummy13 !== undefined)
            writer.tag(13, WireType.Varint).int32(message.dummy13);
        /* optional int32 dummy14 = 14; */
        if (message.dummy14 !== undefined)
            writer.tag(14, WireType.Varint).int32(message.dummy14);
        /* optional int32 dummy15 = 15; */
        if (message.dummy15 !== undefined)
            writer.tag(15, WireType.Varint).int32(message.dummy15);
        /* optional int32 dummy16 = 16; */
        if (message.dummy16 !== undefined)
            writer.tag(16, WireType.Varint).int32(message.dummy16);
        /* optional int32 dummy17 = 17; */
        if (message.dummy17 !== undefined)
            writer.tag(17, WireType.Varint).int32(message.dummy17);
        /* optional int32 dummy18 = 18; */
        if (message.dummy18 !== undefined)
            writer.tag(18, WireType.Varint).int32(message.dummy18);
        /* optional int32 dummy19 = 19; */
        if (message.dummy19 !== undefined)
            writer.tag(19, WireType.Varint).int32(message.dummy19);
        /* optional int32 dummy20 = 20; */
        if (message.dummy20 !== undefined)
            writer.tag(20, WireType.Varint).int32(message.dummy20);
        /* optional int32 dummy21 = 21; */
        if (message.dummy21 !== undefined)
            writer.tag(21, WireType.Varint).int32(message.dummy21);
        /* optional int32 dummy22 = 22; */
        if (message.dummy22 !== undefined)
            writer.tag(22, WireType.Varint).int32(message.dummy22);
        /* optional int32 dummy23 = 23; */
        if (message.dummy23 !== undefined)
            writer.tag(23, WireType.Varint).int32(message.dummy23);
        /* optional int32 dummy24 = 24; */
        if (message.dummy24 !== undefined)
            writer.tag(24, WireType.Varint).int32(message.dummy24);
        /* optional int32 dummy25 = 25; */
        if (message.dummy25 !== undefined)
            writer.tag(25, WireType.Varint).int32(message.dummy25);
        /* optional int32 dummy26 = 26; */
        if (message.dummy26 !== undefined)
            writer.tag(26, WireType.Varint).int32(message.dummy26);
        /* optional int32 dummy27 = 27; */
        if (message.dummy27 !== undefined)
            writer.tag(27, WireType.Varint).int32(message.dummy27);
        /* optional int32 dummy28 = 28; */
        if (message.dummy28 !== undefined)
            writer.tag(28, WireType.Varint).int32(message.dummy28);
        /* optional int32 dummy29 = 29; */
        if (message.dummy29 !== undefined)
            writer.tag(29, WireType.Varint).int32(message.dummy29);
        /* optional int32 dummy30 = 30; */
        if (message.dummy30 !== undefined)
            writer.tag(30, WireType.Varint).int32(message.dummy30);
        /* optional int32 dummy31 = 31; */
        if (message.dummy31 !== undefined)
            writer.tag(31, WireType.Varint).int32(message.dummy31);
        /* optional int32 dummy32 = 32; */
        if (message.dummy32 !== undefined)
            writer.tag(32, WireType.Varint).int32(message.dummy32);
        /* int32 c = 33; */
        if (message.c !== 0)
            writer.tag(33, WireType.Varint).int32(message.c);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequired
 */
export const TestRequired = new TestRequired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredForeign$Type extends MessageType<TestRequiredForeign> {
    constructor() {
        super("protobuf_unittest.TestRequiredForeign", [
            { no: 1, name: "optional_message", kind: "message", T: () => TestRequired },
            { no: 2, name: "repeated_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestRequired },
            { no: 3, name: "dummy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestRequiredForeign>): TestRequiredForeign {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedMessage = [];
        if (value !== undefined)
            reflectionMergePartial<TestRequiredForeign>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredForeign): TestRequiredForeign {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestRequired optional_message */ 1:
                    message.optionalMessage = TestRequired.internalBinaryRead(reader, reader.uint32(), options, message.optionalMessage);
                    break;
                case /* repeated protobuf_unittest.TestRequired repeated_message */ 2:
                    message.repeatedMessage.push(TestRequired.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 dummy */ 3:
                    message.dummy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequiredForeign, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestRequired optional_message = 1; */
        if (message.optionalMessage)
            TestRequired.internalBinaryWrite(message.optionalMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestRequired repeated_message = 2; */
        for (let i = 0; i < message.repeatedMessage.length; i++)
            TestRequired.internalBinaryWrite(message.repeatedMessage[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 dummy = 3; */
        if (message.dummy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.dummy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredForeign
 */
export const TestRequiredForeign = new TestRequiredForeign$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredMessage$Type extends MessageType<TestRequiredMessage> {
    constructor() {
        super("protobuf_unittest.TestRequiredMessage", [
            { no: 1, name: "optional_message", kind: "message", T: () => TestRequired },
            { no: 2, name: "repeated_message", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestRequired },
            { no: 3, name: "required_message", kind: "message", T: () => TestRequired }
        ]);
    }
    create(value?: PartialMessage<TestRequiredMessage>): TestRequiredMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedMessage = [];
        if (value !== undefined)
            reflectionMergePartial<TestRequiredMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredMessage): TestRequiredMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestRequired optional_message */ 1:
                    message.optionalMessage = TestRequired.internalBinaryRead(reader, reader.uint32(), options, message.optionalMessage);
                    break;
                case /* repeated protobuf_unittest.TestRequired repeated_message */ 2:
                    message.repeatedMessage.push(TestRequired.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* protobuf_unittest.TestRequired required_message */ 3:
                    message.requiredMessage = TestRequired.internalBinaryRead(reader, reader.uint32(), options, message.requiredMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequiredMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestRequired optional_message = 1; */
        if (message.optionalMessage)
            TestRequired.internalBinaryWrite(message.optionalMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestRequired repeated_message = 2; */
        for (let i = 0; i < message.repeatedMessage.length; i++)
            TestRequired.internalBinaryWrite(message.repeatedMessage[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protobuf_unittest.TestRequired required_message = 3; */
        if (message.requiredMessage)
            TestRequired.internalBinaryWrite(message.requiredMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredMessage
 */
export const TestRequiredMessage = new TestRequiredMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestForeignNested$Type extends MessageType<TestForeignNested> {
    constructor() {
        super("protobuf_unittest.TestForeignNested", [
            { no: 1, name: "foreign_nested", kind: "message", T: () => TestAllTypes_NestedMessage }
        ]);
    }
    create(value?: PartialMessage<TestForeignNested>): TestForeignNested {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestForeignNested>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestForeignNested): TestForeignNested {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes.NestedMessage foreign_nested */ 1:
                    message.foreignNested = TestAllTypes_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.foreignNested);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestForeignNested, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes.NestedMessage foreign_nested = 1; */
        if (message.foreignNested)
            TestAllTypes_NestedMessage.internalBinaryWrite(message.foreignNested, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestForeignNested
 */
export const TestForeignNested = new TestForeignNested$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEmptyMessage$Type extends MessageType<TestEmptyMessage> {
    constructor() {
        super("protobuf_unittest.TestEmptyMessage", []);
    }
    create(value?: PartialMessage<TestEmptyMessage>): TestEmptyMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestEmptyMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEmptyMessage): TestEmptyMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestEmptyMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEmptyMessage
 */
export const TestEmptyMessage = new TestEmptyMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEmptyMessageWithExtensions$Type extends MessageType<TestEmptyMessageWithExtensions> {
    constructor() {
        super("protobuf_unittest.TestEmptyMessageWithExtensions", []);
    }
    create(value?: PartialMessage<TestEmptyMessageWithExtensions>): TestEmptyMessageWithExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestEmptyMessageWithExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEmptyMessageWithExtensions): TestEmptyMessageWithExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestEmptyMessageWithExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEmptyMessageWithExtensions
 */
export const TestEmptyMessageWithExtensions = new TestEmptyMessageWithExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestPickleNestedMessage$Type extends MessageType<TestPickleNestedMessage> {
    constructor() {
        super("protobuf_unittest.TestPickleNestedMessage", []);
    }
    create(value?: PartialMessage<TestPickleNestedMessage>): TestPickleNestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestPickleNestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestPickleNestedMessage): TestPickleNestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestPickleNestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestPickleNestedMessage
 */
export const TestPickleNestedMessage = new TestPickleNestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestPickleNestedMessage_NestedMessage$Type extends MessageType<TestPickleNestedMessage_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestPickleNestedMessage.NestedMessage", [
            { no: 1, name: "bb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestPickleNestedMessage_NestedMessage>): TestPickleNestedMessage_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestPickleNestedMessage_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestPickleNestedMessage_NestedMessage): TestPickleNestedMessage_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 bb */ 1:
                    message.bb = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestPickleNestedMessage_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 bb = 1; */
        if (message.bb !== undefined)
            writer.tag(1, WireType.Varint).int32(message.bb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestPickleNestedMessage.NestedMessage
 */
export const TestPickleNestedMessage_NestedMessage = new TestPickleNestedMessage_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestPickleNestedMessage_NestedMessage_NestedNestedMessage$Type extends MessageType<TestPickleNestedMessage_NestedMessage_NestedNestedMessage> {
    constructor() {
        super("protobuf_unittest.TestPickleNestedMessage.NestedMessage.NestedNestedMessage", [
            { no: 1, name: "cc", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestPickleNestedMessage_NestedMessage_NestedNestedMessage>): TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestPickleNestedMessage_NestedMessage_NestedNestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestPickleNestedMessage_NestedMessage_NestedNestedMessage): TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cc */ 1:
                    message.cc = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestPickleNestedMessage_NestedMessage_NestedNestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cc = 1; */
        if (message.cc !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestPickleNestedMessage.NestedMessage.NestedNestedMessage
 */
export const TestPickleNestedMessage_NestedMessage_NestedNestedMessage = new TestPickleNestedMessage_NestedMessage_NestedNestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMultipleExtensionRanges$Type extends MessageType<TestMultipleExtensionRanges> {
    constructor() {
        super("protobuf_unittest.TestMultipleExtensionRanges", []);
    }
    create(value?: PartialMessage<TestMultipleExtensionRanges>): TestMultipleExtensionRanges {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMultipleExtensionRanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMultipleExtensionRanges): TestMultipleExtensionRanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMultipleExtensionRanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMultipleExtensionRanges
 */
export const TestMultipleExtensionRanges = new TestMultipleExtensionRanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReallyLargeTagNumber$Type extends MessageType<TestReallyLargeTagNumber> {
    constructor() {
        super("protobuf_unittest.TestReallyLargeTagNumber", [
            { no: 1, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 268435455, name: "bb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestReallyLargeTagNumber>): TestReallyLargeTagNumber {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestReallyLargeTagNumber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReallyLargeTagNumber): TestReallyLargeTagNumber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 1:
                    message.a = reader.int32();
                    break;
                case /* optional int32 bb */ 268435455:
                    message.bb = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReallyLargeTagNumber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 1; */
        if (message.a !== undefined)
            writer.tag(1, WireType.Varint).int32(message.a);
        /* optional int32 bb = 268435455; */
        if (message.bb !== undefined)
            writer.tag(268435455, WireType.Varint).int32(message.bb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestReallyLargeTagNumber
 */
export const TestReallyLargeTagNumber = new TestReallyLargeTagNumber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRecursiveMessage$Type extends MessageType<TestRecursiveMessage> {
    constructor() {
        super("protobuf_unittest.TestRecursiveMessage", [
            { no: 1, name: "a", kind: "message", T: () => TestRecursiveMessage },
            { no: 2, name: "i", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestRecursiveMessage>): TestRecursiveMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestRecursiveMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRecursiveMessage): TestRecursiveMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestRecursiveMessage a */ 1:
                    message.a = TestRecursiveMessage.internalBinaryRead(reader, reader.uint32(), options, message.a);
                    break;
                case /* optional int32 i */ 2:
                    message.i = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRecursiveMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestRecursiveMessage a = 1; */
        if (message.a)
            TestRecursiveMessage.internalBinaryWrite(message.a, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 i = 2; */
        if (message.i !== undefined)
            writer.tag(2, WireType.Varint).int32(message.i);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRecursiveMessage
 */
export const TestRecursiveMessage = new TestRecursiveMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMutualRecursionA$Type extends MessageType<TestMutualRecursionA> {
    constructor() {
        super("protobuf_unittest.TestMutualRecursionA", [
            { no: 1, name: "bb", kind: "message", T: () => TestMutualRecursionB }
        ]);
    }
    create(value?: PartialMessage<TestMutualRecursionA>): TestMutualRecursionA {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMutualRecursionA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMutualRecursionA): TestMutualRecursionA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestMutualRecursionB bb */ 1:
                    message.bb = TestMutualRecursionB.internalBinaryRead(reader, reader.uint32(), options, message.bb);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMutualRecursionA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestMutualRecursionB bb = 1; */
        if (message.bb)
            TestMutualRecursionB.internalBinaryWrite(message.bb, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMutualRecursionA
 */
export const TestMutualRecursionA = new TestMutualRecursionA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMutualRecursionA_SubMessage$Type extends MessageType<TestMutualRecursionA_SubMessage> {
    constructor() {
        super("protobuf_unittest.TestMutualRecursionA.SubMessage", [
            { no: 1, name: "b", kind: "message", T: () => TestMutualRecursionB }
        ]);
    }
    create(value?: PartialMessage<TestMutualRecursionA_SubMessage>): TestMutualRecursionA_SubMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMutualRecursionA_SubMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMutualRecursionA_SubMessage): TestMutualRecursionA_SubMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestMutualRecursionB b */ 1:
                    message.b = TestMutualRecursionB.internalBinaryRead(reader, reader.uint32(), options, message.b);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMutualRecursionA_SubMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestMutualRecursionB b = 1; */
        if (message.b)
            TestMutualRecursionB.internalBinaryWrite(message.b, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMutualRecursionA.SubMessage
 */
export const TestMutualRecursionA_SubMessage = new TestMutualRecursionA_SubMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMutualRecursionA_SubGroup$Type extends MessageType<TestMutualRecursionA_SubGroup> {
    constructor() {
        super("protobuf_unittest.TestMutualRecursionA.SubGroup", [
            { no: 3, name: "sub_message", kind: "message", T: () => TestMutualRecursionA_SubMessage },
            { no: 4, name: "not_in_this_scc", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestMutualRecursionA_SubGroup>): TestMutualRecursionA_SubGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMutualRecursionA_SubGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMutualRecursionA_SubGroup): TestMutualRecursionA_SubGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestMutualRecursionA.SubMessage sub_message */ 3:
                    message.subMessage = TestMutualRecursionA_SubMessage.internalBinaryRead(reader, reader.uint32(), options, message.subMessage);
                    break;
                case /* optional protobuf_unittest.TestAllTypes not_in_this_scc */ 4:
                    message.notInThisScc = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.notInThisScc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMutualRecursionA_SubGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestMutualRecursionA.SubMessage sub_message = 3; */
        if (message.subMessage)
            TestMutualRecursionA_SubMessage.internalBinaryWrite(message.subMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestAllTypes not_in_this_scc = 4; */
        if (message.notInThisScc)
            TestAllTypes.internalBinaryWrite(message.notInThisScc, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMutualRecursionA.SubGroup
 */
export const TestMutualRecursionA_SubGroup = new TestMutualRecursionA_SubGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMutualRecursionB$Type extends MessageType<TestMutualRecursionB> {
    constructor() {
        super("protobuf_unittest.TestMutualRecursionB", [
            { no: 1, name: "a", kind: "message", T: () => TestMutualRecursionA },
            { no: 2, name: "optional_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestMutualRecursionB>): TestMutualRecursionB {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMutualRecursionB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMutualRecursionB): TestMutualRecursionB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestMutualRecursionA a */ 1:
                    message.a = TestMutualRecursionA.internalBinaryRead(reader, reader.uint32(), options, message.a);
                    break;
                case /* optional int32 optional_int32 */ 2:
                    message.optionalInt32 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMutualRecursionB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestMutualRecursionA a = 1; */
        if (message.a)
            TestMutualRecursionA.internalBinaryWrite(message.a, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 optional_int32 = 2; */
        if (message.optionalInt32 !== undefined)
            writer.tag(2, WireType.Varint).int32(message.optionalInt32);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMutualRecursionB
 */
export const TestMutualRecursionB = new TestMutualRecursionB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestIsInitialized$Type extends MessageType<TestIsInitialized> {
    constructor() {
        super("protobuf_unittest.TestIsInitialized", [
            { no: 1, name: "sub_message", kind: "message", T: () => TestIsInitialized_SubMessage }
        ]);
    }
    create(value?: PartialMessage<TestIsInitialized>): TestIsInitialized {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestIsInitialized>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestIsInitialized): TestIsInitialized {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestIsInitialized.SubMessage sub_message */ 1:
                    message.subMessage = TestIsInitialized_SubMessage.internalBinaryRead(reader, reader.uint32(), options, message.subMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestIsInitialized, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestIsInitialized.SubMessage sub_message = 1; */
        if (message.subMessage)
            TestIsInitialized_SubMessage.internalBinaryWrite(message.subMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestIsInitialized
 */
export const TestIsInitialized = new TestIsInitialized$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestIsInitialized_SubMessage$Type extends MessageType<TestIsInitialized_SubMessage> {
    constructor() {
        super("protobuf_unittest.TestIsInitialized.SubMessage", []);
    }
    create(value?: PartialMessage<TestIsInitialized_SubMessage>): TestIsInitialized_SubMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestIsInitialized_SubMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestIsInitialized_SubMessage): TestIsInitialized_SubMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestIsInitialized_SubMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestIsInitialized.SubMessage
 */
export const TestIsInitialized_SubMessage = new TestIsInitialized_SubMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestIsInitialized_SubMessage_SubGroup$Type extends MessageType<TestIsInitialized_SubMessage_SubGroup> {
    constructor() {
        super("protobuf_unittest.TestIsInitialized.SubMessage.SubGroup", [
            { no: 2, name: "i", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestIsInitialized_SubMessage_SubGroup>): TestIsInitialized_SubMessage_SubGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.i = 0;
        if (value !== undefined)
            reflectionMergePartial<TestIsInitialized_SubMessage_SubGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestIsInitialized_SubMessage_SubGroup): TestIsInitialized_SubMessage_SubGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 i */ 2:
                    message.i = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestIsInitialized_SubMessage_SubGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 i = 2; */
        if (message.i !== 0)
            writer.tag(2, WireType.Varint).int32(message.i);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestIsInitialized.SubMessage.SubGroup
 */
export const TestIsInitialized_SubMessage_SubGroup = new TestIsInitialized_SubMessage_SubGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDupFieldNumber$Type extends MessageType<TestDupFieldNumber> {
    constructor() {
        super("protobuf_unittest.TestDupFieldNumber", [
            { no: 1, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDupFieldNumber>): TestDupFieldNumber {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestDupFieldNumber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDupFieldNumber): TestDupFieldNumber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 1:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDupFieldNumber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 1; */
        if (message.a !== undefined)
            writer.tag(1, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDupFieldNumber
 */
export const TestDupFieldNumber = new TestDupFieldNumber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDupFieldNumber_Foo$Type extends MessageType<TestDupFieldNumber_Foo> {
    constructor() {
        super("protobuf_unittest.TestDupFieldNumber.Foo", [
            { no: 1, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDupFieldNumber_Foo>): TestDupFieldNumber_Foo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestDupFieldNumber_Foo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDupFieldNumber_Foo): TestDupFieldNumber_Foo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 1:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDupFieldNumber_Foo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 1; */
        if (message.a !== undefined)
            writer.tag(1, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDupFieldNumber.Foo
 */
export const TestDupFieldNumber_Foo = new TestDupFieldNumber_Foo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDupFieldNumber_Bar$Type extends MessageType<TestDupFieldNumber_Bar> {
    constructor() {
        super("protobuf_unittest.TestDupFieldNumber.Bar", [
            { no: 1, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDupFieldNumber_Bar>): TestDupFieldNumber_Bar {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestDupFieldNumber_Bar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDupFieldNumber_Bar): TestDupFieldNumber_Bar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 1:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDupFieldNumber_Bar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 1; */
        if (message.a !== undefined)
            writer.tag(1, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDupFieldNumber.Bar
 */
export const TestDupFieldNumber_Bar = new TestDupFieldNumber_Bar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEagerMessage$Type extends MessageType<TestEagerMessage> {
    constructor() {
        super("protobuf_unittest.TestEagerMessage", [
            { no: 1, name: "sub_message", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestEagerMessage>): TestEagerMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestEagerMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEagerMessage): TestEagerMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes sub_message */ 1:
                    message.subMessage = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.subMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestEagerMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes sub_message = 1; */
        if (message.subMessage)
            TestAllTypes.internalBinaryWrite(message.subMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEagerMessage
 */
export const TestEagerMessage = new TestEagerMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestLazyMessage$Type extends MessageType<TestLazyMessage> {
    constructor() {
        super("protobuf_unittest.TestLazyMessage", [
            { no: 1, name: "sub_message", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestLazyMessage>): TestLazyMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestLazyMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestLazyMessage): TestLazyMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes sub_message */ 1:
                    message.subMessage = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.subMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestLazyMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes sub_message = 1; */
        if (message.subMessage)
            TestAllTypes.internalBinaryWrite(message.subMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestLazyMessage
 */
export const TestLazyMessage = new TestLazyMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNestedMessageHasBits$Type extends MessageType<TestNestedMessageHasBits> {
    constructor() {
        super("protobuf_unittest.TestNestedMessageHasBits", [
            { no: 1, name: "optional_nested_message", kind: "message", T: () => TestNestedMessageHasBits_NestedMessage }
        ]);
    }
    create(value?: PartialMessage<TestNestedMessageHasBits>): TestNestedMessageHasBits {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestNestedMessageHasBits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNestedMessageHasBits): TestNestedMessageHasBits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestNestedMessageHasBits.NestedMessage optional_nested_message */ 1:
                    message.optionalNestedMessage = TestNestedMessageHasBits_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalNestedMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNestedMessageHasBits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestNestedMessageHasBits.NestedMessage optional_nested_message = 1; */
        if (message.optionalNestedMessage)
            TestNestedMessageHasBits_NestedMessage.internalBinaryWrite(message.optionalNestedMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestNestedMessageHasBits
 */
export const TestNestedMessageHasBits = new TestNestedMessageHasBits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNestedMessageHasBits_NestedMessage$Type extends MessageType<TestNestedMessageHasBits_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestNestedMessageHasBits.NestedMessage", [
            { no: 1, name: "nestedmessage_repeated_int32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "nestedmessage_repeated_foreignmessage", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ForeignMessage }
        ]);
    }
    create(value?: PartialMessage<TestNestedMessageHasBits_NestedMessage>): TestNestedMessageHasBits_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nestedmessageRepeatedInt32 = [];
        message.nestedmessageRepeatedForeignmessage = [];
        if (value !== undefined)
            reflectionMergePartial<TestNestedMessageHasBits_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNestedMessageHasBits_NestedMessage): TestNestedMessageHasBits_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 nestedmessage_repeated_int32 */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.nestedmessageRepeatedInt32.push(reader.int32());
                    else
                        message.nestedmessageRepeatedInt32.push(reader.int32());
                    break;
                case /* repeated protobuf_unittest.ForeignMessage nestedmessage_repeated_foreignmessage */ 2:
                    message.nestedmessageRepeatedForeignmessage.push(ForeignMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNestedMessageHasBits_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 nestedmessage_repeated_int32 = 1; */
        for (let i = 0; i < message.nestedmessageRepeatedInt32.length; i++)
            writer.tag(1, WireType.Varint).int32(message.nestedmessageRepeatedInt32[i]);
        /* repeated protobuf_unittest.ForeignMessage nestedmessage_repeated_foreignmessage = 2; */
        for (let i = 0; i < message.nestedmessageRepeatedForeignmessage.length; i++)
            ForeignMessage.internalBinaryWrite(message.nestedmessageRepeatedForeignmessage[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestNestedMessageHasBits.NestedMessage
 */
export const TestNestedMessageHasBits_NestedMessage = new TestNestedMessageHasBits_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestCamelCaseFieldNames$Type extends MessageType<TestCamelCaseFieldNames> {
    constructor() {
        super("protobuf_unittest.TestCamelCaseFieldNames", [
            { no: 1, name: "PrimitiveField", kind: "scalar", jsonName: "PrimitiveField", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "StringField", kind: "scalar", jsonName: "StringField", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "EnumField", kind: "enum", jsonName: "EnumField", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 4, name: "MessageField", kind: "message", jsonName: "MessageField", T: () => ForeignMessage },
            { no: 5, name: "StringPieceField", kind: "scalar", jsonName: "StringPieceField", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "CordField", kind: "scalar", jsonName: "CordField", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "RepeatedPrimitiveField", kind: "scalar", jsonName: "RepeatedPrimitiveField", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "RepeatedStringField", kind: "scalar", jsonName: "RepeatedStringField", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "RepeatedEnumField", kind: "enum", jsonName: "RepeatedEnumField", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 10, name: "RepeatedMessageField", kind: "message", jsonName: "RepeatedMessageField", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ForeignMessage },
            { no: 11, name: "RepeatedStringPieceField", kind: "scalar", jsonName: "RepeatedStringPieceField", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "RepeatedCordField", kind: "scalar", jsonName: "RepeatedCordField", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestCamelCaseFieldNames>): TestCamelCaseFieldNames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedPrimitiveField = [];
        message.repeatedStringField = [];
        message.repeatedEnumField = [];
        message.repeatedMessageField = [];
        message.repeatedStringPieceField = [];
        message.repeatedCordField = [];
        if (value !== undefined)
            reflectionMergePartial<TestCamelCaseFieldNames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestCamelCaseFieldNames): TestCamelCaseFieldNames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 PrimitiveField = 1 [json_name = "PrimitiveField"];*/ 1:
                    message.primitiveField = reader.int32();
                    break;
                case /* optional string StringField = 2 [json_name = "StringField"];*/ 2:
                    message.stringField = reader.string();
                    break;
                case /* optional protobuf_unittest.ForeignEnum EnumField = 3 [json_name = "EnumField"];*/ 3:
                    message.enumField = reader.int32();
                    break;
                case /* optional protobuf_unittest.ForeignMessage MessageField = 4 [json_name = "MessageField"];*/ 4:
                    message.messageField = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options, message.messageField);
                    break;
                case /* optional string StringPieceField = 5 [json_name = "StringPieceField"];*/ 5:
                    message.stringPieceField = reader.string();
                    break;
                case /* optional string CordField = 6 [json_name = "CordField"];*/ 6:
                    message.cordField = reader.string();
                    break;
                case /* repeated int32 RepeatedPrimitiveField = 7 [json_name = "RepeatedPrimitiveField"];*/ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedPrimitiveField.push(reader.int32());
                    else
                        message.repeatedPrimitiveField.push(reader.int32());
                    break;
                case /* repeated string RepeatedStringField = 8 [json_name = "RepeatedStringField"];*/ 8:
                    message.repeatedStringField.push(reader.string());
                    break;
                case /* repeated protobuf_unittest.ForeignEnum RepeatedEnumField = 9 [json_name = "RepeatedEnumField"];*/ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedEnumField.push(reader.int32());
                    else
                        message.repeatedEnumField.push(reader.int32());
                    break;
                case /* repeated protobuf_unittest.ForeignMessage RepeatedMessageField = 10 [json_name = "RepeatedMessageField"];*/ 10:
                    message.repeatedMessageField.push(ForeignMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string RepeatedStringPieceField = 11 [json_name = "RepeatedStringPieceField"];*/ 11:
                    message.repeatedStringPieceField.push(reader.string());
                    break;
                case /* repeated string RepeatedCordField = 12 [json_name = "RepeatedCordField"];*/ 12:
                    message.repeatedCordField.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestCamelCaseFieldNames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 PrimitiveField = 1 [json_name = "PrimitiveField"]; */
        if (message.primitiveField !== undefined)
            writer.tag(1, WireType.Varint).int32(message.primitiveField);
        /* optional string StringField = 2 [json_name = "StringField"]; */
        if (message.stringField !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.stringField);
        /* optional protobuf_unittest.ForeignEnum EnumField = 3 [json_name = "EnumField"]; */
        if (message.enumField !== undefined)
            writer.tag(3, WireType.Varint).int32(message.enumField);
        /* optional protobuf_unittest.ForeignMessage MessageField = 4 [json_name = "MessageField"]; */
        if (message.messageField)
            ForeignMessage.internalBinaryWrite(message.messageField, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string StringPieceField = 5 [json_name = "StringPieceField"]; */
        if (message.stringPieceField !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.stringPieceField);
        /* optional string CordField = 6 [json_name = "CordField"]; */
        if (message.cordField !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.cordField);
        /* repeated int32 RepeatedPrimitiveField = 7 [json_name = "RepeatedPrimitiveField"]; */
        for (let i = 0; i < message.repeatedPrimitiveField.length; i++)
            writer.tag(7, WireType.Varint).int32(message.repeatedPrimitiveField[i]);
        /* repeated string RepeatedStringField = 8 [json_name = "RepeatedStringField"]; */
        for (let i = 0; i < message.repeatedStringField.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.repeatedStringField[i]);
        /* repeated protobuf_unittest.ForeignEnum RepeatedEnumField = 9 [json_name = "RepeatedEnumField"]; */
        for (let i = 0; i < message.repeatedEnumField.length; i++)
            writer.tag(9, WireType.Varint).int32(message.repeatedEnumField[i]);
        /* repeated protobuf_unittest.ForeignMessage RepeatedMessageField = 10 [json_name = "RepeatedMessageField"]; */
        for (let i = 0; i < message.repeatedMessageField.length; i++)
            ForeignMessage.internalBinaryWrite(message.repeatedMessageField[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string RepeatedStringPieceField = 11 [json_name = "RepeatedStringPieceField"]; */
        for (let i = 0; i < message.repeatedStringPieceField.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.repeatedStringPieceField[i]);
        /* repeated string RepeatedCordField = 12 [json_name = "RepeatedCordField"]; */
        for (let i = 0; i < message.repeatedCordField.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.repeatedCordField[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestCamelCaseFieldNames
 */
export const TestCamelCaseFieldNames = new TestCamelCaseFieldNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFieldOrderings$Type extends MessageType<TestFieldOrderings> {
    constructor() {
        super("protobuf_unittest.TestFieldOrderings", [
            { no: 11, name: "my_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "my_int", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 101, name: "my_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 200, name: "optional_nested_message", kind: "message", T: () => TestFieldOrderings_NestedMessage }
        ]);
    }
    create(value?: PartialMessage<TestFieldOrderings>): TestFieldOrderings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestFieldOrderings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFieldOrderings): TestFieldOrderings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string my_string */ 11:
                    message.myString = reader.string();
                    break;
                case /* optional int64 my_int */ 1:
                    message.myInt = reader.int64().toBigInt();
                    break;
                case /* optional float my_float */ 101:
                    message.myFloat = reader.float();
                    break;
                case /* optional protobuf_unittest.TestFieldOrderings.NestedMessage optional_nested_message */ 200:
                    message.optionalNestedMessage = TestFieldOrderings_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalNestedMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFieldOrderings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string my_string = 11; */
        if (message.myString !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.myString);
        /* optional int64 my_int = 1; */
        if (message.myInt !== undefined)
            writer.tag(1, WireType.Varint).int64(message.myInt);
        /* optional float my_float = 101; */
        if (message.myFloat !== undefined)
            writer.tag(101, WireType.Bit32).float(message.myFloat);
        /* optional protobuf_unittest.TestFieldOrderings.NestedMessage optional_nested_message = 200; */
        if (message.optionalNestedMessage)
            TestFieldOrderings_NestedMessage.internalBinaryWrite(message.optionalNestedMessage, writer.tag(200, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestFieldOrderings
 */
export const TestFieldOrderings = new TestFieldOrderings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFieldOrderings_NestedMessage$Type extends MessageType<TestFieldOrderings_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestFieldOrderings.NestedMessage", [
            { no: 2, name: "oo", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1, name: "bb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestFieldOrderings_NestedMessage>): TestFieldOrderings_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestFieldOrderings_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFieldOrderings_NestedMessage): TestFieldOrderings_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 oo */ 2:
                    message.oo = reader.int64().toBigInt();
                    break;
                case /* optional int32 bb */ 1:
                    message.bb = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFieldOrderings_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 oo = 2; */
        if (message.oo !== undefined)
            writer.tag(2, WireType.Varint).int64(message.oo);
        /* optional int32 bb = 1; */
        if (message.bb !== undefined)
            writer.tag(1, WireType.Varint).int32(message.bb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestFieldOrderings.NestedMessage
 */
export const TestFieldOrderings_NestedMessage = new TestFieldOrderings_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtensionOrderings1$Type extends MessageType<TestExtensionOrderings1> {
    constructor() {
        super("protobuf_unittest.TestExtensionOrderings1", [
            { no: 1, name: "my_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestExtensionOrderings1>): TestExtensionOrderings1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtensionOrderings1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtensionOrderings1): TestExtensionOrderings1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string my_string */ 1:
                    message.myString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtensionOrderings1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string my_string = 1; */
        if (message.myString !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.myString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestExtensionOrderings1
 */
export const TestExtensionOrderings1 = new TestExtensionOrderings1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtensionOrderings2$Type extends MessageType<TestExtensionOrderings2> {
    constructor() {
        super("protobuf_unittest.TestExtensionOrderings2", [
            { no: 1, name: "my_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestExtensionOrderings2>): TestExtensionOrderings2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtensionOrderings2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtensionOrderings2): TestExtensionOrderings2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string my_string */ 1:
                    message.myString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtensionOrderings2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string my_string = 1; */
        if (message.myString !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.myString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestExtensionOrderings2
 */
export const TestExtensionOrderings2 = new TestExtensionOrderings2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtensionOrderings2_TestExtensionOrderings3$Type extends MessageType<TestExtensionOrderings2_TestExtensionOrderings3> {
    constructor() {
        super("protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3", [
            { no: 1, name: "my_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestExtensionOrderings2_TestExtensionOrderings3>): TestExtensionOrderings2_TestExtensionOrderings3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtensionOrderings2_TestExtensionOrderings3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtensionOrderings2_TestExtensionOrderings3): TestExtensionOrderings2_TestExtensionOrderings3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string my_string */ 1:
                    message.myString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtensionOrderings2_TestExtensionOrderings3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string my_string = 1; */
        if (message.myString !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.myString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3
 */
export const TestExtensionOrderings2_TestExtensionOrderings3 = new TestExtensionOrderings2_TestExtensionOrderings3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtremeDefaultValues$Type extends MessageType<TestExtremeDefaultValues> {
    constructor() {
        super("protobuf_unittest.TestExtremeDefaultValues", [
            { no: 1, name: "escaped_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "large_uint32", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "large_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "small_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "small_int64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "really_small_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "really_small_int64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "utf8_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "zero_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "one_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "small_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "negative_one_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "negative_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "large_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "small_negative_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "inf_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "neg_inf_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "nan_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "inf_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 18, name: "neg_inf_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "nan_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "cpp_trigraph", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "string_with_zero", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "bytes_with_zero", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 25, name: "string_piece_with_zero", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "cord_with_zero", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "replacement_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestExtremeDefaultValues>): TestExtremeDefaultValues {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtremeDefaultValues>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtremeDefaultValues): TestExtremeDefaultValues {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes escaped_bytes */ 1:
                    message.escapedBytes = reader.bytes();
                    break;
                case /* optional uint32 large_uint32 */ 2:
                    message.largeUint32 = reader.uint32();
                    break;
                case /* optional uint64 large_uint64 */ 3:
                    message.largeUint64 = reader.uint64().toBigInt();
                    break;
                case /* optional int32 small_int32 */ 4:
                    message.smallInt32 = reader.int32();
                    break;
                case /* optional int64 small_int64 */ 5:
                    message.smallInt64 = reader.int64().toBigInt();
                    break;
                case /* optional int32 really_small_int32 */ 21:
                    message.reallySmallInt32 = reader.int32();
                    break;
                case /* optional int64 really_small_int64 */ 22:
                    message.reallySmallInt64 = reader.int64().toBigInt();
                    break;
                case /* optional string utf8_string */ 6:
                    message.utf8String = reader.string();
                    break;
                case /* optional float zero_float */ 7:
                    message.zeroFloat = reader.float();
                    break;
                case /* optional float one_float */ 8:
                    message.oneFloat = reader.float();
                    break;
                case /* optional float small_float */ 9:
                    message.smallFloat = reader.float();
                    break;
                case /* optional float negative_one_float */ 10:
                    message.negativeOneFloat = reader.float();
                    break;
                case /* optional float negative_float */ 11:
                    message.negativeFloat = reader.float();
                    break;
                case /* optional float large_float */ 12:
                    message.largeFloat = reader.float();
                    break;
                case /* optional float small_negative_float */ 13:
                    message.smallNegativeFloat = reader.float();
                    break;
                case /* optional double inf_double */ 14:
                    message.infDouble = reader.double();
                    break;
                case /* optional double neg_inf_double */ 15:
                    message.negInfDouble = reader.double();
                    break;
                case /* optional double nan_double */ 16:
                    message.nanDouble = reader.double();
                    break;
                case /* optional float inf_float */ 17:
                    message.infFloat = reader.float();
                    break;
                case /* optional float neg_inf_float */ 18:
                    message.negInfFloat = reader.float();
                    break;
                case /* optional float nan_float */ 19:
                    message.nanFloat = reader.float();
                    break;
                case /* optional string cpp_trigraph */ 20:
                    message.cppTrigraph = reader.string();
                    break;
                case /* optional string string_with_zero */ 23:
                    message.stringWithZero = reader.string();
                    break;
                case /* optional bytes bytes_with_zero */ 24:
                    message.bytesWithZero = reader.bytes();
                    break;
                case /* optional string string_piece_with_zero */ 25:
                    message.stringPieceWithZero = reader.string();
                    break;
                case /* optional string cord_with_zero */ 26:
                    message.cordWithZero = reader.string();
                    break;
                case /* optional string replacement_string */ 27:
                    message.replacementString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtremeDefaultValues, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes escaped_bytes = 1; */
        if (message.escapedBytes !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.escapedBytes);
        /* optional uint32 large_uint32 = 2; */
        if (message.largeUint32 !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.largeUint32);
        /* optional uint64 large_uint64 = 3; */
        if (message.largeUint64 !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.largeUint64);
        /* optional int32 small_int32 = 4; */
        if (message.smallInt32 !== undefined)
            writer.tag(4, WireType.Varint).int32(message.smallInt32);
        /* optional int64 small_int64 = 5; */
        if (message.smallInt64 !== undefined)
            writer.tag(5, WireType.Varint).int64(message.smallInt64);
        /* optional int32 really_small_int32 = 21; */
        if (message.reallySmallInt32 !== undefined)
            writer.tag(21, WireType.Varint).int32(message.reallySmallInt32);
        /* optional int64 really_small_int64 = 22; */
        if (message.reallySmallInt64 !== undefined)
            writer.tag(22, WireType.Varint).int64(message.reallySmallInt64);
        /* optional string utf8_string = 6; */
        if (message.utf8String !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.utf8String);
        /* optional float zero_float = 7; */
        if (message.zeroFloat !== undefined)
            writer.tag(7, WireType.Bit32).float(message.zeroFloat);
        /* optional float one_float = 8; */
        if (message.oneFloat !== undefined)
            writer.tag(8, WireType.Bit32).float(message.oneFloat);
        /* optional float small_float = 9; */
        if (message.smallFloat !== undefined)
            writer.tag(9, WireType.Bit32).float(message.smallFloat);
        /* optional float negative_one_float = 10; */
        if (message.negativeOneFloat !== undefined)
            writer.tag(10, WireType.Bit32).float(message.negativeOneFloat);
        /* optional float negative_float = 11; */
        if (message.negativeFloat !== undefined)
            writer.tag(11, WireType.Bit32).float(message.negativeFloat);
        /* optional float large_float = 12; */
        if (message.largeFloat !== undefined)
            writer.tag(12, WireType.Bit32).float(message.largeFloat);
        /* optional float small_negative_float = 13; */
        if (message.smallNegativeFloat !== undefined)
            writer.tag(13, WireType.Bit32).float(message.smallNegativeFloat);
        /* optional double inf_double = 14; */
        if (message.infDouble !== undefined)
            writer.tag(14, WireType.Bit64).double(message.infDouble);
        /* optional double neg_inf_double = 15; */
        if (message.negInfDouble !== undefined)
            writer.tag(15, WireType.Bit64).double(message.negInfDouble);
        /* optional double nan_double = 16; */
        if (message.nanDouble !== undefined)
            writer.tag(16, WireType.Bit64).double(message.nanDouble);
        /* optional float inf_float = 17; */
        if (message.infFloat !== undefined)
            writer.tag(17, WireType.Bit32).float(message.infFloat);
        /* optional float neg_inf_float = 18; */
        if (message.negInfFloat !== undefined)
            writer.tag(18, WireType.Bit32).float(message.negInfFloat);
        /* optional float nan_float = 19; */
        if (message.nanFloat !== undefined)
            writer.tag(19, WireType.Bit32).float(message.nanFloat);
        /* optional string cpp_trigraph = 20; */
        if (message.cppTrigraph !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.cppTrigraph);
        /* optional string string_with_zero = 23; */
        if (message.stringWithZero !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.stringWithZero);
        /* optional bytes bytes_with_zero = 24; */
        if (message.bytesWithZero !== undefined)
            writer.tag(24, WireType.LengthDelimited).bytes(message.bytesWithZero);
        /* optional string string_piece_with_zero = 25; */
        if (message.stringPieceWithZero !== undefined)
            writer.tag(25, WireType.LengthDelimited).string(message.stringPieceWithZero);
        /* optional string cord_with_zero = 26; */
        if (message.cordWithZero !== undefined)
            writer.tag(26, WireType.LengthDelimited).string(message.cordWithZero);
        /* optional string replacement_string = 27; */
        if (message.replacementString !== undefined)
            writer.tag(27, WireType.LengthDelimited).string(message.replacementString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestExtremeDefaultValues
 */
export const TestExtremeDefaultValues = new TestExtremeDefaultValues$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseEnumMessage$Type extends MessageType<SparseEnumMessage> {
    constructor() {
        super("protobuf_unittest.SparseEnumMessage", [
            { no: 1, name: "sparse_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.TestSparseEnum", TestSparseEnum] }
        ]);
    }
    create(value?: PartialMessage<SparseEnumMessage>): SparseEnumMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SparseEnumMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SparseEnumMessage): SparseEnumMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestSparseEnum sparse_enum */ 1:
                    message.sparseEnum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SparseEnumMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestSparseEnum sparse_enum = 1; */
        if (message.sparseEnum !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sparseEnum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.SparseEnumMessage
 */
export const SparseEnumMessage = new SparseEnumMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneString$Type extends MessageType<OneString> {
    constructor() {
        super("protobuf_unittest.OneString", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OneString>): OneString {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OneString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneString): OneString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.OneString
 */
export const OneString = new OneString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoreString$Type extends MessageType<MoreString> {
    constructor() {
        super("protobuf_unittest.MoreString", [
            { no: 1, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MoreString>): MoreString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MoreString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoreString): MoreString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string data */ 1:
                    message.data.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoreString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string data = 1; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.data[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.MoreString
 */
export const MoreString = new MoreString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneBytes$Type extends MessageType<OneBytes> {
    constructor() {
        super("protobuf_unittest.OneBytes", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<OneBytes>): OneBytes {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OneBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneBytes): OneBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.OneBytes
 */
export const OneBytes = new OneBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoreBytes$Type extends MessageType<MoreBytes> {
    constructor() {
        super("protobuf_unittest.MoreBytes", [
            { no: 1, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MoreBytes>): MoreBytes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<MoreBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoreBytes): MoreBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes data */ 1:
                    message.data.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoreBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes data = 1; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.MoreBytes
 */
export const MoreBytes = new MoreBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int32Message$Type extends MessageType<Int32Message> {
    constructor() {
        super("protobuf_unittest.Int32Message", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Int32Message>): Int32Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Int32Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int32Message): Int32Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 data */ 1:
                    message.data = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int32Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.Varint).int32(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.Int32Message
 */
export const Int32Message = new Int32Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uint32Message$Type extends MessageType<Uint32Message> {
    constructor() {
        super("protobuf_unittest.Uint32Message", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Uint32Message>): Uint32Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Uint32Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uint32Message): Uint32Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 data */ 1:
                    message.data = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uint32Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.Uint32Message
 */
export const Uint32Message = new Uint32Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int64Message$Type extends MessageType<Int64Message> {
    constructor() {
        super("protobuf_unittest.Int64Message", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Int64Message>): Int64Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Int64Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int64Message): Int64Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 data */ 1:
                    message.data = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int64Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.Varint).int64(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.Int64Message
 */
export const Int64Message = new Int64Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uint64Message$Type extends MessageType<Uint64Message> {
    constructor() {
        super("protobuf_unittest.Uint64Message", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Uint64Message>): Uint64Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Uint64Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uint64Message): Uint64Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 data */ 1:
                    message.data = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uint64Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.Uint64Message
 */
export const Uint64Message = new Uint64Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolMessage$Type extends MessageType<BoolMessage> {
    constructor() {
        super("protobuf_unittest.BoolMessage", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BoolMessage>): BoolMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BoolMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoolMessage): BoolMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool data */ 1:
                    message.data = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoolMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.Varint).bool(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.BoolMessage
 */
export const BoolMessage = new BoolMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof$Type extends MessageType<TestOneof> {
    constructor() {
        super("protobuf_unittest.TestOneof", [
            { no: 1, name: "foo_int", kind: "scalar", oneof: "foo", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "foo_string", kind: "scalar", oneof: "foo", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "foo_message", kind: "message", oneof: "foo", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestOneof>): TestOneof {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.foo = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestOneof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof): TestOneof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 foo_int */ 1:
                    message.foo = {
                        oneofKind: "fooInt",
                        fooInt: reader.int32()
                    };
                    break;
                case /* string foo_string */ 2:
                    message.foo = {
                        oneofKind: "fooString",
                        fooString: reader.string()
                    };
                    break;
                case /* protobuf_unittest.TestAllTypes foo_message */ 3:
                    message.foo = {
                        oneofKind: "fooMessage",
                        fooMessage: TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, (message.foo as any).fooMessage)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 foo_int = 1; */
        if (message.foo.oneofKind === "fooInt")
            writer.tag(1, WireType.Varint).int32(message.foo.fooInt);
        /* string foo_string = 2; */
        if (message.foo.oneofKind === "fooString")
            writer.tag(2, WireType.LengthDelimited).string(message.foo.fooString);
        /* protobuf_unittest.TestAllTypes foo_message = 3; */
        if (message.foo.oneofKind === "fooMessage")
            TestAllTypes.internalBinaryWrite(message.foo.fooMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneof
 */
export const TestOneof = new TestOneof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof_FooGroup$Type extends MessageType<TestOneof_FooGroup> {
    constructor() {
        super("protobuf_unittest.TestOneof.FooGroup", [
            { no: 5, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "b", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestOneof_FooGroup>): TestOneof_FooGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestOneof_FooGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof_FooGroup): TestOneof_FooGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 5:
                    message.a = reader.int32();
                    break;
                case /* optional string b */ 6:
                    message.b = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof_FooGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 5; */
        if (message.a !== undefined)
            writer.tag(5, WireType.Varint).int32(message.a);
        /* optional string b = 6; */
        if (message.b !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.b);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneof.FooGroup
 */
export const TestOneof_FooGroup = new TestOneof_FooGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneofBackwardsCompatible$Type extends MessageType<TestOneofBackwardsCompatible> {
    constructor() {
        super("protobuf_unittest.TestOneofBackwardsCompatible", [
            { no: 1, name: "foo_int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "foo_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "foo_message", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestOneofBackwardsCompatible>): TestOneofBackwardsCompatible {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestOneofBackwardsCompatible>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneofBackwardsCompatible): TestOneofBackwardsCompatible {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 foo_int */ 1:
                    message.fooInt = reader.int32();
                    break;
                case /* optional string foo_string */ 2:
                    message.fooString = reader.string();
                    break;
                case /* optional protobuf_unittest.TestAllTypes foo_message */ 3:
                    message.fooMessage = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.fooMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneofBackwardsCompatible, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 foo_int = 1; */
        if (message.fooInt !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fooInt);
        /* optional string foo_string = 2; */
        if (message.fooString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fooString);
        /* optional protobuf_unittest.TestAllTypes foo_message = 3; */
        if (message.fooMessage)
            TestAllTypes.internalBinaryWrite(message.fooMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneofBackwardsCompatible
 */
export const TestOneofBackwardsCompatible = new TestOneofBackwardsCompatible$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneofBackwardsCompatible_FooGroup$Type extends MessageType<TestOneofBackwardsCompatible_FooGroup> {
    constructor() {
        super("protobuf_unittest.TestOneofBackwardsCompatible.FooGroup", [
            { no: 5, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "b", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestOneofBackwardsCompatible_FooGroup>): TestOneofBackwardsCompatible_FooGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestOneofBackwardsCompatible_FooGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneofBackwardsCompatible_FooGroup): TestOneofBackwardsCompatible_FooGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 5:
                    message.a = reader.int32();
                    break;
                case /* optional string b */ 6:
                    message.b = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneofBackwardsCompatible_FooGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 5; */
        if (message.a !== undefined)
            writer.tag(5, WireType.Varint).int32(message.a);
        /* optional string b = 6; */
        if (message.b !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.b);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneofBackwardsCompatible.FooGroup
 */
export const TestOneofBackwardsCompatible_FooGroup = new TestOneofBackwardsCompatible_FooGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof2$Type extends MessageType<TestOneof2> {
    constructor() {
        super("protobuf_unittest.TestOneof2", [
            { no: 1, name: "foo_int", kind: "scalar", oneof: "foo", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "foo_string", kind: "scalar", oneof: "foo", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "foo_cord", kind: "scalar", oneof: "foo", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "foo_string_piece", kind: "scalar", oneof: "foo", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "foo_bytes", kind: "scalar", oneof: "foo", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "foo_enum", kind: "enum", oneof: "foo", T: () => ["protobuf_unittest.TestOneof2.NestedEnum", TestOneof2_NestedEnum] },
            { no: 7, name: "foo_message", kind: "message", oneof: "foo", T: () => TestOneof2_NestedMessage },
            { no: 11, name: "foo_lazy_message", kind: "message", oneof: "foo", T: () => TestOneof2_NestedMessage },
            { no: 12, name: "bar_int", kind: "scalar", oneof: "bar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "bar_string", kind: "scalar", oneof: "bar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "bar_cord", kind: "scalar", oneof: "bar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "bar_string_piece", kind: "scalar", oneof: "bar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "bar_bytes", kind: "scalar", oneof: "bar", T: 12 /*ScalarType.BYTES*/ },
            { no: 17, name: "bar_enum", kind: "enum", oneof: "bar", T: () => ["protobuf_unittest.TestOneof2.NestedEnum", TestOneof2_NestedEnum] },
            { no: 18, name: "baz_int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "baz_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestOneof2>): TestOneof2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.foo = { oneofKind: undefined };
        message.bar = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestOneof2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof2): TestOneof2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 foo_int */ 1:
                    message.foo = {
                        oneofKind: "fooInt",
                        fooInt: reader.int32()
                    };
                    break;
                case /* string foo_string */ 2:
                    message.foo = {
                        oneofKind: "fooString",
                        fooString: reader.string()
                    };
                    break;
                case /* string foo_cord */ 3:
                    message.foo = {
                        oneofKind: "fooCord",
                        fooCord: reader.string()
                    };
                    break;
                case /* string foo_string_piece */ 4:
                    message.foo = {
                        oneofKind: "fooStringPiece",
                        fooStringPiece: reader.string()
                    };
                    break;
                case /* bytes foo_bytes */ 5:
                    message.foo = {
                        oneofKind: "fooBytes",
                        fooBytes: reader.bytes()
                    };
                    break;
                case /* protobuf_unittest.TestOneof2.NestedEnum foo_enum */ 6:
                    message.foo = {
                        oneofKind: "fooEnum",
                        fooEnum: reader.int32()
                    };
                    break;
                case /* protobuf_unittest.TestOneof2.NestedMessage foo_message */ 7:
                    message.foo = {
                        oneofKind: "fooMessage",
                        fooMessage: TestOneof2_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, (message.foo as any).fooMessage)
                    };
                    break;
                case /* protobuf_unittest.TestOneof2.NestedMessage foo_lazy_message */ 11:
                    message.foo = {
                        oneofKind: "fooLazyMessage",
                        fooLazyMessage: TestOneof2_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, (message.foo as any).fooLazyMessage)
                    };
                    break;
                case /* int32 bar_int */ 12:
                    message.bar = {
                        oneofKind: "barInt",
                        barInt: reader.int32()
                    };
                    break;
                case /* string bar_string */ 13:
                    message.bar = {
                        oneofKind: "barString",
                        barString: reader.string()
                    };
                    break;
                case /* string bar_cord */ 14:
                    message.bar = {
                        oneofKind: "barCord",
                        barCord: reader.string()
                    };
                    break;
                case /* string bar_string_piece */ 15:
                    message.bar = {
                        oneofKind: "barStringPiece",
                        barStringPiece: reader.string()
                    };
                    break;
                case /* bytes bar_bytes */ 16:
                    message.bar = {
                        oneofKind: "barBytes",
                        barBytes: reader.bytes()
                    };
                    break;
                case /* protobuf_unittest.TestOneof2.NestedEnum bar_enum */ 17:
                    message.bar = {
                        oneofKind: "barEnum",
                        barEnum: reader.int32()
                    };
                    break;
                case /* optional int32 baz_int */ 18:
                    message.bazInt = reader.int32();
                    break;
                case /* optional string baz_string */ 19:
                    message.bazString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 foo_int = 1; */
        if (message.foo.oneofKind === "fooInt")
            writer.tag(1, WireType.Varint).int32(message.foo.fooInt);
        /* string foo_string = 2; */
        if (message.foo.oneofKind === "fooString")
            writer.tag(2, WireType.LengthDelimited).string(message.foo.fooString);
        /* string foo_cord = 3; */
        if (message.foo.oneofKind === "fooCord")
            writer.tag(3, WireType.LengthDelimited).string(message.foo.fooCord);
        /* string foo_string_piece = 4; */
        if (message.foo.oneofKind === "fooStringPiece")
            writer.tag(4, WireType.LengthDelimited).string(message.foo.fooStringPiece);
        /* bytes foo_bytes = 5; */
        if (message.foo.oneofKind === "fooBytes")
            writer.tag(5, WireType.LengthDelimited).bytes(message.foo.fooBytes);
        /* protobuf_unittest.TestOneof2.NestedEnum foo_enum = 6; */
        if (message.foo.oneofKind === "fooEnum")
            writer.tag(6, WireType.Varint).int32(message.foo.fooEnum);
        /* protobuf_unittest.TestOneof2.NestedMessage foo_message = 7; */
        if (message.foo.oneofKind === "fooMessage")
            TestOneof2_NestedMessage.internalBinaryWrite(message.foo.fooMessage, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* protobuf_unittest.TestOneof2.NestedMessage foo_lazy_message = 11; */
        if (message.foo.oneofKind === "fooLazyMessage")
            TestOneof2_NestedMessage.internalBinaryWrite(message.foo.fooLazyMessage, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* int32 bar_int = 12; */
        if (message.bar.oneofKind === "barInt")
            writer.tag(12, WireType.Varint).int32(message.bar.barInt);
        /* string bar_string = 13; */
        if (message.bar.oneofKind === "barString")
            writer.tag(13, WireType.LengthDelimited).string(message.bar.barString);
        /* string bar_cord = 14; */
        if (message.bar.oneofKind === "barCord")
            writer.tag(14, WireType.LengthDelimited).string(message.bar.barCord);
        /* string bar_string_piece = 15; */
        if (message.bar.oneofKind === "barStringPiece")
            writer.tag(15, WireType.LengthDelimited).string(message.bar.barStringPiece);
        /* bytes bar_bytes = 16; */
        if (message.bar.oneofKind === "barBytes")
            writer.tag(16, WireType.LengthDelimited).bytes(message.bar.barBytes);
        /* protobuf_unittest.TestOneof2.NestedEnum bar_enum = 17; */
        if (message.bar.oneofKind === "barEnum")
            writer.tag(17, WireType.Varint).int32(message.bar.barEnum);
        /* optional int32 baz_int = 18; */
        if (message.bazInt !== undefined)
            writer.tag(18, WireType.Varint).int32(message.bazInt);
        /* optional string baz_string = 19; */
        if (message.bazString !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.bazString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneof2
 */
export const TestOneof2 = new TestOneof2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof2_FooGroup$Type extends MessageType<TestOneof2_FooGroup> {
    constructor() {
        super("protobuf_unittest.TestOneof2.FooGroup", [
            { no: 9, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "b", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestOneof2_FooGroup>): TestOneof2_FooGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestOneof2_FooGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof2_FooGroup): TestOneof2_FooGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 a */ 9:
                    message.a = reader.int32();
                    break;
                case /* optional string b */ 10:
                    message.b = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof2_FooGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 a = 9; */
        if (message.a !== undefined)
            writer.tag(9, WireType.Varint).int32(message.a);
        /* optional string b = 10; */
        if (message.b !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.b);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneof2.FooGroup
 */
export const TestOneof2_FooGroup = new TestOneof2_FooGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof2_NestedMessage$Type extends MessageType<TestOneof2_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestOneof2.NestedMessage", [
            { no: 1, name: "qux_int", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "corge_int", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestOneof2_NestedMessage>): TestOneof2_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.corgeInt = [];
        if (value !== undefined)
            reflectionMergePartial<TestOneof2_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof2_NestedMessage): TestOneof2_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 qux_int */ 1:
                    message.quxInt = reader.int64().toBigInt();
                    break;
                case /* repeated int32 corge_int */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.corgeInt.push(reader.int32());
                    else
                        message.corgeInt.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof2_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 qux_int = 1; */
        if (message.quxInt !== undefined)
            writer.tag(1, WireType.Varint).int64(message.quxInt);
        /* repeated int32 corge_int = 2; */
        for (let i = 0; i < message.corgeInt.length; i++)
            writer.tag(2, WireType.Varint).int32(message.corgeInt[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestOneof2.NestedMessage
 */
export const TestOneof2_NestedMessage = new TestOneof2_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredOneof$Type extends MessageType<TestRequiredOneof> {
    constructor() {
        super("protobuf_unittest.TestRequiredOneof", [
            { no: 1, name: "foo_int", kind: "scalar", oneof: "foo", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "foo_string", kind: "scalar", oneof: "foo", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "foo_message", kind: "message", oneof: "foo", T: () => TestRequiredOneof_NestedMessage }
        ]);
    }
    create(value?: PartialMessage<TestRequiredOneof>): TestRequiredOneof {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.foo = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestRequiredOneof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredOneof): TestRequiredOneof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 foo_int */ 1:
                    message.foo = {
                        oneofKind: "fooInt",
                        fooInt: reader.int32()
                    };
                    break;
                case /* string foo_string */ 2:
                    message.foo = {
                        oneofKind: "fooString",
                        fooString: reader.string()
                    };
                    break;
                case /* protobuf_unittest.TestRequiredOneof.NestedMessage foo_message */ 3:
                    message.foo = {
                        oneofKind: "fooMessage",
                        fooMessage: TestRequiredOneof_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, (message.foo as any).fooMessage)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequiredOneof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 foo_int = 1; */
        if (message.foo.oneofKind === "fooInt")
            writer.tag(1, WireType.Varint).int32(message.foo.fooInt);
        /* string foo_string = 2; */
        if (message.foo.oneofKind === "fooString")
            writer.tag(2, WireType.LengthDelimited).string(message.foo.fooString);
        /* protobuf_unittest.TestRequiredOneof.NestedMessage foo_message = 3; */
        if (message.foo.oneofKind === "fooMessage")
            TestRequiredOneof_NestedMessage.internalBinaryWrite(message.foo.fooMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredOneof
 */
export const TestRequiredOneof = new TestRequiredOneof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredOneof_NestedMessage$Type extends MessageType<TestRequiredOneof_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestRequiredOneof.NestedMessage", [
            { no: 1, name: "required_double", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TestRequiredOneof_NestedMessage>): TestRequiredOneof_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiredDouble = 0;
        if (value !== undefined)
            reflectionMergePartial<TestRequiredOneof_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredOneof_NestedMessage): TestRequiredOneof_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double required_double */ 1:
                    message.requiredDouble = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequiredOneof_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double required_double = 1; */
        if (message.requiredDouble !== 0)
            writer.tag(1, WireType.Bit64).double(message.requiredDouble);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredOneof.NestedMessage
 */
export const TestRequiredOneof_NestedMessage = new TestRequiredOneof_NestedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestPackedTypes$Type extends MessageType<TestPackedTypes> {
    constructor() {
        super("protobuf_unittest.TestPackedTypes", [
            { no: 90, name: "packed_int32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 91, name: "packed_int64", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 92, name: "packed_uint32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 93, name: "packed_uint64", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 94, name: "packed_sint32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 95, name: "packed_sint64", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 96, name: "packed_fixed32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 97, name: "packed_fixed64", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 98, name: "packed_sfixed32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 99, name: "packed_sfixed64", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 100, name: "packed_float", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 101, name: "packed_double", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 102, name: "packed_bool", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 103, name: "packed_enum", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] }
        ]);
    }
    create(value?: PartialMessage<TestPackedTypes>): TestPackedTypes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packedInt32 = [];
        message.packedInt64 = [];
        message.packedUint32 = [];
        message.packedUint64 = [];
        message.packedSint32 = [];
        message.packedSint64 = [];
        message.packedFixed32 = [];
        message.packedFixed64 = [];
        message.packedSfixed32 = [];
        message.packedSfixed64 = [];
        message.packedFloat = [];
        message.packedDouble = [];
        message.packedBool = [];
        message.packedEnum = [];
        if (value !== undefined)
            reflectionMergePartial<TestPackedTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestPackedTypes): TestPackedTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 packed_int32 = 90 [packed = true];*/ 90:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedInt32.push(reader.int32());
                    else
                        message.packedInt32.push(reader.int32());
                    break;
                case /* repeated int64 packed_int64 = 91 [packed = true];*/ 91:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedInt64.push(reader.int64().toBigInt());
                    else
                        message.packedInt64.push(reader.int64().toBigInt());
                    break;
                case /* repeated uint32 packed_uint32 = 92 [packed = true];*/ 92:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedUint32.push(reader.uint32());
                    else
                        message.packedUint32.push(reader.uint32());
                    break;
                case /* repeated uint64 packed_uint64 = 93 [packed = true];*/ 93:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedUint64.push(reader.uint64().toBigInt());
                    else
                        message.packedUint64.push(reader.uint64().toBigInt());
                    break;
                case /* repeated sint32 packed_sint32 = 94 [packed = true];*/ 94:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedSint32.push(reader.sint32());
                    else
                        message.packedSint32.push(reader.sint32());
                    break;
                case /* repeated sint64 packed_sint64 = 95 [packed = true];*/ 95:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedSint64.push(reader.sint64().toBigInt());
                    else
                        message.packedSint64.push(reader.sint64().toBigInt());
                    break;
                case /* repeated fixed32 packed_fixed32 = 96 [packed = true];*/ 96:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedFixed32.push(reader.fixed32());
                    else
                        message.packedFixed32.push(reader.fixed32());
                    break;
                case /* repeated fixed64 packed_fixed64 = 97 [packed = true];*/ 97:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedFixed64.push(reader.fixed64().toBigInt());
                    else
                        message.packedFixed64.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated sfixed32 packed_sfixed32 = 98 [packed = true];*/ 98:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedSfixed32.push(reader.sfixed32());
                    else
                        message.packedSfixed32.push(reader.sfixed32());
                    break;
                case /* repeated sfixed64 packed_sfixed64 = 99 [packed = true];*/ 99:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedSfixed64.push(reader.sfixed64().toBigInt());
                    else
                        message.packedSfixed64.push(reader.sfixed64().toBigInt());
                    break;
                case /* repeated float packed_float = 100 [packed = true];*/ 100:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedFloat.push(reader.float());
                    else
                        message.packedFloat.push(reader.float());
                    break;
                case /* repeated double packed_double = 101 [packed = true];*/ 101:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedDouble.push(reader.double());
                    else
                        message.packedDouble.push(reader.double());
                    break;
                case /* repeated bool packed_bool = 102 [packed = true];*/ 102:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedBool.push(reader.bool());
                    else
                        message.packedBool.push(reader.bool());
                    break;
                case /* repeated protobuf_unittest.ForeignEnum packed_enum = 103 [packed = true];*/ 103:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedEnum.push(reader.int32());
                    else
                        message.packedEnum.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestPackedTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 packed_int32 = 90 [packed = true]; */
        if (message.packedInt32.length) {
            writer.tag(90, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedInt32.length; i++)
                writer.int32(message.packedInt32[i]);
            writer.join();
        }
        /* repeated int64 packed_int64 = 91 [packed = true]; */
        if (message.packedInt64.length) {
            writer.tag(91, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedInt64.length; i++)
                writer.int64(message.packedInt64[i]);
            writer.join();
        }
        /* repeated uint32 packed_uint32 = 92 [packed = true]; */
        if (message.packedUint32.length) {
            writer.tag(92, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedUint32.length; i++)
                writer.uint32(message.packedUint32[i]);
            writer.join();
        }
        /* repeated uint64 packed_uint64 = 93 [packed = true]; */
        if (message.packedUint64.length) {
            writer.tag(93, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedUint64.length; i++)
                writer.uint64(message.packedUint64[i]);
            writer.join();
        }
        /* repeated sint32 packed_sint32 = 94 [packed = true]; */
        if (message.packedSint32.length) {
            writer.tag(94, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedSint32.length; i++)
                writer.sint32(message.packedSint32[i]);
            writer.join();
        }
        /* repeated sint64 packed_sint64 = 95 [packed = true]; */
        if (message.packedSint64.length) {
            writer.tag(95, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedSint64.length; i++)
                writer.sint64(message.packedSint64[i]);
            writer.join();
        }
        /* repeated fixed32 packed_fixed32 = 96 [packed = true]; */
        if (message.packedFixed32.length) {
            writer.tag(96, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedFixed32.length; i++)
                writer.fixed32(message.packedFixed32[i]);
            writer.join();
        }
        /* repeated fixed64 packed_fixed64 = 97 [packed = true]; */
        if (message.packedFixed64.length) {
            writer.tag(97, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedFixed64.length; i++)
                writer.fixed64(message.packedFixed64[i]);
            writer.join();
        }
        /* repeated sfixed32 packed_sfixed32 = 98 [packed = true]; */
        if (message.packedSfixed32.length) {
            writer.tag(98, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedSfixed32.length; i++)
                writer.sfixed32(message.packedSfixed32[i]);
            writer.join();
        }
        /* repeated sfixed64 packed_sfixed64 = 99 [packed = true]; */
        if (message.packedSfixed64.length) {
            writer.tag(99, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedSfixed64.length; i++)
                writer.sfixed64(message.packedSfixed64[i]);
            writer.join();
        }
        /* repeated float packed_float = 100 [packed = true]; */
        if (message.packedFloat.length) {
            writer.tag(100, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedFloat.length; i++)
                writer.float(message.packedFloat[i]);
            writer.join();
        }
        /* repeated double packed_double = 101 [packed = true]; */
        if (message.packedDouble.length) {
            writer.tag(101, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedDouble.length; i++)
                writer.double(message.packedDouble[i]);
            writer.join();
        }
        /* repeated bool packed_bool = 102 [packed = true]; */
        if (message.packedBool.length) {
            writer.tag(102, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedBool.length; i++)
                writer.bool(message.packedBool[i]);
            writer.join();
        }
        /* repeated protobuf_unittest.ForeignEnum packed_enum = 103 [packed = true]; */
        if (message.packedEnum.length) {
            writer.tag(103, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedEnum.length; i++)
                writer.int32(message.packedEnum[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestPackedTypes
 */
export const TestPackedTypes = new TestPackedTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestUnpackedTypes$Type extends MessageType<TestUnpackedTypes> {
    constructor() {
        super("protobuf_unittest.TestUnpackedTypes", [
            { no: 90, name: "unpacked_int32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 91, name: "unpacked_int64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 92, name: "unpacked_uint32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 93, name: "unpacked_uint64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 94, name: "unpacked_sint32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 95, name: "unpacked_sint64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 96, name: "unpacked_fixed32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 97, name: "unpacked_fixed64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 98, name: "unpacked_sfixed32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 99, name: "unpacked_sfixed64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 100, name: "unpacked_float", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 101, name: "unpacked_double", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 102, name: "unpacked_bool", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 103, name: "unpacked_enum", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] }
        ]);
    }
    create(value?: PartialMessage<TestUnpackedTypes>): TestUnpackedTypes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unpackedInt32 = [];
        message.unpackedInt64 = [];
        message.unpackedUint32 = [];
        message.unpackedUint64 = [];
        message.unpackedSint32 = [];
        message.unpackedSint64 = [];
        message.unpackedFixed32 = [];
        message.unpackedFixed64 = [];
        message.unpackedSfixed32 = [];
        message.unpackedSfixed64 = [];
        message.unpackedFloat = [];
        message.unpackedDouble = [];
        message.unpackedBool = [];
        message.unpackedEnum = [];
        if (value !== undefined)
            reflectionMergePartial<TestUnpackedTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestUnpackedTypes): TestUnpackedTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 unpacked_int32 = 90 [packed = false];*/ 90:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedInt32.push(reader.int32());
                    else
                        message.unpackedInt32.push(reader.int32());
                    break;
                case /* repeated int64 unpacked_int64 = 91 [packed = false];*/ 91:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedInt64.push(reader.int64().toBigInt());
                    else
                        message.unpackedInt64.push(reader.int64().toBigInt());
                    break;
                case /* repeated uint32 unpacked_uint32 = 92 [packed = false];*/ 92:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedUint32.push(reader.uint32());
                    else
                        message.unpackedUint32.push(reader.uint32());
                    break;
                case /* repeated uint64 unpacked_uint64 = 93 [packed = false];*/ 93:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedUint64.push(reader.uint64().toBigInt());
                    else
                        message.unpackedUint64.push(reader.uint64().toBigInt());
                    break;
                case /* repeated sint32 unpacked_sint32 = 94 [packed = false];*/ 94:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedSint32.push(reader.sint32());
                    else
                        message.unpackedSint32.push(reader.sint32());
                    break;
                case /* repeated sint64 unpacked_sint64 = 95 [packed = false];*/ 95:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedSint64.push(reader.sint64().toBigInt());
                    else
                        message.unpackedSint64.push(reader.sint64().toBigInt());
                    break;
                case /* repeated fixed32 unpacked_fixed32 = 96 [packed = false];*/ 96:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedFixed32.push(reader.fixed32());
                    else
                        message.unpackedFixed32.push(reader.fixed32());
                    break;
                case /* repeated fixed64 unpacked_fixed64 = 97 [packed = false];*/ 97:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedFixed64.push(reader.fixed64().toBigInt());
                    else
                        message.unpackedFixed64.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated sfixed32 unpacked_sfixed32 = 98 [packed = false];*/ 98:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedSfixed32.push(reader.sfixed32());
                    else
                        message.unpackedSfixed32.push(reader.sfixed32());
                    break;
                case /* repeated sfixed64 unpacked_sfixed64 = 99 [packed = false];*/ 99:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedSfixed64.push(reader.sfixed64().toBigInt());
                    else
                        message.unpackedSfixed64.push(reader.sfixed64().toBigInt());
                    break;
                case /* repeated float unpacked_float = 100 [packed = false];*/ 100:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedFloat.push(reader.float());
                    else
                        message.unpackedFloat.push(reader.float());
                    break;
                case /* repeated double unpacked_double = 101 [packed = false];*/ 101:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedDouble.push(reader.double());
                    else
                        message.unpackedDouble.push(reader.double());
                    break;
                case /* repeated bool unpacked_bool = 102 [packed = false];*/ 102:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedBool.push(reader.bool());
                    else
                        message.unpackedBool.push(reader.bool());
                    break;
                case /* repeated protobuf_unittest.ForeignEnum unpacked_enum = 103 [packed = false];*/ 103:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unpackedEnum.push(reader.int32());
                    else
                        message.unpackedEnum.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestUnpackedTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 unpacked_int32 = 90 [packed = false]; */
        for (let i = 0; i < message.unpackedInt32.length; i++)
            writer.tag(90, WireType.Varint).int32(message.unpackedInt32[i]);
        /* repeated int64 unpacked_int64 = 91 [packed = false]; */
        for (let i = 0; i < message.unpackedInt64.length; i++)
            writer.tag(91, WireType.Varint).int64(message.unpackedInt64[i]);
        /* repeated uint32 unpacked_uint32 = 92 [packed = false]; */
        for (let i = 0; i < message.unpackedUint32.length; i++)
            writer.tag(92, WireType.Varint).uint32(message.unpackedUint32[i]);
        /* repeated uint64 unpacked_uint64 = 93 [packed = false]; */
        for (let i = 0; i < message.unpackedUint64.length; i++)
            writer.tag(93, WireType.Varint).uint64(message.unpackedUint64[i]);
        /* repeated sint32 unpacked_sint32 = 94 [packed = false]; */
        for (let i = 0; i < message.unpackedSint32.length; i++)
            writer.tag(94, WireType.Varint).sint32(message.unpackedSint32[i]);
        /* repeated sint64 unpacked_sint64 = 95 [packed = false]; */
        for (let i = 0; i < message.unpackedSint64.length; i++)
            writer.tag(95, WireType.Varint).sint64(message.unpackedSint64[i]);
        /* repeated fixed32 unpacked_fixed32 = 96 [packed = false]; */
        for (let i = 0; i < message.unpackedFixed32.length; i++)
            writer.tag(96, WireType.Bit32).fixed32(message.unpackedFixed32[i]);
        /* repeated fixed64 unpacked_fixed64 = 97 [packed = false]; */
        for (let i = 0; i < message.unpackedFixed64.length; i++)
            writer.tag(97, WireType.Bit64).fixed64(message.unpackedFixed64[i]);
        /* repeated sfixed32 unpacked_sfixed32 = 98 [packed = false]; */
        for (let i = 0; i < message.unpackedSfixed32.length; i++)
            writer.tag(98, WireType.Bit32).sfixed32(message.unpackedSfixed32[i]);
        /* repeated sfixed64 unpacked_sfixed64 = 99 [packed = false]; */
        for (let i = 0; i < message.unpackedSfixed64.length; i++)
            writer.tag(99, WireType.Bit64).sfixed64(message.unpackedSfixed64[i]);
        /* repeated float unpacked_float = 100 [packed = false]; */
        for (let i = 0; i < message.unpackedFloat.length; i++)
            writer.tag(100, WireType.Bit32).float(message.unpackedFloat[i]);
        /* repeated double unpacked_double = 101 [packed = false]; */
        for (let i = 0; i < message.unpackedDouble.length; i++)
            writer.tag(101, WireType.Bit64).double(message.unpackedDouble[i]);
        /* repeated bool unpacked_bool = 102 [packed = false]; */
        for (let i = 0; i < message.unpackedBool.length; i++)
            writer.tag(102, WireType.Varint).bool(message.unpackedBool[i]);
        /* repeated protobuf_unittest.ForeignEnum unpacked_enum = 103 [packed = false]; */
        for (let i = 0; i < message.unpackedEnum.length; i++)
            writer.tag(103, WireType.Varint).int32(message.unpackedEnum[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestUnpackedTypes
 */
export const TestUnpackedTypes = new TestUnpackedTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestPackedExtensions$Type extends MessageType<TestPackedExtensions> {
    constructor() {
        super("protobuf_unittest.TestPackedExtensions", []);
    }
    create(value?: PartialMessage<TestPackedExtensions>): TestPackedExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestPackedExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestPackedExtensions): TestPackedExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestPackedExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestPackedExtensions
 */
export const TestPackedExtensions = new TestPackedExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestUnpackedExtensions$Type extends MessageType<TestUnpackedExtensions> {
    constructor() {
        super("protobuf_unittest.TestUnpackedExtensions", []);
    }
    create(value?: PartialMessage<TestUnpackedExtensions>): TestUnpackedExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestUnpackedExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestUnpackedExtensions): TestUnpackedExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestUnpackedExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestUnpackedExtensions
 */
export const TestUnpackedExtensions = new TestUnpackedExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDynamicExtensions$Type extends MessageType<TestDynamicExtensions> {
    constructor() {
        super("protobuf_unittest.TestDynamicExtensions", [
            { no: 2000, name: "scalar_extension", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2001, name: "enum_extension", kind: "enum", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 2002, name: "dynamic_enum_extension", kind: "enum", opt: true, T: () => ["protobuf_unittest.TestDynamicExtensions.DynamicEnumType", TestDynamicExtensions_DynamicEnumType] },
            { no: 2003, name: "message_extension", kind: "message", T: () => ForeignMessage },
            { no: 2004, name: "dynamic_message_extension", kind: "message", T: () => TestDynamicExtensions_DynamicMessageType },
            { no: 2005, name: "repeated_extension", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2006, name: "packed_extension", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDynamicExtensions>): TestDynamicExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedExtension = [];
        message.packedExtension = [];
        if (value !== undefined)
            reflectionMergePartial<TestDynamicExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDynamicExtensions): TestDynamicExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 scalar_extension */ 2000:
                    message.scalarExtension = reader.fixed32();
                    break;
                case /* optional protobuf_unittest.ForeignEnum enum_extension */ 2001:
                    message.enumExtension = reader.int32();
                    break;
                case /* optional protobuf_unittest.TestDynamicExtensions.DynamicEnumType dynamic_enum_extension */ 2002:
                    message.dynamicEnumExtension = reader.int32();
                    break;
                case /* optional protobuf_unittest.ForeignMessage message_extension */ 2003:
                    message.messageExtension = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options, message.messageExtension);
                    break;
                case /* optional protobuf_unittest.TestDynamicExtensions.DynamicMessageType dynamic_message_extension */ 2004:
                    message.dynamicMessageExtension = TestDynamicExtensions_DynamicMessageType.internalBinaryRead(reader, reader.uint32(), options, message.dynamicMessageExtension);
                    break;
                case /* repeated string repeated_extension */ 2005:
                    message.repeatedExtension.push(reader.string());
                    break;
                case /* repeated sint32 packed_extension = 2006 [packed = true];*/ 2006:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedExtension.push(reader.sint32());
                    else
                        message.packedExtension.push(reader.sint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDynamicExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 scalar_extension = 2000; */
        if (message.scalarExtension !== undefined)
            writer.tag(2000, WireType.Bit32).fixed32(message.scalarExtension);
        /* optional protobuf_unittest.ForeignEnum enum_extension = 2001; */
        if (message.enumExtension !== undefined)
            writer.tag(2001, WireType.Varint).int32(message.enumExtension);
        /* optional protobuf_unittest.TestDynamicExtensions.DynamicEnumType dynamic_enum_extension = 2002; */
        if (message.dynamicEnumExtension !== undefined)
            writer.tag(2002, WireType.Varint).int32(message.dynamicEnumExtension);
        /* optional protobuf_unittest.ForeignMessage message_extension = 2003; */
        if (message.messageExtension)
            ForeignMessage.internalBinaryWrite(message.messageExtension, writer.tag(2003, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestDynamicExtensions.DynamicMessageType dynamic_message_extension = 2004; */
        if (message.dynamicMessageExtension)
            TestDynamicExtensions_DynamicMessageType.internalBinaryWrite(message.dynamicMessageExtension, writer.tag(2004, WireType.LengthDelimited).fork(), options).join();
        /* repeated string repeated_extension = 2005; */
        for (let i = 0; i < message.repeatedExtension.length; i++)
            writer.tag(2005, WireType.LengthDelimited).string(message.repeatedExtension[i]);
        /* repeated sint32 packed_extension = 2006 [packed = true]; */
        if (message.packedExtension.length) {
            writer.tag(2006, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedExtension.length; i++)
                writer.sint32(message.packedExtension[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDynamicExtensions
 */
export const TestDynamicExtensions = new TestDynamicExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDynamicExtensions_DynamicMessageType$Type extends MessageType<TestDynamicExtensions_DynamicMessageType> {
    constructor() {
        super("protobuf_unittest.TestDynamicExtensions.DynamicMessageType", [
            { no: 2100, name: "dynamic_field", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDynamicExtensions_DynamicMessageType>): TestDynamicExtensions_DynamicMessageType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestDynamicExtensions_DynamicMessageType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDynamicExtensions_DynamicMessageType): TestDynamicExtensions_DynamicMessageType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dynamic_field */ 2100:
                    message.dynamicField = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDynamicExtensions_DynamicMessageType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dynamic_field = 2100; */
        if (message.dynamicField !== undefined)
            writer.tag(2100, WireType.Varint).int32(message.dynamicField);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestDynamicExtensions.DynamicMessageType
 */
export const TestDynamicExtensions_DynamicMessageType = new TestDynamicExtensions_DynamicMessageType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRepeatedScalarDifferentTagSizes$Type extends MessageType<TestRepeatedScalarDifferentTagSizes> {
    constructor() {
        super("protobuf_unittest.TestRepeatedScalarDifferentTagSizes", [
            { no: 12, name: "repeated_fixed32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 13, name: "repeated_int32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2046, name: "repeated_fixed64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2047, name: "repeated_int64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 262142, name: "repeated_float", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 262143, name: "repeated_uint64", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TestRepeatedScalarDifferentTagSizes>): TestRepeatedScalarDifferentTagSizes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedFixed32 = [];
        message.repeatedInt32 = [];
        message.repeatedFixed64 = [];
        message.repeatedInt64 = [];
        message.repeatedFloat = [];
        message.repeatedUint64 = [];
        if (value !== undefined)
            reflectionMergePartial<TestRepeatedScalarDifferentTagSizes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRepeatedScalarDifferentTagSizes): TestRepeatedScalarDifferentTagSizes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 repeated_fixed32 */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFixed32.push(reader.fixed32());
                    else
                        message.repeatedFixed32.push(reader.fixed32());
                    break;
                case /* repeated int32 repeated_int32 */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt32.push(reader.int32());
                    else
                        message.repeatedInt32.push(reader.int32());
                    break;
                case /* repeated fixed64 repeated_fixed64 */ 2046:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFixed64.push(reader.fixed64().toBigInt());
                    else
                        message.repeatedFixed64.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated int64 repeated_int64 */ 2047:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt64.push(reader.int64().toBigInt());
                    else
                        message.repeatedInt64.push(reader.int64().toBigInt());
                    break;
                case /* repeated float repeated_float */ 262142:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFloat.push(reader.float());
                    else
                        message.repeatedFloat.push(reader.float());
                    break;
                case /* repeated uint64 repeated_uint64 */ 262143:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedUint64.push(reader.uint64().toBigInt());
                    else
                        message.repeatedUint64.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRepeatedScalarDifferentTagSizes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 repeated_fixed32 = 12; */
        for (let i = 0; i < message.repeatedFixed32.length; i++)
            writer.tag(12, WireType.Bit32).fixed32(message.repeatedFixed32[i]);
        /* repeated int32 repeated_int32 = 13; */
        for (let i = 0; i < message.repeatedInt32.length; i++)
            writer.tag(13, WireType.Varint).int32(message.repeatedInt32[i]);
        /* repeated fixed64 repeated_fixed64 = 2046; */
        for (let i = 0; i < message.repeatedFixed64.length; i++)
            writer.tag(2046, WireType.Bit64).fixed64(message.repeatedFixed64[i]);
        /* repeated int64 repeated_int64 = 2047; */
        for (let i = 0; i < message.repeatedInt64.length; i++)
            writer.tag(2047, WireType.Varint).int64(message.repeatedInt64[i]);
        /* repeated float repeated_float = 262142; */
        for (let i = 0; i < message.repeatedFloat.length; i++)
            writer.tag(262142, WireType.Bit32).float(message.repeatedFloat[i]);
        /* repeated uint64 repeated_uint64 = 262143; */
        for (let i = 0; i < message.repeatedUint64.length; i++)
            writer.tag(262143, WireType.Varint).uint64(message.repeatedUint64[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRepeatedScalarDifferentTagSizes
 */
export const TestRepeatedScalarDifferentTagSizes = new TestRepeatedScalarDifferentTagSizes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge$Type extends MessageType<TestParsingMerge> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge", [
            { no: 1, name: "required_all_types", kind: "message", T: () => TestAllTypes },
            { no: 2, name: "optional_all_types", kind: "message", T: () => TestAllTypes },
            { no: 3, name: "repeated_all_types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge>): TestParsingMerge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedAllTypes = [];
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge): TestParsingMerge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protobuf_unittest.TestAllTypes required_all_types */ 1:
                    message.requiredAllTypes = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.requiredAllTypes);
                    break;
                case /* optional protobuf_unittest.TestAllTypes optional_all_types */ 2:
                    message.optionalAllTypes = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.optionalAllTypes);
                    break;
                case /* repeated protobuf_unittest.TestAllTypes repeated_all_types */ 3:
                    message.repeatedAllTypes.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protobuf_unittest.TestAllTypes required_all_types = 1; */
        if (message.requiredAllTypes)
            TestAllTypes.internalBinaryWrite(message.requiredAllTypes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestAllTypes optional_all_types = 2; */
        if (message.optionalAllTypes)
            TestAllTypes.internalBinaryWrite(message.optionalAllTypes, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes repeated_all_types = 3; */
        for (let i = 0; i < message.repeatedAllTypes.length; i++)
            TestAllTypes.internalBinaryWrite(message.repeatedAllTypes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge
 */
export const TestParsingMerge = new TestParsingMerge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge_RepeatedFieldsGenerator$Type extends MessageType<TestParsingMerge_RepeatedFieldsGenerator> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator", [
            { no: 1, name: "field1", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes },
            { no: 2, name: "field2", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes },
            { no: 3, name: "field3", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes },
            { no: 1000, name: "ext1", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes },
            { no: 1001, name: "ext2", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator>): TestParsingMerge_RepeatedFieldsGenerator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field1 = [];
        message.field2 = [];
        message.field3 = [];
        message.ext1 = [];
        message.ext2 = [];
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge_RepeatedFieldsGenerator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge_RepeatedFieldsGenerator): TestParsingMerge_RepeatedFieldsGenerator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated protobuf_unittest.TestAllTypes field1 */ 1:
                    message.field1.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.TestAllTypes field2 */ 2:
                    message.field2.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.TestAllTypes field3 */ 3:
                    message.field3.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.TestAllTypes ext1 */ 1000:
                    message.ext1.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protobuf_unittest.TestAllTypes ext2 */ 1001:
                    message.ext2.push(TestAllTypes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge_RepeatedFieldsGenerator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated protobuf_unittest.TestAllTypes field1 = 1; */
        for (let i = 0; i < message.field1.length; i++)
            TestAllTypes.internalBinaryWrite(message.field1[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes field2 = 2; */
        for (let i = 0; i < message.field2.length; i++)
            TestAllTypes.internalBinaryWrite(message.field2[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes field3 = 3; */
        for (let i = 0; i < message.field3.length; i++)
            TestAllTypes.internalBinaryWrite(message.field3[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes ext1 = 1000; */
        for (let i = 0; i < message.ext1.length; i++)
            TestAllTypes.internalBinaryWrite(message.ext1[i], writer.tag(1000, WireType.LengthDelimited).fork(), options).join();
        /* repeated protobuf_unittest.TestAllTypes ext2 = 1001; */
        for (let i = 0; i < message.ext2.length; i++)
            TestAllTypes.internalBinaryWrite(message.ext2[i], writer.tag(1001, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator
 */
export const TestParsingMerge_RepeatedFieldsGenerator = new TestParsingMerge_RepeatedFieldsGenerator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge_RepeatedFieldsGenerator_Group1$Type extends MessageType<TestParsingMerge_RepeatedFieldsGenerator_Group1> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1", [
            { no: 11, name: "field1", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator_Group1>): TestParsingMerge_RepeatedFieldsGenerator_Group1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge_RepeatedFieldsGenerator_Group1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge_RepeatedFieldsGenerator_Group1): TestParsingMerge_RepeatedFieldsGenerator_Group1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes field1 */ 11:
                    message.field1 = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.field1);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge_RepeatedFieldsGenerator_Group1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes field1 = 11; */
        if (message.field1)
            TestAllTypes.internalBinaryWrite(message.field1, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1
 */
export const TestParsingMerge_RepeatedFieldsGenerator_Group1 = new TestParsingMerge_RepeatedFieldsGenerator_Group1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge_RepeatedFieldsGenerator_Group2$Type extends MessageType<TestParsingMerge_RepeatedFieldsGenerator_Group2> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2", [
            { no: 21, name: "field1", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator_Group2>): TestParsingMerge_RepeatedFieldsGenerator_Group2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge_RepeatedFieldsGenerator_Group2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge_RepeatedFieldsGenerator_Group2): TestParsingMerge_RepeatedFieldsGenerator_Group2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes field1 */ 21:
                    message.field1 = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.field1);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge_RepeatedFieldsGenerator_Group2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes field1 = 21; */
        if (message.field1)
            TestAllTypes.internalBinaryWrite(message.field1, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2
 */
export const TestParsingMerge_RepeatedFieldsGenerator_Group2 = new TestParsingMerge_RepeatedFieldsGenerator_Group2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge_OptionalGroup$Type extends MessageType<TestParsingMerge_OptionalGroup> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge.OptionalGroup", [
            { no: 11, name: "optional_group_all_types", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge_OptionalGroup>): TestParsingMerge_OptionalGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge_OptionalGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge_OptionalGroup): TestParsingMerge_OptionalGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes optional_group_all_types */ 11:
                    message.optionalGroupAllTypes = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.optionalGroupAllTypes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge_OptionalGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes optional_group_all_types = 11; */
        if (message.optionalGroupAllTypes)
            TestAllTypes.internalBinaryWrite(message.optionalGroupAllTypes, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge.OptionalGroup
 */
export const TestParsingMerge_OptionalGroup = new TestParsingMerge_OptionalGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestParsingMerge_RepeatedGroup$Type extends MessageType<TestParsingMerge_RepeatedGroup> {
    constructor() {
        super("protobuf_unittest.TestParsingMerge.RepeatedGroup", [
            { no: 21, name: "repeated_group_all_types", kind: "message", T: () => TestAllTypes }
        ]);
    }
    create(value?: PartialMessage<TestParsingMerge_RepeatedGroup>): TestParsingMerge_RepeatedGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestParsingMerge_RepeatedGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestParsingMerge_RepeatedGroup): TestParsingMerge_RepeatedGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestAllTypes repeated_group_all_types */ 21:
                    message.repeatedGroupAllTypes = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, message.repeatedGroupAllTypes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestParsingMerge_RepeatedGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestAllTypes repeated_group_all_types = 21; */
        if (message.repeatedGroupAllTypes)
            TestAllTypes.internalBinaryWrite(message.repeatedGroupAllTypes, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestParsingMerge.RepeatedGroup
 */
export const TestParsingMerge_RepeatedGroup = new TestParsingMerge_RepeatedGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestCommentInjectionMessage$Type extends MessageType<TestCommentInjectionMessage> {
    constructor() {
        super("protobuf_unittest.TestCommentInjectionMessage", [
            { no: 1, name: "a", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestCommentInjectionMessage>): TestCommentInjectionMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestCommentInjectionMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestCommentInjectionMessage): TestCommentInjectionMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string a */ 1:
                    message.a = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestCommentInjectionMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string a = 1; */
        if (message.a !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestCommentInjectionMessage
 */
export const TestCommentInjectionMessage = new TestCommentInjectionMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FooRequest$Type extends MessageType<FooRequest> {
    constructor() {
        super("protobuf_unittest.FooRequest", []);
    }
    create(value?: PartialMessage<FooRequest>): FooRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FooRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FooRequest): FooRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FooRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.FooRequest
 */
export const FooRequest = new FooRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FooResponse$Type extends MessageType<FooResponse> {
    constructor() {
        super("protobuf_unittest.FooResponse", []);
    }
    create(value?: PartialMessage<FooResponse>): FooResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FooResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FooResponse): FooResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FooResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.FooResponse
 */
export const FooResponse = new FooResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FooClientMessage$Type extends MessageType<FooClientMessage> {
    constructor() {
        super("protobuf_unittest.FooClientMessage", []);
    }
    create(value?: PartialMessage<FooClientMessage>): FooClientMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FooClientMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FooClientMessage): FooClientMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FooClientMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.FooClientMessage
 */
export const FooClientMessage = new FooClientMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FooServerMessage$Type extends MessageType<FooServerMessage> {
    constructor() {
        super("protobuf_unittest.FooServerMessage", []);
    }
    create(value?: PartialMessage<FooServerMessage>): FooServerMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FooServerMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FooServerMessage): FooServerMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FooServerMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.FooServerMessage
 */
export const FooServerMessage = new FooServerMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BarRequest$Type extends MessageType<BarRequest> {
    constructor() {
        super("protobuf_unittest.BarRequest", []);
    }
    create(value?: PartialMessage<BarRequest>): BarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BarRequest): BarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.BarRequest
 */
export const BarRequest = new BarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BarResponse$Type extends MessageType<BarResponse> {
    constructor() {
        super("protobuf_unittest.BarResponse", []);
    }
    create(value?: PartialMessage<BarResponse>): BarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BarResponse): BarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.BarResponse
 */
export const BarResponse = new BarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestJsonName$Type extends MessageType<TestJsonName> {
    constructor() {
        super("protobuf_unittest.TestJsonName", [
            { no: 1, name: "field_name1", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fieldName2", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "FieldName3", kind: "scalar", jsonName: "FieldName3", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "_field_name4", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "FIELD_NAME5", kind: "scalar", jsonName: "FIELDNAME5", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "field_name6", kind: "scalar", jsonName: "@type", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestJsonName>): TestJsonName {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestJsonName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestJsonName): TestJsonName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 field_name1 */ 1:
                    message.fieldName1 = reader.int32();
                    break;
                case /* optional int32 fieldName2 */ 2:
                    message.fieldName2 = reader.int32();
                    break;
                case /* optional int32 FieldName3 = 3 [json_name = "FieldName3"];*/ 3:
                    message.fieldName3 = reader.int32();
                    break;
                case /* optional int32 _field_name4 */ 4:
                    message.FieldName4 = reader.int32();
                    break;
                case /* optional int32 FIELD_NAME5 = 5 [json_name = "FIELDNAME5"];*/ 5:
                    message.fIELDNAME5 = reader.int32();
                    break;
                case /* optional int32 field_name6 = 6 [json_name = "@type"];*/ 6:
                    message.fieldName6 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestJsonName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 field_name1 = 1; */
        if (message.fieldName1 !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fieldName1);
        /* optional int32 fieldName2 = 2; */
        if (message.fieldName2 !== undefined)
            writer.tag(2, WireType.Varint).int32(message.fieldName2);
        /* optional int32 FieldName3 = 3 [json_name = "FieldName3"]; */
        if (message.fieldName3 !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fieldName3);
        /* optional int32 _field_name4 = 4; */
        if (message.FieldName4 !== undefined)
            writer.tag(4, WireType.Varint).int32(message.FieldName4);
        /* optional int32 FIELD_NAME5 = 5 [json_name = "FIELDNAME5"]; */
        if (message.fIELDNAME5 !== undefined)
            writer.tag(5, WireType.Varint).int32(message.fIELDNAME5);
        /* optional int32 field_name6 = 6 [json_name = "@type"]; */
        if (message.fieldName6 !== undefined)
            writer.tag(6, WireType.Varint).int32(message.fieldName6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestJsonName
 */
export const TestJsonName = new TestJsonName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestHugeFieldNumbers$Type extends MessageType<TestHugeFieldNumbers> {
    constructor() {
        super("protobuf_unittest.TestHugeFieldNumbers", [
            { no: 536870000, name: "optional_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 536870001, name: "fixed_32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 536870002, name: "repeated_int32", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 536870003, name: "packed_int32", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 536870004, name: "optional_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.ForeignEnum", ForeignEnum] },
            { no: 536870005, name: "optional_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 536870006, name: "optional_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 536870007, name: "optional_message", kind: "message", T: () => ForeignMessage },
            { no: 536870010, name: "string_string_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 536870011, name: "oneof_uint32", kind: "scalar", oneof: "oneofField", T: 13 /*ScalarType.UINT32*/ },
            { no: 536870012, name: "oneof_test_all_types", kind: "message", oneof: "oneofField", T: () => TestAllTypes },
            { no: 536870013, name: "oneof_string", kind: "scalar", oneof: "oneofField", T: 9 /*ScalarType.STRING*/ },
            { no: 536870014, name: "oneof_bytes", kind: "scalar", oneof: "oneofField", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TestHugeFieldNumbers>): TestHugeFieldNumbers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedInt32 = [];
        message.packedInt32 = [];
        message.stringStringMap = {};
        message.oneofField = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestHugeFieldNumbers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestHugeFieldNumbers): TestHugeFieldNumbers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 optional_int32 */ 536870000:
                    message.optionalInt32 = reader.int32();
                    break;
                case /* optional int32 fixed_32 */ 536870001:
                    message.fixed32 = reader.int32();
                    break;
                case /* repeated int32 repeated_int32 = 536870002 [packed = false];*/ 536870002:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt32.push(reader.int32());
                    else
                        message.repeatedInt32.push(reader.int32());
                    break;
                case /* repeated int32 packed_int32 = 536870003 [packed = true];*/ 536870003:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedInt32.push(reader.int32());
                    else
                        message.packedInt32.push(reader.int32());
                    break;
                case /* optional protobuf_unittest.ForeignEnum optional_enum */ 536870004:
                    message.optionalEnum = reader.int32();
                    break;
                case /* optional string optional_string */ 536870005:
                    message.optionalString = reader.string();
                    break;
                case /* optional bytes optional_bytes */ 536870006:
                    message.optionalBytes = reader.bytes();
                    break;
                case /* optional protobuf_unittest.ForeignMessage optional_message */ 536870007:
                    message.optionalMessage = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalMessage);
                    break;
                case /* map<string, string> string_string_map */ 536870010:
                    this.binaryReadMap536870010(message.stringStringMap, reader, options);
                    break;
                case /* uint32 oneof_uint32 */ 536870011:
                    message.oneofField = {
                        oneofKind: "oneofUint32",
                        oneofUint32: reader.uint32()
                    };
                    break;
                case /* protobuf_unittest.TestAllTypes oneof_test_all_types */ 536870012:
                    message.oneofField = {
                        oneofKind: "oneofTestAllTypes",
                        oneofTestAllTypes: TestAllTypes.internalBinaryRead(reader, reader.uint32(), options, (message.oneofField as any).oneofTestAllTypes)
                    };
                    break;
                case /* string oneof_string */ 536870013:
                    message.oneofField = {
                        oneofKind: "oneofString",
                        oneofString: reader.string()
                    };
                    break;
                case /* bytes oneof_bytes */ 536870014:
                    message.oneofField = {
                        oneofKind: "oneofBytes",
                        oneofBytes: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap536870010(map: TestHugeFieldNumbers["stringStringMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestHugeFieldNumbers["stringStringMap"] | undefined, val: TestHugeFieldNumbers["stringStringMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestHugeFieldNumbers.string_string_map");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TestHugeFieldNumbers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 optional_int32 = 536870000; */
        if (message.optionalInt32 !== undefined)
            writer.tag(536870000, WireType.Varint).int32(message.optionalInt32);
        /* optional int32 fixed_32 = 536870001; */
        if (message.fixed32 !== undefined)
            writer.tag(536870001, WireType.Varint).int32(message.fixed32);
        /* repeated int32 repeated_int32 = 536870002 [packed = false]; */
        for (let i = 0; i < message.repeatedInt32.length; i++)
            writer.tag(536870002, WireType.Varint).int32(message.repeatedInt32[i]);
        /* repeated int32 packed_int32 = 536870003 [packed = true]; */
        if (message.packedInt32.length) {
            writer.tag(536870003, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packedInt32.length; i++)
                writer.int32(message.packedInt32[i]);
            writer.join();
        }
        /* optional protobuf_unittest.ForeignEnum optional_enum = 536870004; */
        if (message.optionalEnum !== undefined)
            writer.tag(536870004, WireType.Varint).int32(message.optionalEnum);
        /* optional string optional_string = 536870005; */
        if (message.optionalString !== undefined)
            writer.tag(536870005, WireType.LengthDelimited).string(message.optionalString);
        /* optional bytes optional_bytes = 536870006; */
        if (message.optionalBytes !== undefined)
            writer.tag(536870006, WireType.LengthDelimited).bytes(message.optionalBytes);
        /* optional protobuf_unittest.ForeignMessage optional_message = 536870007; */
        if (message.optionalMessage)
            ForeignMessage.internalBinaryWrite(message.optionalMessage, writer.tag(536870007, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> string_string_map = 536870010; */
        for (let k of globalThis.Object.keys(message.stringStringMap))
            writer.tag(536870010, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.stringStringMap[k]).join();
        /* uint32 oneof_uint32 = 536870011; */
        if (message.oneofField.oneofKind === "oneofUint32")
            writer.tag(536870011, WireType.Varint).uint32(message.oneofField.oneofUint32);
        /* protobuf_unittest.TestAllTypes oneof_test_all_types = 536870012; */
        if (message.oneofField.oneofKind === "oneofTestAllTypes")
            TestAllTypes.internalBinaryWrite(message.oneofField.oneofTestAllTypes, writer.tag(536870012, WireType.LengthDelimited).fork(), options).join();
        /* string oneof_string = 536870013; */
        if (message.oneofField.oneofKind === "oneofString")
            writer.tag(536870013, WireType.LengthDelimited).string(message.oneofField.oneofString);
        /* bytes oneof_bytes = 536870014; */
        if (message.oneofField.oneofKind === "oneofBytes")
            writer.tag(536870014, WireType.LengthDelimited).bytes(message.oneofField.oneofBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestHugeFieldNumbers
 */
export const TestHugeFieldNumbers = new TestHugeFieldNumbers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestHugeFieldNumbers_OptionalGroup$Type extends MessageType<TestHugeFieldNumbers_OptionalGroup> {
    constructor() {
        super("protobuf_unittest.TestHugeFieldNumbers.OptionalGroup", [
            { no: 536870009, name: "group_a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestHugeFieldNumbers_OptionalGroup>): TestHugeFieldNumbers_OptionalGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestHugeFieldNumbers_OptionalGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestHugeFieldNumbers_OptionalGroup): TestHugeFieldNumbers_OptionalGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 group_a */ 536870009:
                    message.groupA = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestHugeFieldNumbers_OptionalGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 group_a = 536870009; */
        if (message.groupA !== undefined)
            writer.tag(536870009, WireType.Varint).int32(message.groupA);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestHugeFieldNumbers.OptionalGroup
 */
export const TestHugeFieldNumbers_OptionalGroup = new TestHugeFieldNumbers_OptionalGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtensionInsideTable$Type extends MessageType<TestExtensionInsideTable> {
    constructor() {
        super("protobuf_unittest.TestExtensionInsideTable", [
            { no: 1, name: "field1", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "field2", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "field3", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "field4", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "field6", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "field7", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "field8", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "field9", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "field10", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestExtensionInsideTable>): TestExtensionInsideTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtensionInsideTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtensionInsideTable): TestExtensionInsideTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 field1 */ 1:
                    message.field1 = reader.int32();
                    break;
                case /* optional int32 field2 */ 2:
                    message.field2 = reader.int32();
                    break;
                case /* optional int32 field3 */ 3:
                    message.field3 = reader.int32();
                    break;
                case /* optional int32 field4 */ 4:
                    message.field4 = reader.int32();
                    break;
                case /* optional int32 field6 */ 6:
                    message.field6 = reader.int32();
                    break;
                case /* optional int32 field7 */ 7:
                    message.field7 = reader.int32();
                    break;
                case /* optional int32 field8 */ 8:
                    message.field8 = reader.int32();
                    break;
                case /* optional int32 field9 */ 9:
                    message.field9 = reader.int32();
                    break;
                case /* optional int32 field10 */ 10:
                    message.field10 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtensionInsideTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 field1 = 1; */
        if (message.field1 !== undefined)
            writer.tag(1, WireType.Varint).int32(message.field1);
        /* optional int32 field2 = 2; */
        if (message.field2 !== undefined)
            writer.tag(2, WireType.Varint).int32(message.field2);
        /* optional int32 field3 = 3; */
        if (message.field3 !== undefined)
            writer.tag(3, WireType.Varint).int32(message.field3);
        /* optional int32 field4 = 4; */
        if (message.field4 !== undefined)
            writer.tag(4, WireType.Varint).int32(message.field4);
        /* optional int32 field6 = 6; */
        if (message.field6 !== undefined)
            writer.tag(6, WireType.Varint).int32(message.field6);
        /* optional int32 field7 = 7; */
        if (message.field7 !== undefined)
            writer.tag(7, WireType.Varint).int32(message.field7);
        /* optional int32 field8 = 8; */
        if (message.field8 !== undefined)
            writer.tag(8, WireType.Varint).int32(message.field8);
        /* optional int32 field9 = 9; */
        if (message.field9 !== undefined)
            writer.tag(9, WireType.Varint).int32(message.field9);
        /* optional int32 field10 = 10; */
        if (message.field10 !== undefined)
            writer.tag(10, WireType.Varint).int32(message.field10);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestExtensionInsideTable
 */
export const TestExtensionInsideTable = new TestExtensionInsideTable$Type();
/**
 * @generated ServiceType for protobuf service protobuf_unittest.TestService
 */
export const TestService = new ServiceType("protobuf_unittest.TestService", [
    { name: "Foo", options: {}, I: FooRequest, O: FooResponse },
    { name: "Bar", options: {}, I: BarRequest, O: BarResponse }
]);
