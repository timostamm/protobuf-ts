// @generated by protobuf-ts 2.9.5
// @generated from protobuf file "google/protobuf/util/internal/testdata/maps.proto" (package "proto_util_converter.testing", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../any";
/**
 * Top-level test cases proto used by MarshallingTest. See description
 * at the top of the class MarshallingTest for details on how to write
 * test cases.
 *
 * @generated from protobuf message proto_util_converter.testing.MapsTestCases
 */
export interface MapsTestCases {
    /**
     * @generated from protobuf field: proto_util_converter.testing.EmptyMap empty_map = 1;
     */
    emptyMap?: EmptyMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt string_to_int = 2;
     */
    stringToInt?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.IntToString int_to_string = 3;
     */
    intToString?: IntToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed1 mixed1 = 4;
     */
    mixed1?: Mixed1;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed2 mixed2 = 5;
     */
    mixed2?: Mixed2;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfObjects map_of_objects = 6;
     */
    mapOfObjects?: MapOfObjects;
    /**
     * Empty key tests
     *
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int1 = 7;
     */
    emptyKeyStringToInt1?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int2 = 8;
     */
    emptyKeyStringToInt2?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int3 = 9;
     */
    emptyKeyStringToInt3?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.BoolToString empty_key_bool_to_string = 10;
     */
    emptyKeyBoolToString?: BoolToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.IntToString empty_key_int_to_string = 11;
     */
    emptyKeyIntToString?: IntToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed1 empty_key_mixed = 12;
     */
    emptyKeyMixed?: Mixed1;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfObjects empty_key_map_objects = 13;
     */
    emptyKeyMapObjects?: MapOfObjects;
}
/**
 * @generated from protobuf message proto_util_converter.testing.EmptyMap
 */
export interface EmptyMap {
    /**
     * @generated from protobuf field: map<int32, int32> map = 1;
     */
    map: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.StringtoInt
 */
export interface StringtoInt {
    /**
     * @generated from protobuf field: map<string, int32> map = 1;
     */
    map: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.IntToString
 */
export interface IntToString {
    /**
     * @generated from protobuf field: map<int32, string> map = 1;
     */
    map: {
        [key: number]: string;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.BoolToString
 */
export interface BoolToString {
    /**
     * @generated from protobuf field: map<bool, string> map = 1;
     */
    map: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.Mixed1
 */
export interface Mixed1 {
    /**
     * @generated from protobuf field: string msg = 1;
     */
    msg: string;
    /**
     * @generated from protobuf field: map<string, float> map = 2;
     */
    map: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.Mixed2
 */
export interface Mixed2 {
    /**
     * @generated from protobuf field: map<int32, bool> map = 1;
     */
    map: {
        [key: number]: boolean;
    };
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed2.E ee = 2;
     */
    ee: Mixed2_E;
}
/**
 * @generated from protobuf enum proto_util_converter.testing.Mixed2.E
 */
export enum Mixed2_E {
    /**
     * @generated from protobuf enum value: E0 = 0;
     */
    E0 = 0,
    /**
     * @generated from protobuf enum value: E1 = 1;
     */
    E1 = 1,
    /**
     * @generated from protobuf enum value: E2 = 2;
     */
    E2 = 2,
    /**
     * @generated from protobuf enum value: E3 = 3;
     */
    E3 = 3
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOfObjects
 */
export interface MapOfObjects {
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapOfObjects.M> map = 1;
     */
    map: {
        [key: string]: MapOfObjects_M;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOfObjects.M
 */
export interface MapOfObjects_M {
    /**
     * @generated from protobuf field: string inner_text = 1;
     */
    innerText: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.DummyRequest
 */
export interface DummyRequest {
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapIn
 */
export interface MapIn {
    /**
     * @generated from protobuf field: string other = 1;
     */
    other: string;
    /**
     * @generated from protobuf field: repeated string things = 2;
     */
    things: string[];
    /**
     * @generated from protobuf field: map<string, string> map_input = 3;
     */
    mapInput: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, google.protobuf.Any> map_any = 4;
     */
    mapAny: {
        [key: string]: Any;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOut
 */
export interface MapOut {
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapM> map1 = 1;
     */
    map1: {
        [key: string]: MapM;
    };
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapOut> map2 = 2;
     */
    map2: {
        [key: string]: MapOut;
    };
    /**
     * @generated from protobuf field: map<int32, string> map3 = 3;
     */
    map3: {
        [key: number]: string;
    };
    /**
     * @generated from protobuf field: map<bool, string> map4 = 5;
     */
    map4: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string bar = 4;
     */
    bar: string;
}
/**
 * A message with exactly the same wire representation as MapOut, but using
 * repeated message fields instead of map fields. We use this message to test
 * the wire-format compatibility of the JSON transcoder (e.g., whether it
 * handles missing keys correctly).
 *
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat
 */
export interface MapOutWireFormat {
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map1Entry map1 = 1;
     */
    map1: MapOutWireFormat_Map1Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map2Entry map2 = 2;
     */
    map2: MapOutWireFormat_Map2Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map3Entry map3 = 3;
     */
    map3: MapOutWireFormat_Map3Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map4Entry map4 = 5;
     */
    map4: MapOutWireFormat_Map4Entry[];
    /**
     * @generated from protobuf field: string bar = 4;
     */
    bar: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map1Entry
 */
export interface MapOutWireFormat_Map1Entry {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapM value = 2;
     */
    value?: MapM;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map2Entry
 */
export interface MapOutWireFormat_Map2Entry {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOut value = 2;
     */
    value?: MapOut;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map3Entry
 */
export interface MapOutWireFormat_Map3Entry {
    /**
     * @generated from protobuf field: int32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map4Entry
 */
export interface MapOutWireFormat_Map4Entry {
    /**
     * @generated from protobuf field: bool key = 1;
     */
    key: boolean;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapM
 */
export interface MapM {
    /**
     * @generated from protobuf field: string foo = 1;
     */
    foo: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MapsTestCases$Type extends MessageType<MapsTestCases> {
    constructor() {
        super("proto_util_converter.testing.MapsTestCases", [
            { no: 1, name: "empty_map", kind: "message", T: () => EmptyMap },
            { no: 2, name: "string_to_int", kind: "message", T: () => StringtoInt },
            { no: 3, name: "int_to_string", kind: "message", T: () => IntToString },
            { no: 4, name: "mixed1", kind: "message", T: () => Mixed1 },
            { no: 5, name: "mixed2", kind: "message", T: () => Mixed2 },
            { no: 6, name: "map_of_objects", kind: "message", T: () => MapOfObjects },
            { no: 7, name: "empty_key_string_to_int1", kind: "message", T: () => StringtoInt },
            { no: 8, name: "empty_key_string_to_int2", kind: "message", T: () => StringtoInt },
            { no: 9, name: "empty_key_string_to_int3", kind: "message", T: () => StringtoInt },
            { no: 10, name: "empty_key_bool_to_string", kind: "message", T: () => BoolToString },
            { no: 11, name: "empty_key_int_to_string", kind: "message", T: () => IntToString },
            { no: 12, name: "empty_key_mixed", kind: "message", T: () => Mixed1 },
            { no: 13, name: "empty_key_map_objects", kind: "message", T: () => MapOfObjects }
        ]);
    }
    create(value?: PartialMessage<MapsTestCases>): MapsTestCases {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MapsTestCases>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapsTestCases): MapsTestCases {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto_util_converter.testing.EmptyMap empty_map */ 1:
                    message.emptyMap = EmptyMap.internalBinaryRead(reader, reader.uint32(), options, message.emptyMap);
                    break;
                case /* proto_util_converter.testing.StringtoInt string_to_int */ 2:
                    message.stringToInt = StringtoInt.internalBinaryRead(reader, reader.uint32(), options, message.stringToInt);
                    break;
                case /* proto_util_converter.testing.IntToString int_to_string */ 3:
                    message.intToString = IntToString.internalBinaryRead(reader, reader.uint32(), options, message.intToString);
                    break;
                case /* proto_util_converter.testing.Mixed1 mixed1 */ 4:
                    message.mixed1 = Mixed1.internalBinaryRead(reader, reader.uint32(), options, message.mixed1);
                    break;
                case /* proto_util_converter.testing.Mixed2 mixed2 */ 5:
                    message.mixed2 = Mixed2.internalBinaryRead(reader, reader.uint32(), options, message.mixed2);
                    break;
                case /* proto_util_converter.testing.MapOfObjects map_of_objects */ 6:
                    message.mapOfObjects = MapOfObjects.internalBinaryRead(reader, reader.uint32(), options, message.mapOfObjects);
                    break;
                case /* proto_util_converter.testing.StringtoInt empty_key_string_to_int1 */ 7:
                    message.emptyKeyStringToInt1 = StringtoInt.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyStringToInt1);
                    break;
                case /* proto_util_converter.testing.StringtoInt empty_key_string_to_int2 */ 8:
                    message.emptyKeyStringToInt2 = StringtoInt.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyStringToInt2);
                    break;
                case /* proto_util_converter.testing.StringtoInt empty_key_string_to_int3 */ 9:
                    message.emptyKeyStringToInt3 = StringtoInt.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyStringToInt3);
                    break;
                case /* proto_util_converter.testing.BoolToString empty_key_bool_to_string */ 10:
                    message.emptyKeyBoolToString = BoolToString.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyBoolToString);
                    break;
                case /* proto_util_converter.testing.IntToString empty_key_int_to_string */ 11:
                    message.emptyKeyIntToString = IntToString.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyIntToString);
                    break;
                case /* proto_util_converter.testing.Mixed1 empty_key_mixed */ 12:
                    message.emptyKeyMixed = Mixed1.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyMixed);
                    break;
                case /* proto_util_converter.testing.MapOfObjects empty_key_map_objects */ 13:
                    message.emptyKeyMapObjects = MapOfObjects.internalBinaryRead(reader, reader.uint32(), options, message.emptyKeyMapObjects);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapsTestCases, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto_util_converter.testing.EmptyMap empty_map = 1; */
        if (message.emptyMap)
            EmptyMap.internalBinaryWrite(message.emptyMap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoInt string_to_int = 2; */
        if (message.stringToInt)
            StringtoInt.internalBinaryWrite(message.stringToInt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.IntToString int_to_string = 3; */
        if (message.intToString)
            IntToString.internalBinaryWrite(message.intToString, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.Mixed1 mixed1 = 4; */
        if (message.mixed1)
            Mixed1.internalBinaryWrite(message.mixed1, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.Mixed2 mixed2 = 5; */
        if (message.mixed2)
            Mixed2.internalBinaryWrite(message.mixed2, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MapOfObjects map_of_objects = 6; */
        if (message.mapOfObjects)
            MapOfObjects.internalBinaryWrite(message.mapOfObjects, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoInt empty_key_string_to_int1 = 7; */
        if (message.emptyKeyStringToInt1)
            StringtoInt.internalBinaryWrite(message.emptyKeyStringToInt1, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoInt empty_key_string_to_int2 = 8; */
        if (message.emptyKeyStringToInt2)
            StringtoInt.internalBinaryWrite(message.emptyKeyStringToInt2, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoInt empty_key_string_to_int3 = 9; */
        if (message.emptyKeyStringToInt3)
            StringtoInt.internalBinaryWrite(message.emptyKeyStringToInt3, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.BoolToString empty_key_bool_to_string = 10; */
        if (message.emptyKeyBoolToString)
            BoolToString.internalBinaryWrite(message.emptyKeyBoolToString, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.IntToString empty_key_int_to_string = 11; */
        if (message.emptyKeyIntToString)
            IntToString.internalBinaryWrite(message.emptyKeyIntToString, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.Mixed1 empty_key_mixed = 12; */
        if (message.emptyKeyMixed)
            Mixed1.internalBinaryWrite(message.emptyKeyMixed, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MapOfObjects empty_key_map_objects = 13; */
        if (message.emptyKeyMapObjects)
            MapOfObjects.internalBinaryWrite(message.emptyKeyMapObjects, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapsTestCases
 */
export const MapsTestCases = new MapsTestCases$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyMap$Type extends MessageType<EmptyMap> {
    constructor() {
        super("proto_util_converter.testing.EmptyMap", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<EmptyMap>): EmptyMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<EmptyMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyMap): EmptyMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: EmptyMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EmptyMap["map"] | undefined, val: EmptyMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.EmptyMap.map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: EmptyMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.map[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.EmptyMap
 */
export const EmptyMap = new EmptyMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringtoInt$Type extends MessageType<StringtoInt> {
    constructor() {
        super("proto_util_converter.testing.StringtoInt", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<StringtoInt>): StringtoInt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<StringtoInt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringtoInt): StringtoInt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int32> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: StringtoInt["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StringtoInt["map"] | undefined, val: StringtoInt["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.StringtoInt.map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: StringtoInt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int32> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.map[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StringtoInt
 */
export const StringtoInt = new StringtoInt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntToString$Type extends MessageType<IntToString> {
    constructor() {
        super("proto_util_converter.testing.IntToString", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<IntToString>): IntToString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<IntToString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntToString): IntToString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, string> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: IntToString["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof IntToString["map"] | undefined, val: IntToString["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.IntToString.map");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    internalBinaryWrite(message: IntToString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, string> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.map[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.IntToString
 */
export const IntToString = new IntToString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolToString$Type extends MessageType<BoolToString> {
    constructor() {
        super("proto_util_converter.testing.BoolToString", [
            { no: 1, name: "map", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<BoolToString>): BoolToString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<BoolToString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoolToString): BoolToString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<bool, string> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: BoolToString["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BoolToString["map"] | undefined, val: BoolToString["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.BoolToString.map");
            }
        }
        map[key ?? "false"] = val ?? "";
    }
    internalBinaryWrite(message: BoolToString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<bool, string> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.LengthDelimited).string(message.map[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.BoolToString
 */
export const BoolToString = new BoolToString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mixed1$Type extends MessageType<Mixed1> {
    constructor() {
        super("proto_util_converter.testing.Mixed1", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<Mixed1>): Mixed1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msg = "";
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<Mixed1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mixed1): Mixed1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* map<string, float> map */ 2:
                    this.binaryReadMap2(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Mixed1["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Mixed1["map"] | undefined, val: Mixed1["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.Mixed1.map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Mixed1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* map<string, float> map = 2; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.map[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.Mixed1
 */
export const Mixed1 = new Mixed1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mixed2$Type extends MessageType<Mixed2> {
    constructor() {
        super("proto_util_converter.testing.Mixed2", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 2, name: "ee", kind: "enum", T: () => ["proto_util_converter.testing.Mixed2.E", Mixed2_E] }
        ]);
    }
    create(value?: PartialMessage<Mixed2>): Mixed2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        message.ee = 0;
        if (value !== undefined)
            reflectionMergePartial<Mixed2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mixed2): Mixed2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, bool> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                case /* proto_util_converter.testing.Mixed2.E ee */ 2:
                    message.ee = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Mixed2["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Mixed2["map"] | undefined, val: Mixed2["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.Mixed2.map");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: Mixed2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, bool> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.map[k as any]).join();
        /* proto_util_converter.testing.Mixed2.E ee = 2; */
        if (message.ee !== 0)
            writer.tag(2, WireType.Varint).int32(message.ee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.Mixed2
 */
export const Mixed2 = new Mixed2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOfObjects$Type extends MessageType<MapOfObjects> {
    constructor() {
        super("proto_util_converter.testing.MapOfObjects", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapOfObjects_M } }
        ]);
    }
    create(value?: PartialMessage<MapOfObjects>): MapOfObjects {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<MapOfObjects>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOfObjects): MapOfObjects {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, proto_util_converter.testing.MapOfObjects.M> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MapOfObjects["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOfObjects["map"] | undefined, val: MapOfObjects["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MapOfObjects_M.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOfObjects.map");
            }
        }
        map[key ?? ""] = val ?? MapOfObjects_M.create();
    }
    internalBinaryWrite(message: MapOfObjects, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, proto_util_converter.testing.MapOfObjects.M> map = 1; */
        for (let k of globalThis.Object.keys(message.map)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MapOfObjects_M.internalBinaryWrite(message.map[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOfObjects
 */
export const MapOfObjects = new MapOfObjects$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOfObjects_M$Type extends MessageType<MapOfObjects_M> {
    constructor() {
        super("proto_util_converter.testing.MapOfObjects.M", [
            { no: 1, name: "inner_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapOfObjects_M>): MapOfObjects_M {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.innerText = "";
        if (value !== undefined)
            reflectionMergePartial<MapOfObjects_M>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOfObjects_M): MapOfObjects_M {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string inner_text */ 1:
                    message.innerText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOfObjects_M, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string inner_text = 1; */
        if (message.innerText !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.innerText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOfObjects.M
 */
export const MapOfObjects_M = new MapOfObjects_M$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DummyRequest$Type extends MessageType<DummyRequest> {
    constructor() {
        super("proto_util_converter.testing.DummyRequest", []);
    }
    create(value?: PartialMessage<DummyRequest>): DummyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DummyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DummyRequest): DummyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DummyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.DummyRequest
 */
export const DummyRequest = new DummyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapIn$Type extends MessageType<MapIn> {
    constructor() {
        super("proto_util_converter.testing.MapIn", [
            { no: 1, name: "other", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "things", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "map_input", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "map_any", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } }
        ]);
    }
    create(value?: PartialMessage<MapIn>): MapIn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.other = "";
        message.things = [];
        message.mapInput = {};
        message.mapAny = {};
        if (value !== undefined)
            reflectionMergePartial<MapIn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapIn): MapIn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string other */ 1:
                    message.other = reader.string();
                    break;
                case /* repeated string things */ 2:
                    message.things.push(reader.string());
                    break;
                case /* map<string, string> map_input */ 3:
                    this.binaryReadMap3(message.mapInput, reader, options);
                    break;
                case /* map<string, google.protobuf.Any> map_any */ 4:
                    this.binaryReadMap4(message.mapAny, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: MapIn["mapInput"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapIn["mapInput"] | undefined, val: MapIn["mapInput"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapIn.map_input");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap4(map: MapIn["mapAny"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapIn["mapAny"] | undefined, val: MapIn["mapAny"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapIn.map_any");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: MapIn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string other = 1; */
        if (message.other !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.other);
        /* repeated string things = 2; */
        for (let i = 0; i < message.things.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.things[i]);
        /* map<string, string> map_input = 3; */
        for (let k of globalThis.Object.keys(message.mapInput))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapInput[k]).join();
        /* map<string, google.protobuf.Any> map_any = 4; */
        for (let k of globalThis.Object.keys(message.mapAny)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.mapAny[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapIn
 */
export const MapIn = new MapIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOut$Type extends MessageType<MapOut> {
    constructor() {
        super("proto_util_converter.testing.MapOut", [
            { no: 1, name: "map1", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapM } },
            { no: 2, name: "map2", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapOut } },
            { no: 3, name: "map3", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "map4", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "bar", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapOut>): MapOut {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map1 = {};
        message.map2 = {};
        message.map3 = {};
        message.map4 = {};
        message.bar = "";
        if (value !== undefined)
            reflectionMergePartial<MapOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOut): MapOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, proto_util_converter.testing.MapM> map1 */ 1:
                    this.binaryReadMap1(message.map1, reader, options);
                    break;
                case /* map<string, proto_util_converter.testing.MapOut> map2 */ 2:
                    this.binaryReadMap2(message.map2, reader, options);
                    break;
                case /* map<int32, string> map3 */ 3:
                    this.binaryReadMap3(message.map3, reader, options);
                    break;
                case /* map<bool, string> map4 */ 5:
                    this.binaryReadMap5(message.map4, reader, options);
                    break;
                case /* string bar */ 4:
                    message.bar = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MapOut["map1"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOut["map1"] | undefined, val: MapOut["map1"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MapM.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOut.map1");
            }
        }
        map[key ?? ""] = val ?? MapM.create();
    }
    private binaryReadMap2(map: MapOut["map2"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOut["map2"] | undefined, val: MapOut["map2"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MapOut.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOut.map2");
            }
        }
        map[key ?? ""] = val ?? MapOut.create();
    }
    private binaryReadMap3(map: MapOut["map3"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOut["map3"] | undefined, val: MapOut["map3"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOut.map3");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    private binaryReadMap5(map: MapOut["map4"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOut["map4"] | undefined, val: MapOut["map4"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOut.map4");
            }
        }
        map[key ?? "false"] = val ?? "";
    }
    internalBinaryWrite(message: MapOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, proto_util_converter.testing.MapM> map1 = 1; */
        for (let k of globalThis.Object.keys(message.map1)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MapM.internalBinaryWrite(message.map1[k], writer, options);
            writer.join().join();
        }
        /* map<string, proto_util_converter.testing.MapOut> map2 = 2; */
        for (let k of globalThis.Object.keys(message.map2)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MapOut.internalBinaryWrite(message.map2[k], writer, options);
            writer.join().join();
        }
        /* map<int32, string> map3 = 3; */
        for (let k of globalThis.Object.keys(message.map3))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.map3[k as any]).join();
        /* map<bool, string> map4 = 5; */
        for (let k of globalThis.Object.keys(message.map4))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.LengthDelimited).string(message.map4[k]).join();
        /* string bar = 4; */
        if (message.bar !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.bar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOut
 */
export const MapOut = new MapOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat$Type extends MessageType<MapOutWireFormat> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat", [
            { no: 1, name: "map1", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map1Entry },
            { no: 2, name: "map2", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map2Entry },
            { no: 3, name: "map3", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map3Entry },
            { no: 5, name: "map4", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map4Entry },
            { no: 4, name: "bar", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapOutWireFormat>): MapOutWireFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map1 = [];
        message.map2 = [];
        message.map3 = [];
        message.map4 = [];
        message.bar = "";
        if (value !== undefined)
            reflectionMergePartial<MapOutWireFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOutWireFormat): MapOutWireFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto_util_converter.testing.MapOutWireFormat.Map1Entry map1 */ 1:
                    message.map1.push(MapOutWireFormat_Map1Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto_util_converter.testing.MapOutWireFormat.Map2Entry map2 */ 2:
                    message.map2.push(MapOutWireFormat_Map2Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto_util_converter.testing.MapOutWireFormat.Map3Entry map3 */ 3:
                    message.map3.push(MapOutWireFormat_Map3Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto_util_converter.testing.MapOutWireFormat.Map4Entry map4 */ 5:
                    message.map4.push(MapOutWireFormat_Map4Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string bar */ 4:
                    message.bar = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOutWireFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto_util_converter.testing.MapOutWireFormat.Map1Entry map1 = 1; */
        for (let i = 0; i < message.map1.length; i++)
            MapOutWireFormat_Map1Entry.internalBinaryWrite(message.map1[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto_util_converter.testing.MapOutWireFormat.Map2Entry map2 = 2; */
        for (let i = 0; i < message.map2.length; i++)
            MapOutWireFormat_Map2Entry.internalBinaryWrite(message.map2[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto_util_converter.testing.MapOutWireFormat.Map3Entry map3 = 3; */
        for (let i = 0; i < message.map3.length; i++)
            MapOutWireFormat_Map3Entry.internalBinaryWrite(message.map3[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto_util_converter.testing.MapOutWireFormat.Map4Entry map4 = 5; */
        for (let i = 0; i < message.map4.length; i++)
            MapOutWireFormat_Map4Entry.internalBinaryWrite(message.map4[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string bar = 4; */
        if (message.bar !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.bar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat
 */
export const MapOutWireFormat = new MapOutWireFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map1Entry$Type extends MessageType<MapOutWireFormat_Map1Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map1Entry", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => MapM }
        ]);
    }
    create(value?: PartialMessage<MapOutWireFormat_Map1Entry>): MapOutWireFormat_Map1Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<MapOutWireFormat_Map1Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOutWireFormat_Map1Entry): MapOutWireFormat_Map1Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* proto_util_converter.testing.MapM value */ 2:
                    message.value = MapM.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOutWireFormat_Map1Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* proto_util_converter.testing.MapM value = 2; */
        if (message.value)
            MapM.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map1Entry
 */
export const MapOutWireFormat_Map1Entry = new MapOutWireFormat_Map1Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map2Entry$Type extends MessageType<MapOutWireFormat_Map2Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map2Entry", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => MapOut }
        ]);
    }
    create(value?: PartialMessage<MapOutWireFormat_Map2Entry>): MapOutWireFormat_Map2Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<MapOutWireFormat_Map2Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOutWireFormat_Map2Entry): MapOutWireFormat_Map2Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* proto_util_converter.testing.MapOut value */ 2:
                    message.value = MapOut.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOutWireFormat_Map2Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* proto_util_converter.testing.MapOut value = 2; */
        if (message.value)
            MapOut.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map2Entry
 */
export const MapOutWireFormat_Map2Entry = new MapOutWireFormat_Map2Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map3Entry$Type extends MessageType<MapOutWireFormat_Map3Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map3Entry", [
            { no: 1, name: "key", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapOutWireFormat_Map3Entry>): MapOutWireFormat_Map3Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = 0;
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<MapOutWireFormat_Map3Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOutWireFormat_Map3Entry): MapOutWireFormat_Map3Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 key */ 1:
                    message.key = reader.int32();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOutWireFormat_Map3Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Varint).int32(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map3Entry
 */
export const MapOutWireFormat_Map3Entry = new MapOutWireFormat_Map3Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map4Entry$Type extends MessageType<MapOutWireFormat_Map4Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map4Entry", [
            { no: 1, name: "key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapOutWireFormat_Map4Entry>): MapOutWireFormat_Map4Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = false;
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<MapOutWireFormat_Map4Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOutWireFormat_Map4Entry): MapOutWireFormat_Map4Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool key */ 1:
                    message.key = reader.bool();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapOutWireFormat_Map4Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool key = 1; */
        if (message.key !== false)
            writer.tag(1, WireType.Varint).bool(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map4Entry
 */
export const MapOutWireFormat_Map4Entry = new MapOutWireFormat_Map4Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapM$Type extends MessageType<MapM> {
    constructor() {
        super("proto_util_converter.testing.MapM", [
            { no: 1, name: "foo", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MapM>): MapM {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.foo = "";
        if (value !== undefined)
            reflectionMergePartial<MapM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapM): MapM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string foo */ 1:
                    message.foo = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string foo = 1; */
        if (message.foo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.foo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapM
 */
export const MapM = new MapM$Type();
/**
 * @generated ServiceType for protobuf service proto_util_converter.testing.MapsTestService
 */
export const MapsTestService = new ServiceType("proto_util_converter.testing.MapsTestService", [
    { name: "Call", options: {}, I: DummyRequest, O: MapsTestCases }
]);
