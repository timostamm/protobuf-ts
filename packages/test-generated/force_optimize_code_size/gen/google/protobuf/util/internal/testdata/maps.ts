// @generated by protobuf-ts 2.9.5 with parameter force_optimize_code_size
// @generated from protobuf file "google/protobuf/util/internal/testdata/maps.proto" (package "proto_util_converter.testing", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../any";
/**
 * Top-level test cases proto used by MarshallingTest. See description
 * at the top of the class MarshallingTest for details on how to write
 * test cases.
 *
 * @generated from protobuf message proto_util_converter.testing.MapsTestCases
 */
export interface MapsTestCases {
    /**
     * @generated from protobuf field: proto_util_converter.testing.EmptyMap empty_map = 1;
     */
    emptyMap?: EmptyMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt string_to_int = 2;
     */
    stringToInt?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.IntToString int_to_string = 3;
     */
    intToString?: IntToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed1 mixed1 = 4;
     */
    mixed1?: Mixed1;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed2 mixed2 = 5;
     */
    mixed2?: Mixed2;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfObjects map_of_objects = 6;
     */
    mapOfObjects?: MapOfObjects;
    /**
     * Empty key tests
     *
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int1 = 7;
     */
    emptyKeyStringToInt1?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int2 = 8;
     */
    emptyKeyStringToInt2?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoInt empty_key_string_to_int3 = 9;
     */
    emptyKeyStringToInt3?: StringtoInt;
    /**
     * @generated from protobuf field: proto_util_converter.testing.BoolToString empty_key_bool_to_string = 10;
     */
    emptyKeyBoolToString?: BoolToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.IntToString empty_key_int_to_string = 11;
     */
    emptyKeyIntToString?: IntToString;
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed1 empty_key_mixed = 12;
     */
    emptyKeyMixed?: Mixed1;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfObjects empty_key_map_objects = 13;
     */
    emptyKeyMapObjects?: MapOfObjects;
}
/**
 * @generated from protobuf message proto_util_converter.testing.EmptyMap
 */
export interface EmptyMap {
    /**
     * @generated from protobuf field: map<int32, int32> map = 1;
     */
    map: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.StringtoInt
 */
export interface StringtoInt {
    /**
     * @generated from protobuf field: map<string, int32> map = 1;
     */
    map: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.IntToString
 */
export interface IntToString {
    /**
     * @generated from protobuf field: map<int32, string> map = 1;
     */
    map: {
        [key: number]: string;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.BoolToString
 */
export interface BoolToString {
    /**
     * @generated from protobuf field: map<bool, string> map = 1;
     */
    map: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.Mixed1
 */
export interface Mixed1 {
    /**
     * @generated from protobuf field: string msg = 1;
     */
    msg: string;
    /**
     * @generated from protobuf field: map<string, float> map = 2;
     */
    map: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.Mixed2
 */
export interface Mixed2 {
    /**
     * @generated from protobuf field: map<int32, bool> map = 1;
     */
    map: {
        [key: number]: boolean;
    };
    /**
     * @generated from protobuf field: proto_util_converter.testing.Mixed2.E ee = 2;
     */
    ee: Mixed2_E;
}
/**
 * @generated from protobuf enum proto_util_converter.testing.Mixed2.E
 */
export enum Mixed2_E {
    /**
     * @generated from protobuf enum value: E0 = 0;
     */
    E0 = 0,
    /**
     * @generated from protobuf enum value: E1 = 1;
     */
    E1 = 1,
    /**
     * @generated from protobuf enum value: E2 = 2;
     */
    E2 = 2,
    /**
     * @generated from protobuf enum value: E3 = 3;
     */
    E3 = 3
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOfObjects
 */
export interface MapOfObjects {
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapOfObjects.M> map = 1;
     */
    map: {
        [key: string]: MapOfObjects_M;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOfObjects.M
 */
export interface MapOfObjects_M {
    /**
     * @generated from protobuf field: string inner_text = 1;
     */
    innerText: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.DummyRequest
 */
export interface DummyRequest {
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapIn
 */
export interface MapIn {
    /**
     * @generated from protobuf field: string other = 1;
     */
    other: string;
    /**
     * @generated from protobuf field: repeated string things = 2;
     */
    things: string[];
    /**
     * @generated from protobuf field: map<string, string> map_input = 3;
     */
    mapInput: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, google.protobuf.Any> map_any = 4;
     */
    mapAny: {
        [key: string]: Any;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOut
 */
export interface MapOut {
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapM> map1 = 1;
     */
    map1: {
        [key: string]: MapM;
    };
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MapOut> map2 = 2;
     */
    map2: {
        [key: string]: MapOut;
    };
    /**
     * @generated from protobuf field: map<int32, string> map3 = 3;
     */
    map3: {
        [key: number]: string;
    };
    /**
     * @generated from protobuf field: map<bool, string> map4 = 5;
     */
    map4: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string bar = 4;
     */
    bar: string;
}
/**
 * A message with exactly the same wire representation as MapOut, but using
 * repeated message fields instead of map fields. We use this message to test
 * the wire-format compatibility of the JSON transcoder (e.g., whether it
 * handles missing keys correctly).
 *
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat
 */
export interface MapOutWireFormat {
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map1Entry map1 = 1;
     */
    map1: MapOutWireFormat_Map1Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map2Entry map2 = 2;
     */
    map2: MapOutWireFormat_Map2Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map3Entry map3 = 3;
     */
    map3: MapOutWireFormat_Map3Entry[];
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.MapOutWireFormat.Map4Entry map4 = 5;
     */
    map4: MapOutWireFormat_Map4Entry[];
    /**
     * @generated from protobuf field: string bar = 4;
     */
    bar: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map1Entry
 */
export interface MapOutWireFormat_Map1Entry {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapM value = 2;
     */
    value?: MapM;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map2Entry
 */
export interface MapOutWireFormat_Map2Entry {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOut value = 2;
     */
    value?: MapOut;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map3Entry
 */
export interface MapOutWireFormat_Map3Entry {
    /**
     * @generated from protobuf field: int32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOutWireFormat.Map4Entry
 */
export interface MapOutWireFormat_Map4Entry {
    /**
     * @generated from protobuf field: bool key = 1;
     */
    key: boolean;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapM
 */
export interface MapM {
    /**
     * @generated from protobuf field: string foo = 1;
     */
    foo: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MapsTestCases$Type extends MessageType<MapsTestCases> {
    constructor() {
        super("proto_util_converter.testing.MapsTestCases", [
            { no: 1, name: "empty_map", kind: "message", T: () => EmptyMap },
            { no: 2, name: "string_to_int", kind: "message", T: () => StringtoInt },
            { no: 3, name: "int_to_string", kind: "message", T: () => IntToString },
            { no: 4, name: "mixed1", kind: "message", T: () => Mixed1 },
            { no: 5, name: "mixed2", kind: "message", T: () => Mixed2 },
            { no: 6, name: "map_of_objects", kind: "message", T: () => MapOfObjects },
            { no: 7, name: "empty_key_string_to_int1", kind: "message", T: () => StringtoInt },
            { no: 8, name: "empty_key_string_to_int2", kind: "message", T: () => StringtoInt },
            { no: 9, name: "empty_key_string_to_int3", kind: "message", T: () => StringtoInt },
            { no: 10, name: "empty_key_bool_to_string", kind: "message", T: () => BoolToString },
            { no: 11, name: "empty_key_int_to_string", kind: "message", T: () => IntToString },
            { no: 12, name: "empty_key_mixed", kind: "message", T: () => Mixed1 },
            { no: 13, name: "empty_key_map_objects", kind: "message", T: () => MapOfObjects }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapsTestCases
 */
export const MapsTestCases = new MapsTestCases$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyMap$Type extends MessageType<EmptyMap> {
    constructor() {
        super("proto_util_converter.testing.EmptyMap", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.EmptyMap
 */
export const EmptyMap = new EmptyMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringtoInt$Type extends MessageType<StringtoInt> {
    constructor() {
        super("proto_util_converter.testing.StringtoInt", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StringtoInt
 */
export const StringtoInt = new StringtoInt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntToString$Type extends MessageType<IntToString> {
    constructor() {
        super("proto_util_converter.testing.IntToString", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.IntToString
 */
export const IntToString = new IntToString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolToString$Type extends MessageType<BoolToString> {
    constructor() {
        super("proto_util_converter.testing.BoolToString", [
            { no: 1, name: "map", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.BoolToString
 */
export const BoolToString = new BoolToString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mixed1$Type extends MessageType<Mixed1> {
    constructor() {
        super("proto_util_converter.testing.Mixed1", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.Mixed1
 */
export const Mixed1 = new Mixed1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mixed2$Type extends MessageType<Mixed2> {
    constructor() {
        super("proto_util_converter.testing.Mixed2", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 2, name: "ee", kind: "enum", T: () => ["proto_util_converter.testing.Mixed2.E", Mixed2_E] }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.Mixed2
 */
export const Mixed2 = new Mixed2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOfObjects$Type extends MessageType<MapOfObjects> {
    constructor() {
        super("proto_util_converter.testing.MapOfObjects", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapOfObjects_M } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOfObjects
 */
export const MapOfObjects = new MapOfObjects$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOfObjects_M$Type extends MessageType<MapOfObjects_M> {
    constructor() {
        super("proto_util_converter.testing.MapOfObjects.M", [
            { no: 1, name: "inner_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOfObjects.M
 */
export const MapOfObjects_M = new MapOfObjects_M$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DummyRequest$Type extends MessageType<DummyRequest> {
    constructor() {
        super("proto_util_converter.testing.DummyRequest", []);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.DummyRequest
 */
export const DummyRequest = new DummyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapIn$Type extends MessageType<MapIn> {
    constructor() {
        super("proto_util_converter.testing.MapIn", [
            { no: 1, name: "other", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "things", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "map_input", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "map_any", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapIn
 */
export const MapIn = new MapIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOut$Type extends MessageType<MapOut> {
    constructor() {
        super("proto_util_converter.testing.MapOut", [
            { no: 1, name: "map1", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapM } },
            { no: 2, name: "map2", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MapOut } },
            { no: 3, name: "map3", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "map4", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "bar", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOut
 */
export const MapOut = new MapOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat$Type extends MessageType<MapOutWireFormat> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat", [
            { no: 1, name: "map1", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map1Entry },
            { no: 2, name: "map2", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map2Entry },
            { no: 3, name: "map3", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map3Entry },
            { no: 5, name: "map4", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapOutWireFormat_Map4Entry },
            { no: 4, name: "bar", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat
 */
export const MapOutWireFormat = new MapOutWireFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map1Entry$Type extends MessageType<MapOutWireFormat_Map1Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map1Entry", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => MapM }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map1Entry
 */
export const MapOutWireFormat_Map1Entry = new MapOutWireFormat_Map1Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map2Entry$Type extends MessageType<MapOutWireFormat_Map2Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map2Entry", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => MapOut }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map2Entry
 */
export const MapOutWireFormat_Map2Entry = new MapOutWireFormat_Map2Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map3Entry$Type extends MessageType<MapOutWireFormat_Map3Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map3Entry", [
            { no: 1, name: "key", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map3Entry
 */
export const MapOutWireFormat_Map3Entry = new MapOutWireFormat_Map3Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOutWireFormat_Map4Entry$Type extends MessageType<MapOutWireFormat_Map4Entry> {
    constructor() {
        super("proto_util_converter.testing.MapOutWireFormat.Map4Entry", [
            { no: 1, name: "key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOutWireFormat.Map4Entry
 */
export const MapOutWireFormat_Map4Entry = new MapOutWireFormat_Map4Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapM$Type extends MessageType<MapM> {
    constructor() {
        super("proto_util_converter.testing.MapM", [
            { no: 1, name: "foo", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapM
 */
export const MapM = new MapM$Type();
/**
 * @generated ServiceType for protobuf service proto_util_converter.testing.MapsTestService
 */
export const MapsTestService = new ServiceType("proto_util_converter.testing.MapsTestService", [
    { name: "Call", options: {}, I: DummyRequest, O: MapsTestCases }
]);
