// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/util/internal/testdata/struct.proto" (package "proto_util_converter.testing", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ListValue } from "../../../struct";
import { Value } from "../../../struct";
import { Struct } from "../../../struct";
/**
 * @generated from protobuf message proto_util_converter.testing.StructTestCases
 */
export interface StructTestCases {
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper empty_value = 1;
     */
    emptyValue?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper empty_value2 = 2;
     */
    emptyValue2?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper null_value = 3;
     */
    nullValue?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper simple_struct = 4;
     */
    simpleStruct?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper longer_struct = 5;
     */
    longerStruct?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_nested_struct = 6;
     */
    structWithNestedStruct?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_nested_list = 7;
     */
    structWithNestedList?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_list_of_nulls = 8;
     */
    structWithListOfNulls?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_list_of_lists = 9;
     */
    structWithListOfLists?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_list_of_structs = 10;
     */
    structWithListOfStructs?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_empty_list = 11;
     */
    structWithEmptyList?: StructWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructWrapper struct_with_list_with_empty_struct = 12;
     */
    structWithListWithEmptyStruct?: StructWrapper;
    /**
     * @generated from protobuf field: google.protobuf.Struct top_level_struct = 13;
     */
    topLevelStruct?: Struct;
    /**
     * @generated from protobuf field: google.protobuf.Struct top_level_struct_with_empty_list = 14;
     */
    topLevelStructWithEmptyList?: Struct;
    /**
     * @generated from protobuf field: google.protobuf.Struct top_level_struct_with_list_with_empty_struct = 15;
     */
    topLevelStructWithListWithEmptyStruct?: Struct;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueWrapper value_wrapper_simple = 16;
     */
    valueWrapperSimple?: ValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueWrapper value_wrapper_with_struct = 17;
     */
    valueWrapperWithStruct?: ValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueWrapper value_wrapper_with_list = 18;
     */
    valueWrapperWithList?: ValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueWrapper value_wrapper_with_empty_list = 19;
     */
    valueWrapperWithEmptyList?: ValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueWrapper value_wrapper_with_list_with_empty_struct = 20;
     */
    valueWrapperWithListWithEmptyStruct?: ValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ListValueWrapper list_value_wrapper = 21;
     */
    listValueWrapper?: ListValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_empty_list = 22;
     */
    listValueWrapperWithEmptyList?: ListValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_list_with_empty_struct = 23;
     */
    listValueWrapperWithListWithEmptyStruct?: ListValueWrapper;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_simple = 24;
     */
    topLevelValueSimple?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_struct = 25;
     */
    topLevelValueWithStruct?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_list = 26;
     */
    topLevelValueWithList?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_empty_list = 27;
     */
    topLevelValueWithEmptyList?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_list_with_empty_struct = 28;
     */
    topLevelValueWithListWithEmptyStruct?: Value;
    /**
     * @generated from protobuf field: google.protobuf.ListValue top_level_listvalue = 29;
     */
    topLevelListvalue?: ListValue;
    /**
     * @generated from protobuf field: google.protobuf.ListValue top_level_empty_listvalue = 30;
     */
    topLevelEmptyListvalue?: ListValue;
    /**
     * @generated from protobuf field: google.protobuf.ListValue top_level_listvalue_with_empty_struct = 31;
     */
    topLevelListvalueWithEmptyStruct?: ListValue;
    /**
     * @generated from protobuf field: proto_util_converter.testing.RepeatedValueWrapper repeated_value = 32;
     */
    repeatedValue?: RepeatedValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list = 33;
     */
    repeatedValueNestedList?: RepeatedValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list2 = 34;
     */
    repeatedValueNestedList2?: RepeatedValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list3 = 35;
     */
    repeatedValueNestedList3?: RepeatedValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.RepeatedListValueWrapper repeated_listvalue = 36;
     */
    repeatedListvalue?: RepeatedListValueWrapper;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfStruct map_of_struct = 37;
     */
    mapOfStruct?: MapOfStruct;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfStruct map_of_struct_value = 38;
     */
    mapOfStructValue?: MapOfStruct;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MapOfStruct map_of_listvalue = 39;
     */
    mapOfListvalue?: MapOfStruct;
}
/**
 * @generated from protobuf message proto_util_converter.testing.StructWrapper
 */
export interface StructWrapper {
    /**
     * @generated from protobuf field: google.protobuf.Struct struct = 1;
     */
    struct?: Struct;
}
/**
 * @generated from protobuf message proto_util_converter.testing.ValueWrapper
 */
export interface ValueWrapper {
    /**
     * @generated from protobuf field: google.protobuf.Value value = 1;
     */
    value?: Value;
}
/**
 * @generated from protobuf message proto_util_converter.testing.RepeatedValueWrapper
 */
export interface RepeatedValueWrapper {
    /**
     * @generated from protobuf field: repeated google.protobuf.Value values = 1;
     */
    values: Value[];
}
/**
 * @generated from protobuf message proto_util_converter.testing.ListValueWrapper
 */
export interface ListValueWrapper {
    /**
     * @generated from protobuf field: google.protobuf.ListValue shopping_list = 1;
     */
    shoppingList?: ListValue;
}
/**
 * @generated from protobuf message proto_util_converter.testing.RepeatedListValueWrapper
 */
export interface RepeatedListValueWrapper {
    /**
     * @generated from protobuf field: repeated google.protobuf.ListValue dimensions = 1;
     */
    dimensions: ListValue[];
}
/**
 * @generated from protobuf message proto_util_converter.testing.MapOfStruct
 */
export interface MapOfStruct {
    /**
     * @generated from protobuf field: map<string, google.protobuf.Struct> struct_map = 1;
     */
    structMap: {
        [key: string]: Struct;
    };
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> value_map = 2;
     */
    valueMap: {
        [key: string]: Value;
    };
    /**
     * @generated from protobuf field: map<string, google.protobuf.ListValue> listvalue_map = 3;
     */
    listvalueMap: {
        [key: string]: ListValue;
    };
}
/**
 * Hack to test return types with Struct as top-level message. Struct typers
 * cannot be directly used in API requests. Hence using Dummy as request type.
 *
 * @generated from protobuf message proto_util_converter.testing.Dummy
 */
export interface Dummy {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.StructType
 */
export interface StructType {
    /**
     * @generated from protobuf field: google.protobuf.Struct object = 1;
     */
    object?: Struct;
}
// @generated message type with reflection information, may provide speed optimized methods
class StructTestCases$Type extends MessageType<StructTestCases> {
    constructor() {
        super("proto_util_converter.testing.StructTestCases", [
            { no: 1, name: "empty_value", kind: "message", T: () => StructWrapper },
            { no: 2, name: "empty_value2", kind: "message", T: () => StructWrapper },
            { no: 3, name: "null_value", kind: "message", T: () => StructWrapper },
            { no: 4, name: "simple_struct", kind: "message", T: () => StructWrapper },
            { no: 5, name: "longer_struct", kind: "message", T: () => StructWrapper },
            { no: 6, name: "struct_with_nested_struct", kind: "message", T: () => StructWrapper },
            { no: 7, name: "struct_with_nested_list", kind: "message", T: () => StructWrapper },
            { no: 8, name: "struct_with_list_of_nulls", kind: "message", T: () => StructWrapper },
            { no: 9, name: "struct_with_list_of_lists", kind: "message", T: () => StructWrapper },
            { no: 10, name: "struct_with_list_of_structs", kind: "message", T: () => StructWrapper },
            { no: 11, name: "struct_with_empty_list", kind: "message", T: () => StructWrapper },
            { no: 12, name: "struct_with_list_with_empty_struct", kind: "message", T: () => StructWrapper },
            { no: 13, name: "top_level_struct", kind: "message", T: () => Struct },
            { no: 14, name: "top_level_struct_with_empty_list", kind: "message", T: () => Struct },
            { no: 15, name: "top_level_struct_with_list_with_empty_struct", kind: "message", T: () => Struct },
            { no: 16, name: "value_wrapper_simple", kind: "message", T: () => ValueWrapper },
            { no: 17, name: "value_wrapper_with_struct", kind: "message", T: () => ValueWrapper },
            { no: 18, name: "value_wrapper_with_list", kind: "message", T: () => ValueWrapper },
            { no: 19, name: "value_wrapper_with_empty_list", kind: "message", T: () => ValueWrapper },
            { no: 20, name: "value_wrapper_with_list_with_empty_struct", kind: "message", T: () => ValueWrapper },
            { no: 21, name: "list_value_wrapper", kind: "message", T: () => ListValueWrapper },
            { no: 22, name: "list_value_wrapper_with_empty_list", kind: "message", T: () => ListValueWrapper },
            { no: 23, name: "list_value_wrapper_with_list_with_empty_struct", kind: "message", T: () => ListValueWrapper },
            { no: 24, name: "top_level_value_simple", kind: "message", T: () => Value },
            { no: 25, name: "top_level_value_with_struct", kind: "message", T: () => Value },
            { no: 26, name: "top_level_value_with_list", kind: "message", T: () => Value },
            { no: 27, name: "top_level_value_with_empty_list", kind: "message", T: () => Value },
            { no: 28, name: "top_level_value_with_list_with_empty_struct", kind: "message", T: () => Value },
            { no: 29, name: "top_level_listvalue", kind: "message", T: () => ListValue },
            { no: 30, name: "top_level_empty_listvalue", kind: "message", T: () => ListValue },
            { no: 31, name: "top_level_listvalue_with_empty_struct", kind: "message", T: () => ListValue },
            { no: 32, name: "repeated_value", kind: "message", T: () => RepeatedValueWrapper },
            { no: 33, name: "repeated_value_nested_list", kind: "message", T: () => RepeatedValueWrapper },
            { no: 34, name: "repeated_value_nested_list2", kind: "message", T: () => RepeatedValueWrapper },
            { no: 35, name: "repeated_value_nested_list3", kind: "message", T: () => RepeatedValueWrapper },
            { no: 36, name: "repeated_listvalue", kind: "message", T: () => RepeatedListValueWrapper },
            { no: 37, name: "map_of_struct", kind: "message", T: () => MapOfStruct },
            { no: 38, name: "map_of_struct_value", kind: "message", T: () => MapOfStruct },
            { no: 39, name: "map_of_listvalue", kind: "message", T: () => MapOfStruct }
        ]);
    }
    create(value?: PartialMessage<StructTestCases>): StructTestCases {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StructTestCases>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StructTestCases): StructTestCases {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto_util_converter.testing.StructWrapper empty_value */ 1:
                    message.emptyValue = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.emptyValue);
                    break;
                case /* proto_util_converter.testing.StructWrapper empty_value2 */ 2:
                    message.emptyValue2 = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.emptyValue2);
                    break;
                case /* proto_util_converter.testing.StructWrapper null_value */ 3:
                    message.nullValue = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.nullValue);
                    break;
                case /* proto_util_converter.testing.StructWrapper simple_struct */ 4:
                    message.simpleStruct = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.simpleStruct);
                    break;
                case /* proto_util_converter.testing.StructWrapper longer_struct */ 5:
                    message.longerStruct = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.longerStruct);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_nested_struct */ 6:
                    message.structWithNestedStruct = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithNestedStruct);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_nested_list */ 7:
                    message.structWithNestedList = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithNestedList);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_list_of_nulls */ 8:
                    message.structWithListOfNulls = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfNulls);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_list_of_lists */ 9:
                    message.structWithListOfLists = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfLists);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_list_of_structs */ 10:
                    message.structWithListOfStructs = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfStructs);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_empty_list */ 11:
                    message.structWithEmptyList = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithEmptyList);
                    break;
                case /* proto_util_converter.testing.StructWrapper struct_with_list_with_empty_struct */ 12:
                    message.structWithListWithEmptyStruct = StructWrapper.internalBinaryRead(reader, reader.uint32(), options, message.structWithListWithEmptyStruct);
                    break;
                case /* google.protobuf.Struct top_level_struct */ 13:
                    message.topLevelStruct = Struct.internalBinaryRead(reader, reader.uint32(), options, message.topLevelStruct);
                    break;
                case /* google.protobuf.Struct top_level_struct_with_empty_list */ 14:
                    message.topLevelStructWithEmptyList = Struct.internalBinaryRead(reader, reader.uint32(), options, message.topLevelStructWithEmptyList);
                    break;
                case /* google.protobuf.Struct top_level_struct_with_list_with_empty_struct */ 15:
                    message.topLevelStructWithListWithEmptyStruct = Struct.internalBinaryRead(reader, reader.uint32(), options, message.topLevelStructWithListWithEmptyStruct);
                    break;
                case /* proto_util_converter.testing.ValueWrapper value_wrapper_simple */ 16:
                    message.valueWrapperSimple = ValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperSimple);
                    break;
                case /* proto_util_converter.testing.ValueWrapper value_wrapper_with_struct */ 17:
                    message.valueWrapperWithStruct = ValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithStruct);
                    break;
                case /* proto_util_converter.testing.ValueWrapper value_wrapper_with_list */ 18:
                    message.valueWrapperWithList = ValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithList);
                    break;
                case /* proto_util_converter.testing.ValueWrapper value_wrapper_with_empty_list */ 19:
                    message.valueWrapperWithEmptyList = ValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithEmptyList);
                    break;
                case /* proto_util_converter.testing.ValueWrapper value_wrapper_with_list_with_empty_struct */ 20:
                    message.valueWrapperWithListWithEmptyStruct = ValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithListWithEmptyStruct);
                    break;
                case /* proto_util_converter.testing.ListValueWrapper list_value_wrapper */ 21:
                    message.listValueWrapper = ListValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.listValueWrapper);
                    break;
                case /* proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_empty_list */ 22:
                    message.listValueWrapperWithEmptyList = ListValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.listValueWrapperWithEmptyList);
                    break;
                case /* proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_list_with_empty_struct */ 23:
                    message.listValueWrapperWithListWithEmptyStruct = ListValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.listValueWrapperWithListWithEmptyStruct);
                    break;
                case /* google.protobuf.Value top_level_value_simple */ 24:
                    message.topLevelValueSimple = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueSimple);
                    break;
                case /* google.protobuf.Value top_level_value_with_struct */ 25:
                    message.topLevelValueWithStruct = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithStruct);
                    break;
                case /* google.protobuf.Value top_level_value_with_list */ 26:
                    message.topLevelValueWithList = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithList);
                    break;
                case /* google.protobuf.Value top_level_value_with_empty_list */ 27:
                    message.topLevelValueWithEmptyList = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithEmptyList);
                    break;
                case /* google.protobuf.Value top_level_value_with_list_with_empty_struct */ 28:
                    message.topLevelValueWithListWithEmptyStruct = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithListWithEmptyStruct);
                    break;
                case /* google.protobuf.ListValue top_level_listvalue */ 29:
                    message.topLevelListvalue = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.topLevelListvalue);
                    break;
                case /* google.protobuf.ListValue top_level_empty_listvalue */ 30:
                    message.topLevelEmptyListvalue = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.topLevelEmptyListvalue);
                    break;
                case /* google.protobuf.ListValue top_level_listvalue_with_empty_struct */ 31:
                    message.topLevelListvalueWithEmptyStruct = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.topLevelListvalueWithEmptyStruct);
                    break;
                case /* proto_util_converter.testing.RepeatedValueWrapper repeated_value */ 32:
                    message.repeatedValue = RepeatedValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.repeatedValue);
                    break;
                case /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list */ 33:
                    message.repeatedValueNestedList = RepeatedValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.repeatedValueNestedList);
                    break;
                case /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list2 */ 34:
                    message.repeatedValueNestedList2 = RepeatedValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.repeatedValueNestedList2);
                    break;
                case /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list3 */ 35:
                    message.repeatedValueNestedList3 = RepeatedValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.repeatedValueNestedList3);
                    break;
                case /* proto_util_converter.testing.RepeatedListValueWrapper repeated_listvalue */ 36:
                    message.repeatedListvalue = RepeatedListValueWrapper.internalBinaryRead(reader, reader.uint32(), options, message.repeatedListvalue);
                    break;
                case /* proto_util_converter.testing.MapOfStruct map_of_struct */ 37:
                    message.mapOfStruct = MapOfStruct.internalBinaryRead(reader, reader.uint32(), options, message.mapOfStruct);
                    break;
                case /* proto_util_converter.testing.MapOfStruct map_of_struct_value */ 38:
                    message.mapOfStructValue = MapOfStruct.internalBinaryRead(reader, reader.uint32(), options, message.mapOfStructValue);
                    break;
                case /* proto_util_converter.testing.MapOfStruct map_of_listvalue */ 39:
                    message.mapOfListvalue = MapOfStruct.internalBinaryRead(reader, reader.uint32(), options, message.mapOfListvalue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StructTestCases, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto_util_converter.testing.StructWrapper empty_value = 1; */
        if (message.emptyValue)
            StructWrapper.internalBinaryWrite(message.emptyValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper empty_value2 = 2; */
        if (message.emptyValue2)
            StructWrapper.internalBinaryWrite(message.emptyValue2, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper null_value = 3; */
        if (message.nullValue)
            StructWrapper.internalBinaryWrite(message.nullValue, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper simple_struct = 4; */
        if (message.simpleStruct)
            StructWrapper.internalBinaryWrite(message.simpleStruct, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper longer_struct = 5; */
        if (message.longerStruct)
            StructWrapper.internalBinaryWrite(message.longerStruct, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_nested_struct = 6; */
        if (message.structWithNestedStruct)
            StructWrapper.internalBinaryWrite(message.structWithNestedStruct, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_nested_list = 7; */
        if (message.structWithNestedList)
            StructWrapper.internalBinaryWrite(message.structWithNestedList, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_list_of_nulls = 8; */
        if (message.structWithListOfNulls)
            StructWrapper.internalBinaryWrite(message.structWithListOfNulls, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_list_of_lists = 9; */
        if (message.structWithListOfLists)
            StructWrapper.internalBinaryWrite(message.structWithListOfLists, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_list_of_structs = 10; */
        if (message.structWithListOfStructs)
            StructWrapper.internalBinaryWrite(message.structWithListOfStructs, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_empty_list = 11; */
        if (message.structWithEmptyList)
            StructWrapper.internalBinaryWrite(message.structWithEmptyList, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructWrapper struct_with_list_with_empty_struct = 12; */
        if (message.structWithListWithEmptyStruct)
            StructWrapper.internalBinaryWrite(message.structWithListWithEmptyStruct, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct top_level_struct = 13; */
        if (message.topLevelStruct)
            Struct.internalBinaryWrite(message.topLevelStruct, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct top_level_struct_with_empty_list = 14; */
        if (message.topLevelStructWithEmptyList)
            Struct.internalBinaryWrite(message.topLevelStructWithEmptyList, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct top_level_struct_with_list_with_empty_struct = 15; */
        if (message.topLevelStructWithListWithEmptyStruct)
            Struct.internalBinaryWrite(message.topLevelStructWithListWithEmptyStruct, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueWrapper value_wrapper_simple = 16; */
        if (message.valueWrapperSimple)
            ValueWrapper.internalBinaryWrite(message.valueWrapperSimple, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueWrapper value_wrapper_with_struct = 17; */
        if (message.valueWrapperWithStruct)
            ValueWrapper.internalBinaryWrite(message.valueWrapperWithStruct, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueWrapper value_wrapper_with_list = 18; */
        if (message.valueWrapperWithList)
            ValueWrapper.internalBinaryWrite(message.valueWrapperWithList, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueWrapper value_wrapper_with_empty_list = 19; */
        if (message.valueWrapperWithEmptyList)
            ValueWrapper.internalBinaryWrite(message.valueWrapperWithEmptyList, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueWrapper value_wrapper_with_list_with_empty_struct = 20; */
        if (message.valueWrapperWithListWithEmptyStruct)
            ValueWrapper.internalBinaryWrite(message.valueWrapperWithListWithEmptyStruct, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ListValueWrapper list_value_wrapper = 21; */
        if (message.listValueWrapper)
            ListValueWrapper.internalBinaryWrite(message.listValueWrapper, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_empty_list = 22; */
        if (message.listValueWrapperWithEmptyList)
            ListValueWrapper.internalBinaryWrite(message.listValueWrapperWithEmptyList, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ListValueWrapper list_value_wrapper_with_list_with_empty_struct = 23; */
        if (message.listValueWrapperWithListWithEmptyStruct)
            ListValueWrapper.internalBinaryWrite(message.listValueWrapperWithListWithEmptyStruct, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_simple = 24; */
        if (message.topLevelValueSimple)
            Value.internalBinaryWrite(message.topLevelValueSimple, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_struct = 25; */
        if (message.topLevelValueWithStruct)
            Value.internalBinaryWrite(message.topLevelValueWithStruct, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_list = 26; */
        if (message.topLevelValueWithList)
            Value.internalBinaryWrite(message.topLevelValueWithList, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_empty_list = 27; */
        if (message.topLevelValueWithEmptyList)
            Value.internalBinaryWrite(message.topLevelValueWithEmptyList, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_list_with_empty_struct = 28; */
        if (message.topLevelValueWithListWithEmptyStruct)
            Value.internalBinaryWrite(message.topLevelValueWithListWithEmptyStruct, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.ListValue top_level_listvalue = 29; */
        if (message.topLevelListvalue)
            ListValue.internalBinaryWrite(message.topLevelListvalue, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.ListValue top_level_empty_listvalue = 30; */
        if (message.topLevelEmptyListvalue)
            ListValue.internalBinaryWrite(message.topLevelEmptyListvalue, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.ListValue top_level_listvalue_with_empty_struct = 31; */
        if (message.topLevelListvalueWithEmptyStruct)
            ListValue.internalBinaryWrite(message.topLevelListvalueWithEmptyStruct, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.RepeatedValueWrapper repeated_value = 32; */
        if (message.repeatedValue)
            RepeatedValueWrapper.internalBinaryWrite(message.repeatedValue, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list = 33; */
        if (message.repeatedValueNestedList)
            RepeatedValueWrapper.internalBinaryWrite(message.repeatedValueNestedList, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list2 = 34; */
        if (message.repeatedValueNestedList2)
            RepeatedValueWrapper.internalBinaryWrite(message.repeatedValueNestedList2, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.RepeatedValueWrapper repeated_value_nested_list3 = 35; */
        if (message.repeatedValueNestedList3)
            RepeatedValueWrapper.internalBinaryWrite(message.repeatedValueNestedList3, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.RepeatedListValueWrapper repeated_listvalue = 36; */
        if (message.repeatedListvalue)
            RepeatedListValueWrapper.internalBinaryWrite(message.repeatedListvalue, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MapOfStruct map_of_struct = 37; */
        if (message.mapOfStruct)
            MapOfStruct.internalBinaryWrite(message.mapOfStruct, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MapOfStruct map_of_struct_value = 38; */
        if (message.mapOfStructValue)
            MapOfStruct.internalBinaryWrite(message.mapOfStructValue, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MapOfStruct map_of_listvalue = 39; */
        if (message.mapOfListvalue)
            MapOfStruct.internalBinaryWrite(message.mapOfListvalue, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StructTestCases
 */
export const StructTestCases = new StructTestCases$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructWrapper$Type extends MessageType<StructWrapper> {
    constructor() {
        super("proto_util_converter.testing.StructWrapper", [
            { no: 1, name: "struct", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<StructWrapper>): StructWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StructWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StructWrapper): StructWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct struct */ 1:
                    message.struct = Struct.internalBinaryRead(reader, reader.uint32(), options, message.struct);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StructWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct struct = 1; */
        if (message.struct)
            Struct.internalBinaryWrite(message.struct, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StructWrapper
 */
export const StructWrapper = new StructWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValueWrapper$Type extends MessageType<ValueWrapper> {
    constructor() {
        super("proto_util_converter.testing.ValueWrapper", [
            { no: 1, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<ValueWrapper>): ValueWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ValueWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValueWrapper): ValueWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Value value */ 1:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValueWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Value value = 1; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.ValueWrapper
 */
export const ValueWrapper = new ValueWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedValueWrapper$Type extends MessageType<RepeatedValueWrapper> {
    constructor() {
        super("proto_util_converter.testing.RepeatedValueWrapper", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<RepeatedValueWrapper>): RepeatedValueWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<RepeatedValueWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedValueWrapper): RepeatedValueWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.Value values */ 1:
                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RepeatedValueWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.Value values = 1; */
        for (let i = 0; i < message.values.length; i++)
            Value.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.RepeatedValueWrapper
 */
export const RepeatedValueWrapper = new RepeatedValueWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListValueWrapper$Type extends MessageType<ListValueWrapper> {
    constructor() {
        super("proto_util_converter.testing.ListValueWrapper", [
            { no: 1, name: "shopping_list", kind: "message", T: () => ListValue }
        ]);
    }
    create(value?: PartialMessage<ListValueWrapper>): ListValueWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListValueWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListValueWrapper): ListValueWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.ListValue shopping_list */ 1:
                    message.shoppingList = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.shoppingList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListValueWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.ListValue shopping_list = 1; */
        if (message.shoppingList)
            ListValue.internalBinaryWrite(message.shoppingList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.ListValueWrapper
 */
export const ListValueWrapper = new ListValueWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedListValueWrapper$Type extends MessageType<RepeatedListValueWrapper> {
    constructor() {
        super("proto_util_converter.testing.RepeatedListValueWrapper", [
            { no: 1, name: "dimensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListValue }
        ]);
    }
    create(value?: PartialMessage<RepeatedListValueWrapper>): RepeatedListValueWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dimensions = [];
        if (value !== undefined)
            reflectionMergePartial<RepeatedListValueWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedListValueWrapper): RepeatedListValueWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.ListValue dimensions */ 1:
                    message.dimensions.push(ListValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RepeatedListValueWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.ListValue dimensions = 1; */
        for (let i = 0; i < message.dimensions.length; i++)
            ListValue.internalBinaryWrite(message.dimensions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.RepeatedListValueWrapper
 */
export const RepeatedListValueWrapper = new RepeatedListValueWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapOfStruct$Type extends MessageType<MapOfStruct> {
    constructor() {
        super("proto_util_converter.testing.MapOfStruct", [
            { no: 1, name: "struct_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 2, name: "value_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } },
            { no: 3, name: "listvalue_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ListValue } }
        ]);
    }
    create(value?: PartialMessage<MapOfStruct>): MapOfStruct {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.structMap = {};
        message.valueMap = {};
        message.listvalueMap = {};
        if (value !== undefined)
            reflectionMergePartial<MapOfStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapOfStruct): MapOfStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, google.protobuf.Struct> struct_map */ 1:
                    this.binaryReadMap1(message.structMap, reader, options);
                    break;
                case /* map<string, google.protobuf.Value> value_map */ 2:
                    this.binaryReadMap2(message.valueMap, reader, options);
                    break;
                case /* map<string, google.protobuf.ListValue> listvalue_map */ 3:
                    this.binaryReadMap3(message.listvalueMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MapOfStruct["structMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOfStruct["structMap"] | undefined, val: MapOfStruct["structMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOfStruct.struct_map");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    private binaryReadMap2(map: MapOfStruct["valueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOfStruct["valueMap"] | undefined, val: MapOfStruct["valueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOfStruct.value_map");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    private binaryReadMap3(map: MapOfStruct["listvalueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapOfStruct["listvalueMap"] | undefined, val: MapOfStruct["listvalueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ListValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MapOfStruct.listvalue_map");
            }
        }
        map[key ?? ""] = val ?? ListValue.create();
    }
    internalBinaryWrite(message: MapOfStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, google.protobuf.Struct> struct_map = 1; */
        for (let k of globalThis.Object.keys(message.structMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.structMap[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.Value> value_map = 2; */
        for (let k of globalThis.Object.keys(message.valueMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.valueMap[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.ListValue> listvalue_map = 3; */
        for (let k of globalThis.Object.keys(message.listvalueMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ListValue.internalBinaryWrite(message.listvalueMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MapOfStruct
 */
export const MapOfStruct = new MapOfStruct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Dummy$Type extends MessageType<Dummy> {
    constructor() {
        super("proto_util_converter.testing.Dummy", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Dummy>): Dummy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Dummy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dummy): Dummy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Dummy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.Dummy
 */
export const Dummy = new Dummy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructType$Type extends MessageType<StructType> {
    constructor() {
        super("proto_util_converter.testing.StructType", [
            { no: 1, name: "object", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<StructType>): StructType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StructType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StructType): StructType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct object */ 1:
                    message.object = Struct.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StructType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct object = 1; */
        if (message.object)
            Struct.internalBinaryWrite(message.object, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StructType
 */
export const StructType = new StructType$Type();
/**
 * @generated ServiceType for protobuf service proto_util_converter.testing.StructTestService
 */
export const StructTestService = new ServiceType("proto_util_converter.testing.StructTestService", [
    { name: "Call", options: {}, I: Dummy, O: StructTestCases }
]);
