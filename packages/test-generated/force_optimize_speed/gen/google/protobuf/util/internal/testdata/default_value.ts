// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/util/internal/testdata/default_value.proto" (package "proto_util_converter.testing", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DoubleValue } from "../../../wrappers";
import { Any } from "../../../any";
import { ListValue } from "../../../struct";
import { Value } from "../../../struct";
import { Struct } from "../../../struct";
/**
 * @generated from protobuf message proto_util_converter.testing.DefaultValueTestCases
 */
export interface DefaultValueTestCases {
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage empty_double = 1;
     */
    emptyDouble?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage double_with_default_value = 2;
     */
    doubleWithDefaultValue?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage double_with_nondefault_value = 3;
     */
    doubleWithNondefaultValue?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage repeated_double = 4;
     */
    repeatedDouble?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage nested_message = 5;
     */
    nestedMessage?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage repeated_nested_message = 6;
     */
    repeatedNestedMessage?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage double_message_with_oneof = 7;
     */
    doubleMessageWithOneof?: DoubleMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage empty_struct = 201;
     */
    emptyStruct?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage empty_struct2 = 202;
     */
    emptyStruct2?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_null_value = 203;
     */
    structWithNullValue?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_values = 204;
     */
    structWithValues?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_nested_struct = 205;
     */
    structWithNestedStruct?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_nested_list = 206;
     */
    structWithNestedList?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_list_of_nulls = 207;
     */
    structWithListOfNulls?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_list_of_lists = 208;
     */
    structWithListOfLists?: StructMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StructMessage struct_with_list_of_structs = 209;
     */
    structWithListOfStructs?: StructMessage;
    /**
     * @generated from protobuf field: google.protobuf.Struct top_level_struct = 210;
     */
    topLevelStruct?: Struct;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueMessage value_wrapper_simple = 212;
     */
    valueWrapperSimple?: ValueMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueMessage value_wrapper_with_struct = 213;
     */
    valueWrapperWithStruct?: ValueMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ValueMessage value_wrapper_with_list = 214;
     */
    valueWrapperWithList?: ValueMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.ListValueMessage list_value_wrapper = 215;
     */
    listValueWrapper?: ListValueMessage;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_simple = 216;
     */
    topLevelValueSimple?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_struct = 217;
     */
    topLevelValueWithStruct?: Value;
    /**
     * @generated from protobuf field: google.protobuf.Value top_level_value_with_list = 218;
     */
    topLevelValueWithList?: Value;
    /**
     * @generated from protobuf field: google.protobuf.ListValue top_level_listvalue = 219;
     */
    topLevelListvalue?: ListValue;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage empty_any = 301;
     */
    emptyAny?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage type_only_any = 302;
     */
    typeOnlyAny?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage recursive_any = 303;
     */
    recursiveAny?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage any_with_message_value = 304;
     */
    anyWithMessageValue?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage any_with_nested_message = 305;
     */
    anyWithNestedMessage?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage any_with_message_containing_map = 306;
     */
    anyWithMessageContainingMap?: AnyMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyMessage any_with_message_containing_struct = 307;
     */
    anyWithMessageContainingStruct?: AnyMessage;
    /**
     * @generated from protobuf field: google.protobuf.Any top_level_any = 308;
     */
    topLevelAny?: Any;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoIntMap empty_map = 401;
     */
    emptyMap?: StringtoIntMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.StringtoIntMap string_to_int = 402;
     */
    stringToInt?: StringtoIntMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.IntToStringMap int_to_string = 403;
     */
    intToString?: IntToStringMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MixedMap mixed1 = 404;
     */
    mixed1?: MixedMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MixedMap2 mixed2 = 405;
     */
    mixed2?: MixedMap2;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MixedMap2 empty_mixed2 = 406;
     */
    emptyMixed2?: MixedMap2;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MessageMap map_of_objects = 407;
     */
    mapOfObjects?: MessageMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MixedMap mixed_empty = 408;
     */
    mixedEmpty?: MixedMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.MessageMap message_map_empty = 409;
     */
    messageMapEmpty?: MessageMap;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleValueMessage double_value = 501;
     */
    doubleValue?: DoubleValueMessage;
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleValueMessage double_value_default = 502;
     */
    doubleValueDefault?: DoubleValueMessage;
}
/**
 * @generated from protobuf message proto_util_converter.testing.DoubleMessage
 */
export interface DoubleMessage {
    /**
     * @generated from protobuf field: double double_value = 1;
     */
    doubleValue: number;
    /**
     * @generated from protobuf field: repeated double repeated_double = 2;
     */
    repeatedDouble: number[];
    /**
     * @generated from protobuf field: proto_util_converter.testing.DoubleMessage nested_message = 3;
     */
    nestedMessage?: DoubleMessage;
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.DoubleMessage repeated_nested_message = 4;
     */
    repeatedNestedMessage: DoubleMessage[];
    /**
     * @generated from protobuf field: google.protobuf.DoubleValue double_wrapper = 100;
     */
    doubleWrapper?: DoubleValue;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "strValue";
        /**
         * @generated from protobuf field: string str_value = 112;
         */
        strValue: string;
    } | {
        oneofKind: "numValue";
        /**
         * @generated from protobuf field: int64 num_value = 113;
         */
        numValue: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.StructMessage
 */
export interface StructMessage {
    /**
     * @generated from protobuf field: google.protobuf.Struct struct = 1;
     */
    struct?: Struct;
}
/**
 * @generated from protobuf message proto_util_converter.testing.ValueMessage
 */
export interface ValueMessage {
    /**
     * @generated from protobuf field: google.protobuf.Value value = 1;
     */
    value?: Value;
}
/**
 * @generated from protobuf message proto_util_converter.testing.ListValueMessage
 */
export interface ListValueMessage {
    /**
     * @generated from protobuf field: google.protobuf.ListValue shopping_list = 1;
     */
    shoppingList?: ListValue;
}
/**
 * @generated from protobuf message proto_util_converter.testing.RequestMessage
 */
export interface RequestMessage {
    /**
     * @generated from protobuf field: string content = 1;
     */
    content: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.AnyMessage
 */
export interface AnyMessage {
    /**
     * @generated from protobuf field: google.protobuf.Any any = 1;
     */
    any?: Any;
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyData data = 2;
     */
    data?: AnyData;
}
/**
 * @generated from protobuf message proto_util_converter.testing.AnyData
 */
export interface AnyData {
    /**
     * @generated from protobuf field: int32 attr = 1;
     */
    attr: number;
    /**
     * @generated from protobuf field: string str = 2;
     */
    str: string;
    /**
     * @generated from protobuf field: repeated string msgs = 3;
     */
    msgs: string[];
    /**
     * @generated from protobuf field: proto_util_converter.testing.AnyData nested_data = 4;
     */
    nestedData?: AnyData;
    /**
     * @generated from protobuf field: map<string, string> map_data = 7;
     */
    mapData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: google.protobuf.Struct struct_data = 8;
     */
    structData?: Struct;
    /**
     * @generated from protobuf field: repeated proto_util_converter.testing.AnyData repeated_data = 9;
     */
    repeatedData: AnyData[];
}
/**
 * @generated from protobuf message proto_util_converter.testing.StringtoIntMap
 */
export interface StringtoIntMap {
    /**
     * @generated from protobuf field: map<string, int32> map = 1;
     */
    map: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.IntToStringMap
 */
export interface IntToStringMap {
    /**
     * @generated from protobuf field: map<int32, string> map = 1;
     */
    map: {
        [key: number]: string;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MixedMap
 */
export interface MixedMap {
    /**
     * @generated from protobuf field: string msg = 1;
     */
    msg: string;
    /**
     * @generated from protobuf field: map<string, float> map = 2;
     */
    map: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: int32 int_value = 3;
     */
    intValue: number;
}
/**
 * @generated from protobuf message proto_util_converter.testing.MixedMap2
 */
export interface MixedMap2 {
    /**
     * @generated from protobuf field: map<int32, bool> map = 1;
     */
    map: {
        [key: number]: boolean;
    };
    /**
     * @generated from protobuf field: proto_util_converter.testing.MixedMap2.E ee = 2;
     */
    ee: MixedMap2_E;
    /**
     * @generated from protobuf field: string msg = 4;
     */
    msg: string;
}
/**
 * @generated from protobuf enum proto_util_converter.testing.MixedMap2.E
 */
export enum MixedMap2_E {
    /**
     * @generated from protobuf enum value: E0 = 0;
     */
    E0 = 0,
    /**
     * @generated from protobuf enum value: E1 = 1;
     */
    E1 = 1,
    /**
     * @generated from protobuf enum value: E2 = 2;
     */
    E2 = 2,
    /**
     * @generated from protobuf enum value: E3 = 3;
     */
    E3 = 3
}
/**
 * @generated from protobuf message proto_util_converter.testing.MessageMap
 */
export interface MessageMap {
    /**
     * @generated from protobuf field: map<string, proto_util_converter.testing.MessageMap.M> map = 1;
     */
    map: {
        [key: string]: MessageMap_M;
    };
}
/**
 * @generated from protobuf message proto_util_converter.testing.MessageMap.M
 */
export interface MessageMap_M {
    /**
     * @generated from protobuf field: int32 inner_int = 1;
     */
    innerInt: number;
    /**
     * @generated from protobuf field: string inner_text = 2;
     */
    innerText: string;
}
/**
 * @generated from protobuf message proto_util_converter.testing.DoubleValueMessage
 */
export interface DoubleValueMessage {
    /**
     * @generated from protobuf field: google.protobuf.DoubleValue double = 1;
     */
    double?: DoubleValue;
}
// @generated message type with reflection information, may provide speed optimized methods
class DefaultValueTestCases$Type extends MessageType<DefaultValueTestCases> {
    constructor() {
        super("proto_util_converter.testing.DefaultValueTestCases", [
            { no: 1, name: "empty_double", kind: "message", T: () => DoubleMessage },
            { no: 2, name: "double_with_default_value", kind: "message", T: () => DoubleMessage },
            { no: 3, name: "double_with_nondefault_value", kind: "message", T: () => DoubleMessage },
            { no: 4, name: "repeated_double", kind: "message", T: () => DoubleMessage },
            { no: 5, name: "nested_message", kind: "message", T: () => DoubleMessage },
            { no: 6, name: "repeated_nested_message", kind: "message", T: () => DoubleMessage },
            { no: 7, name: "double_message_with_oneof", kind: "message", T: () => DoubleMessage },
            { no: 201, name: "empty_struct", kind: "message", T: () => StructMessage },
            { no: 202, name: "empty_struct2", kind: "message", T: () => StructMessage },
            { no: 203, name: "struct_with_null_value", kind: "message", T: () => StructMessage },
            { no: 204, name: "struct_with_values", kind: "message", T: () => StructMessage },
            { no: 205, name: "struct_with_nested_struct", kind: "message", T: () => StructMessage },
            { no: 206, name: "struct_with_nested_list", kind: "message", T: () => StructMessage },
            { no: 207, name: "struct_with_list_of_nulls", kind: "message", T: () => StructMessage },
            { no: 208, name: "struct_with_list_of_lists", kind: "message", T: () => StructMessage },
            { no: 209, name: "struct_with_list_of_structs", kind: "message", T: () => StructMessage },
            { no: 210, name: "top_level_struct", kind: "message", T: () => Struct },
            { no: 212, name: "value_wrapper_simple", kind: "message", T: () => ValueMessage },
            { no: 213, name: "value_wrapper_with_struct", kind: "message", T: () => ValueMessage },
            { no: 214, name: "value_wrapper_with_list", kind: "message", T: () => ValueMessage },
            { no: 215, name: "list_value_wrapper", kind: "message", T: () => ListValueMessage },
            { no: 216, name: "top_level_value_simple", kind: "message", T: () => Value },
            { no: 217, name: "top_level_value_with_struct", kind: "message", T: () => Value },
            { no: 218, name: "top_level_value_with_list", kind: "message", T: () => Value },
            { no: 219, name: "top_level_listvalue", kind: "message", T: () => ListValue },
            { no: 301, name: "empty_any", kind: "message", T: () => AnyMessage },
            { no: 302, name: "type_only_any", kind: "message", T: () => AnyMessage },
            { no: 303, name: "recursive_any", kind: "message", T: () => AnyMessage },
            { no: 304, name: "any_with_message_value", kind: "message", T: () => AnyMessage },
            { no: 305, name: "any_with_nested_message", kind: "message", T: () => AnyMessage },
            { no: 306, name: "any_with_message_containing_map", kind: "message", T: () => AnyMessage },
            { no: 307, name: "any_with_message_containing_struct", kind: "message", T: () => AnyMessage },
            { no: 308, name: "top_level_any", kind: "message", T: () => Any },
            { no: 401, name: "empty_map", kind: "message", T: () => StringtoIntMap },
            { no: 402, name: "string_to_int", kind: "message", T: () => StringtoIntMap },
            { no: 403, name: "int_to_string", kind: "message", T: () => IntToStringMap },
            { no: 404, name: "mixed1", kind: "message", T: () => MixedMap },
            { no: 405, name: "mixed2", kind: "message", T: () => MixedMap2 },
            { no: 406, name: "empty_mixed2", kind: "message", T: () => MixedMap2 },
            { no: 407, name: "map_of_objects", kind: "message", T: () => MessageMap },
            { no: 408, name: "mixed_empty", kind: "message", T: () => MixedMap },
            { no: 409, name: "message_map_empty", kind: "message", T: () => MessageMap },
            { no: 501, name: "double_value", kind: "message", T: () => DoubleValueMessage },
            { no: 502, name: "double_value_default", kind: "message", T: () => DoubleValueMessage }
        ]);
    }
    create(value?: PartialMessage<DefaultValueTestCases>): DefaultValueTestCases {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DefaultValueTestCases>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DefaultValueTestCases): DefaultValueTestCases {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto_util_converter.testing.DoubleMessage empty_double */ 1:
                    message.emptyDouble = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.emptyDouble);
                    break;
                case /* proto_util_converter.testing.DoubleMessage double_with_default_value */ 2:
                    message.doubleWithDefaultValue = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.doubleWithDefaultValue);
                    break;
                case /* proto_util_converter.testing.DoubleMessage double_with_nondefault_value */ 3:
                    message.doubleWithNondefaultValue = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.doubleWithNondefaultValue);
                    break;
                case /* proto_util_converter.testing.DoubleMessage repeated_double */ 4:
                    message.repeatedDouble = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.repeatedDouble);
                    break;
                case /* proto_util_converter.testing.DoubleMessage nested_message */ 5:
                    message.nestedMessage = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.nestedMessage);
                    break;
                case /* proto_util_converter.testing.DoubleMessage repeated_nested_message */ 6:
                    message.repeatedNestedMessage = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.repeatedNestedMessage);
                    break;
                case /* proto_util_converter.testing.DoubleMessage double_message_with_oneof */ 7:
                    message.doubleMessageWithOneof = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.doubleMessageWithOneof);
                    break;
                case /* proto_util_converter.testing.StructMessage empty_struct */ 201:
                    message.emptyStruct = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.emptyStruct);
                    break;
                case /* proto_util_converter.testing.StructMessage empty_struct2 */ 202:
                    message.emptyStruct2 = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.emptyStruct2);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_null_value */ 203:
                    message.structWithNullValue = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithNullValue);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_values */ 204:
                    message.structWithValues = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithValues);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_nested_struct */ 205:
                    message.structWithNestedStruct = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithNestedStruct);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_nested_list */ 206:
                    message.structWithNestedList = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithNestedList);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_list_of_nulls */ 207:
                    message.structWithListOfNulls = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfNulls);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_list_of_lists */ 208:
                    message.structWithListOfLists = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfLists);
                    break;
                case /* proto_util_converter.testing.StructMessage struct_with_list_of_structs */ 209:
                    message.structWithListOfStructs = StructMessage.internalBinaryRead(reader, reader.uint32(), options, message.structWithListOfStructs);
                    break;
                case /* google.protobuf.Struct top_level_struct */ 210:
                    message.topLevelStruct = Struct.internalBinaryRead(reader, reader.uint32(), options, message.topLevelStruct);
                    break;
                case /* proto_util_converter.testing.ValueMessage value_wrapper_simple */ 212:
                    message.valueWrapperSimple = ValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperSimple);
                    break;
                case /* proto_util_converter.testing.ValueMessage value_wrapper_with_struct */ 213:
                    message.valueWrapperWithStruct = ValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithStruct);
                    break;
                case /* proto_util_converter.testing.ValueMessage value_wrapper_with_list */ 214:
                    message.valueWrapperWithList = ValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.valueWrapperWithList);
                    break;
                case /* proto_util_converter.testing.ListValueMessage list_value_wrapper */ 215:
                    message.listValueWrapper = ListValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.listValueWrapper);
                    break;
                case /* google.protobuf.Value top_level_value_simple */ 216:
                    message.topLevelValueSimple = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueSimple);
                    break;
                case /* google.protobuf.Value top_level_value_with_struct */ 217:
                    message.topLevelValueWithStruct = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithStruct);
                    break;
                case /* google.protobuf.Value top_level_value_with_list */ 218:
                    message.topLevelValueWithList = Value.internalBinaryRead(reader, reader.uint32(), options, message.topLevelValueWithList);
                    break;
                case /* google.protobuf.ListValue top_level_listvalue */ 219:
                    message.topLevelListvalue = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.topLevelListvalue);
                    break;
                case /* proto_util_converter.testing.AnyMessage empty_any */ 301:
                    message.emptyAny = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.emptyAny);
                    break;
                case /* proto_util_converter.testing.AnyMessage type_only_any */ 302:
                    message.typeOnlyAny = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.typeOnlyAny);
                    break;
                case /* proto_util_converter.testing.AnyMessage recursive_any */ 303:
                    message.recursiveAny = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.recursiveAny);
                    break;
                case /* proto_util_converter.testing.AnyMessage any_with_message_value */ 304:
                    message.anyWithMessageValue = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.anyWithMessageValue);
                    break;
                case /* proto_util_converter.testing.AnyMessage any_with_nested_message */ 305:
                    message.anyWithNestedMessage = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.anyWithNestedMessage);
                    break;
                case /* proto_util_converter.testing.AnyMessage any_with_message_containing_map */ 306:
                    message.anyWithMessageContainingMap = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.anyWithMessageContainingMap);
                    break;
                case /* proto_util_converter.testing.AnyMessage any_with_message_containing_struct */ 307:
                    message.anyWithMessageContainingStruct = AnyMessage.internalBinaryRead(reader, reader.uint32(), options, message.anyWithMessageContainingStruct);
                    break;
                case /* google.protobuf.Any top_level_any */ 308:
                    message.topLevelAny = Any.internalBinaryRead(reader, reader.uint32(), options, message.topLevelAny);
                    break;
                case /* proto_util_converter.testing.StringtoIntMap empty_map */ 401:
                    message.emptyMap = StringtoIntMap.internalBinaryRead(reader, reader.uint32(), options, message.emptyMap);
                    break;
                case /* proto_util_converter.testing.StringtoIntMap string_to_int */ 402:
                    message.stringToInt = StringtoIntMap.internalBinaryRead(reader, reader.uint32(), options, message.stringToInt);
                    break;
                case /* proto_util_converter.testing.IntToStringMap int_to_string */ 403:
                    message.intToString = IntToStringMap.internalBinaryRead(reader, reader.uint32(), options, message.intToString);
                    break;
                case /* proto_util_converter.testing.MixedMap mixed1 */ 404:
                    message.mixed1 = MixedMap.internalBinaryRead(reader, reader.uint32(), options, message.mixed1);
                    break;
                case /* proto_util_converter.testing.MixedMap2 mixed2 */ 405:
                    message.mixed2 = MixedMap2.internalBinaryRead(reader, reader.uint32(), options, message.mixed2);
                    break;
                case /* proto_util_converter.testing.MixedMap2 empty_mixed2 */ 406:
                    message.emptyMixed2 = MixedMap2.internalBinaryRead(reader, reader.uint32(), options, message.emptyMixed2);
                    break;
                case /* proto_util_converter.testing.MessageMap map_of_objects */ 407:
                    message.mapOfObjects = MessageMap.internalBinaryRead(reader, reader.uint32(), options, message.mapOfObjects);
                    break;
                case /* proto_util_converter.testing.MixedMap mixed_empty */ 408:
                    message.mixedEmpty = MixedMap.internalBinaryRead(reader, reader.uint32(), options, message.mixedEmpty);
                    break;
                case /* proto_util_converter.testing.MessageMap message_map_empty */ 409:
                    message.messageMapEmpty = MessageMap.internalBinaryRead(reader, reader.uint32(), options, message.messageMapEmpty);
                    break;
                case /* proto_util_converter.testing.DoubleValueMessage double_value */ 501:
                    message.doubleValue = DoubleValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.doubleValue);
                    break;
                case /* proto_util_converter.testing.DoubleValueMessage double_value_default */ 502:
                    message.doubleValueDefault = DoubleValueMessage.internalBinaryRead(reader, reader.uint32(), options, message.doubleValueDefault);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DefaultValueTestCases, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto_util_converter.testing.DoubleMessage empty_double = 1; */
        if (message.emptyDouble)
            DoubleMessage.internalBinaryWrite(message.emptyDouble, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage double_with_default_value = 2; */
        if (message.doubleWithDefaultValue)
            DoubleMessage.internalBinaryWrite(message.doubleWithDefaultValue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage double_with_nondefault_value = 3; */
        if (message.doubleWithNondefaultValue)
            DoubleMessage.internalBinaryWrite(message.doubleWithNondefaultValue, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage repeated_double = 4; */
        if (message.repeatedDouble)
            DoubleMessage.internalBinaryWrite(message.repeatedDouble, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage nested_message = 5; */
        if (message.nestedMessage)
            DoubleMessage.internalBinaryWrite(message.nestedMessage, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage repeated_nested_message = 6; */
        if (message.repeatedNestedMessage)
            DoubleMessage.internalBinaryWrite(message.repeatedNestedMessage, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleMessage double_message_with_oneof = 7; */
        if (message.doubleMessageWithOneof)
            DoubleMessage.internalBinaryWrite(message.doubleMessageWithOneof, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage empty_struct = 201; */
        if (message.emptyStruct)
            StructMessage.internalBinaryWrite(message.emptyStruct, writer.tag(201, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage empty_struct2 = 202; */
        if (message.emptyStruct2)
            StructMessage.internalBinaryWrite(message.emptyStruct2, writer.tag(202, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_null_value = 203; */
        if (message.structWithNullValue)
            StructMessage.internalBinaryWrite(message.structWithNullValue, writer.tag(203, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_values = 204; */
        if (message.structWithValues)
            StructMessage.internalBinaryWrite(message.structWithValues, writer.tag(204, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_nested_struct = 205; */
        if (message.structWithNestedStruct)
            StructMessage.internalBinaryWrite(message.structWithNestedStruct, writer.tag(205, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_nested_list = 206; */
        if (message.structWithNestedList)
            StructMessage.internalBinaryWrite(message.structWithNestedList, writer.tag(206, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_list_of_nulls = 207; */
        if (message.structWithListOfNulls)
            StructMessage.internalBinaryWrite(message.structWithListOfNulls, writer.tag(207, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_list_of_lists = 208; */
        if (message.structWithListOfLists)
            StructMessage.internalBinaryWrite(message.structWithListOfLists, writer.tag(208, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StructMessage struct_with_list_of_structs = 209; */
        if (message.structWithListOfStructs)
            StructMessage.internalBinaryWrite(message.structWithListOfStructs, writer.tag(209, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct top_level_struct = 210; */
        if (message.topLevelStruct)
            Struct.internalBinaryWrite(message.topLevelStruct, writer.tag(210, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueMessage value_wrapper_simple = 212; */
        if (message.valueWrapperSimple)
            ValueMessage.internalBinaryWrite(message.valueWrapperSimple, writer.tag(212, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueMessage value_wrapper_with_struct = 213; */
        if (message.valueWrapperWithStruct)
            ValueMessage.internalBinaryWrite(message.valueWrapperWithStruct, writer.tag(213, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ValueMessage value_wrapper_with_list = 214; */
        if (message.valueWrapperWithList)
            ValueMessage.internalBinaryWrite(message.valueWrapperWithList, writer.tag(214, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.ListValueMessage list_value_wrapper = 215; */
        if (message.listValueWrapper)
            ListValueMessage.internalBinaryWrite(message.listValueWrapper, writer.tag(215, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_simple = 216; */
        if (message.topLevelValueSimple)
            Value.internalBinaryWrite(message.topLevelValueSimple, writer.tag(216, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_struct = 217; */
        if (message.topLevelValueWithStruct)
            Value.internalBinaryWrite(message.topLevelValueWithStruct, writer.tag(217, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Value top_level_value_with_list = 218; */
        if (message.topLevelValueWithList)
            Value.internalBinaryWrite(message.topLevelValueWithList, writer.tag(218, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.ListValue top_level_listvalue = 219; */
        if (message.topLevelListvalue)
            ListValue.internalBinaryWrite(message.topLevelListvalue, writer.tag(219, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage empty_any = 301; */
        if (message.emptyAny)
            AnyMessage.internalBinaryWrite(message.emptyAny, writer.tag(301, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage type_only_any = 302; */
        if (message.typeOnlyAny)
            AnyMessage.internalBinaryWrite(message.typeOnlyAny, writer.tag(302, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage recursive_any = 303; */
        if (message.recursiveAny)
            AnyMessage.internalBinaryWrite(message.recursiveAny, writer.tag(303, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage any_with_message_value = 304; */
        if (message.anyWithMessageValue)
            AnyMessage.internalBinaryWrite(message.anyWithMessageValue, writer.tag(304, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage any_with_nested_message = 305; */
        if (message.anyWithNestedMessage)
            AnyMessage.internalBinaryWrite(message.anyWithNestedMessage, writer.tag(305, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage any_with_message_containing_map = 306; */
        if (message.anyWithMessageContainingMap)
            AnyMessage.internalBinaryWrite(message.anyWithMessageContainingMap, writer.tag(306, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyMessage any_with_message_containing_struct = 307; */
        if (message.anyWithMessageContainingStruct)
            AnyMessage.internalBinaryWrite(message.anyWithMessageContainingStruct, writer.tag(307, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any top_level_any = 308; */
        if (message.topLevelAny)
            Any.internalBinaryWrite(message.topLevelAny, writer.tag(308, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoIntMap empty_map = 401; */
        if (message.emptyMap)
            StringtoIntMap.internalBinaryWrite(message.emptyMap, writer.tag(401, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.StringtoIntMap string_to_int = 402; */
        if (message.stringToInt)
            StringtoIntMap.internalBinaryWrite(message.stringToInt, writer.tag(402, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.IntToStringMap int_to_string = 403; */
        if (message.intToString)
            IntToStringMap.internalBinaryWrite(message.intToString, writer.tag(403, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MixedMap mixed1 = 404; */
        if (message.mixed1)
            MixedMap.internalBinaryWrite(message.mixed1, writer.tag(404, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MixedMap2 mixed2 = 405; */
        if (message.mixed2)
            MixedMap2.internalBinaryWrite(message.mixed2, writer.tag(405, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MixedMap2 empty_mixed2 = 406; */
        if (message.emptyMixed2)
            MixedMap2.internalBinaryWrite(message.emptyMixed2, writer.tag(406, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MessageMap map_of_objects = 407; */
        if (message.mapOfObjects)
            MessageMap.internalBinaryWrite(message.mapOfObjects, writer.tag(407, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MixedMap mixed_empty = 408; */
        if (message.mixedEmpty)
            MixedMap.internalBinaryWrite(message.mixedEmpty, writer.tag(408, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.MessageMap message_map_empty = 409; */
        if (message.messageMapEmpty)
            MessageMap.internalBinaryWrite(message.messageMapEmpty, writer.tag(409, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleValueMessage double_value = 501; */
        if (message.doubleValue)
            DoubleValueMessage.internalBinaryWrite(message.doubleValue, writer.tag(501, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.DoubleValueMessage double_value_default = 502; */
        if (message.doubleValueDefault)
            DoubleValueMessage.internalBinaryWrite(message.doubleValueDefault, writer.tag(502, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.DefaultValueTestCases
 */
export const DefaultValueTestCases = new DefaultValueTestCases$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleMessage$Type extends MessageType<DoubleMessage> {
    constructor() {
        super("proto_util_converter.testing.DoubleMessage", [
            { no: 1, name: "double_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "repeated_double", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "nested_message", kind: "message", T: () => DoubleMessage },
            { no: 4, name: "repeated_nested_message", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DoubleMessage },
            { no: 100, name: "double_wrapper", kind: "message", T: () => DoubleValue },
            { no: 112, name: "str_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 113, name: "num_value", kind: "scalar", oneof: "value", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<DoubleMessage>): DoubleMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doubleValue = 0;
        message.repeatedDouble = [];
        message.repeatedNestedMessage = [];
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DoubleMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleMessage): DoubleMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double double_value */ 1:
                    message.doubleValue = reader.double();
                    break;
                case /* repeated double repeated_double */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedDouble.push(reader.double());
                    else
                        message.repeatedDouble.push(reader.double());
                    break;
                case /* proto_util_converter.testing.DoubleMessage nested_message */ 3:
                    message.nestedMessage = DoubleMessage.internalBinaryRead(reader, reader.uint32(), options, message.nestedMessage);
                    break;
                case /* repeated proto_util_converter.testing.DoubleMessage repeated_nested_message */ 4:
                    message.repeatedNestedMessage.push(DoubleMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.DoubleValue double_wrapper */ 100:
                    message.doubleWrapper = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.doubleWrapper);
                    break;
                case /* string str_value */ 112:
                    message.value = {
                        oneofKind: "strValue",
                        strValue: reader.string()
                    };
                    break;
                case /* int64 num_value */ 113:
                    message.value = {
                        oneofKind: "numValue",
                        numValue: reader.int64().toString()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double double_value = 1; */
        if (message.doubleValue !== 0)
            writer.tag(1, WireType.Bit64).double(message.doubleValue);
        /* repeated double repeated_double = 2; */
        if (message.repeatedDouble.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedDouble.length; i++)
                writer.double(message.repeatedDouble[i]);
            writer.join();
        }
        /* proto_util_converter.testing.DoubleMessage nested_message = 3; */
        if (message.nestedMessage)
            DoubleMessage.internalBinaryWrite(message.nestedMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto_util_converter.testing.DoubleMessage repeated_nested_message = 4; */
        for (let i = 0; i < message.repeatedNestedMessage.length; i++)
            DoubleMessage.internalBinaryWrite(message.repeatedNestedMessage[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.DoubleValue double_wrapper = 100; */
        if (message.doubleWrapper)
            DoubleValue.internalBinaryWrite(message.doubleWrapper, writer.tag(100, WireType.LengthDelimited).fork(), options).join();
        /* string str_value = 112; */
        if (message.value.oneofKind === "strValue")
            writer.tag(112, WireType.LengthDelimited).string(message.value.strValue);
        /* int64 num_value = 113; */
        if (message.value.oneofKind === "numValue")
            writer.tag(113, WireType.Varint).int64(message.value.numValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.DoubleMessage
 */
export const DoubleMessage = new DoubleMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructMessage$Type extends MessageType<StructMessage> {
    constructor() {
        super("proto_util_converter.testing.StructMessage", [
            { no: 1, name: "struct", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<StructMessage>): StructMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StructMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StructMessage): StructMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct struct */ 1:
                    message.struct = Struct.internalBinaryRead(reader, reader.uint32(), options, message.struct);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StructMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct struct = 1; */
        if (message.struct)
            Struct.internalBinaryWrite(message.struct, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StructMessage
 */
export const StructMessage = new StructMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValueMessage$Type extends MessageType<ValueMessage> {
    constructor() {
        super("proto_util_converter.testing.ValueMessage", [
            { no: 1, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<ValueMessage>): ValueMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ValueMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValueMessage): ValueMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Value value */ 1:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValueMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Value value = 1; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.ValueMessage
 */
export const ValueMessage = new ValueMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListValueMessage$Type extends MessageType<ListValueMessage> {
    constructor() {
        super("proto_util_converter.testing.ListValueMessage", [
            { no: 1, name: "shopping_list", kind: "message", T: () => ListValue }
        ]);
    }
    create(value?: PartialMessage<ListValueMessage>): ListValueMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListValueMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListValueMessage): ListValueMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.ListValue shopping_list */ 1:
                    message.shoppingList = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.shoppingList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListValueMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.ListValue shopping_list = 1; */
        if (message.shoppingList)
            ListValue.internalBinaryWrite(message.shoppingList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.ListValueMessage
 */
export const ListValueMessage = new ListValueMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestMessage$Type extends MessageType<RequestMessage> {
    constructor() {
        super("proto_util_converter.testing.RequestMessage", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestMessage>): RequestMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.content = "";
        if (value !== undefined)
            reflectionMergePartial<RequestMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestMessage): RequestMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.RequestMessage
 */
export const RequestMessage = new RequestMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnyMessage$Type extends MessageType<AnyMessage> {
    constructor() {
        super("proto_util_converter.testing.AnyMessage", [
            { no: 1, name: "any", kind: "message", T: () => Any },
            { no: 2, name: "data", kind: "message", T: () => AnyData }
        ]);
    }
    create(value?: PartialMessage<AnyMessage>): AnyMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AnyMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnyMessage): AnyMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any any */ 1:
                    message.any = Any.internalBinaryRead(reader, reader.uint32(), options, message.any);
                    break;
                case /* proto_util_converter.testing.AnyData data */ 2:
                    message.data = AnyData.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnyMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any any = 1; */
        if (message.any)
            Any.internalBinaryWrite(message.any, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto_util_converter.testing.AnyData data = 2; */
        if (message.data)
            AnyData.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.AnyMessage
 */
export const AnyMessage = new AnyMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnyData$Type extends MessageType<AnyData> {
    constructor() {
        super("proto_util_converter.testing.AnyData", [
            { no: 1, name: "attr", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "str", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "msgs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "nested_data", kind: "message", T: () => AnyData },
            { no: 7, name: "map_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "struct_data", kind: "message", T: () => Struct },
            { no: 9, name: "repeated_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnyData }
        ]);
    }
    create(value?: PartialMessage<AnyData>): AnyData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attr = 0;
        message.str = "";
        message.msgs = [];
        message.mapData = {};
        message.repeatedData = [];
        if (value !== undefined)
            reflectionMergePartial<AnyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnyData): AnyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 attr */ 1:
                    message.attr = reader.int32();
                    break;
                case /* string str */ 2:
                    message.str = reader.string();
                    break;
                case /* repeated string msgs */ 3:
                    message.msgs.push(reader.string());
                    break;
                case /* proto_util_converter.testing.AnyData nested_data */ 4:
                    message.nestedData = AnyData.internalBinaryRead(reader, reader.uint32(), options, message.nestedData);
                    break;
                case /* map<string, string> map_data */ 7:
                    this.binaryReadMap7(message.mapData, reader, options);
                    break;
                case /* google.protobuf.Struct struct_data */ 8:
                    message.structData = Struct.internalBinaryRead(reader, reader.uint32(), options, message.structData);
                    break;
                case /* repeated proto_util_converter.testing.AnyData repeated_data */ 9:
                    message.repeatedData.push(AnyData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: AnyData["mapData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AnyData["mapData"] | undefined, val: AnyData["mapData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.AnyData.map_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AnyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 attr = 1; */
        if (message.attr !== 0)
            writer.tag(1, WireType.Varint).int32(message.attr);
        /* string str = 2; */
        if (message.str !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.str);
        /* repeated string msgs = 3; */
        for (let i = 0; i < message.msgs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.msgs[i]);
        /* proto_util_converter.testing.AnyData nested_data = 4; */
        if (message.nestedData)
            AnyData.internalBinaryWrite(message.nestedData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> map_data = 7; */
        for (let k of globalThis.Object.keys(message.mapData))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapData[k]).join();
        /* google.protobuf.Struct struct_data = 8; */
        if (message.structData)
            Struct.internalBinaryWrite(message.structData, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto_util_converter.testing.AnyData repeated_data = 9; */
        for (let i = 0; i < message.repeatedData.length; i++)
            AnyData.internalBinaryWrite(message.repeatedData[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.AnyData
 */
export const AnyData = new AnyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringtoIntMap$Type extends MessageType<StringtoIntMap> {
    constructor() {
        super("proto_util_converter.testing.StringtoIntMap", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<StringtoIntMap>): StringtoIntMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<StringtoIntMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringtoIntMap): StringtoIntMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int32> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: StringtoIntMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StringtoIntMap["map"] | undefined, val: StringtoIntMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.StringtoIntMap.map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: StringtoIntMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int32> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.map[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.StringtoIntMap
 */
export const StringtoIntMap = new StringtoIntMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntToStringMap$Type extends MessageType<IntToStringMap> {
    constructor() {
        super("proto_util_converter.testing.IntToStringMap", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<IntToStringMap>): IntToStringMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<IntToStringMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntToStringMap): IntToStringMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, string> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: IntToStringMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof IntToStringMap["map"] | undefined, val: IntToStringMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.IntToStringMap.map");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    internalBinaryWrite(message: IntToStringMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, string> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.map[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.IntToStringMap
 */
export const IntToStringMap = new IntToStringMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MixedMap$Type extends MessageType<MixedMap> {
    constructor() {
        super("proto_util_converter.testing.MixedMap", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 3, name: "int_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MixedMap>): MixedMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msg = "";
        message.map = {};
        message.intValue = 0;
        if (value !== undefined)
            reflectionMergePartial<MixedMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MixedMap): MixedMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* map<string, float> map */ 2:
                    this.binaryReadMap2(message.map, reader, options);
                    break;
                case /* int32 int_value */ 3:
                    message.intValue = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: MixedMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MixedMap["map"] | undefined, val: MixedMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MixedMap.map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: MixedMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* map<string, float> map = 2; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.map[k]).join();
        /* int32 int_value = 3; */
        if (message.intValue !== 0)
            writer.tag(3, WireType.Varint).int32(message.intValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MixedMap
 */
export const MixedMap = new MixedMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MixedMap2$Type extends MessageType<MixedMap2> {
    constructor() {
        super("proto_util_converter.testing.MixedMap2", [
            { no: 1, name: "map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 2, name: "ee", kind: "enum", T: () => ["proto_util_converter.testing.MixedMap2.E", MixedMap2_E] },
            { no: 4, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MixedMap2>): MixedMap2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        message.ee = 0;
        message.msg = "";
        if (value !== undefined)
            reflectionMergePartial<MixedMap2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MixedMap2): MixedMap2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, bool> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                case /* proto_util_converter.testing.MixedMap2.E ee */ 2:
                    message.ee = reader.int32();
                    break;
                case /* string msg */ 4:
                    message.msg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MixedMap2["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MixedMap2["map"] | undefined, val: MixedMap2["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MixedMap2.map");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: MixedMap2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, bool> map = 1; */
        for (let k of globalThis.Object.keys(message.map))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.map[k as any]).join();
        /* proto_util_converter.testing.MixedMap2.E ee = 2; */
        if (message.ee !== 0)
            writer.tag(2, WireType.Varint).int32(message.ee);
        /* string msg = 4; */
        if (message.msg !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MixedMap2
 */
export const MixedMap2 = new MixedMap2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageMap$Type extends MessageType<MessageMap> {
    constructor() {
        super("proto_util_converter.testing.MessageMap", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MessageMap_M } }
        ]);
    }
    create(value?: PartialMessage<MessageMap>): MessageMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<MessageMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageMap): MessageMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, proto_util_converter.testing.MessageMap.M> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MessageMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MessageMap["map"] | undefined, val: MessageMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MessageMap_M.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto_util_converter.testing.MessageMap.map");
            }
        }
        map[key ?? ""] = val ?? MessageMap_M.create();
    }
    internalBinaryWrite(message: MessageMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, proto_util_converter.testing.MessageMap.M> map = 1; */
        for (let k of globalThis.Object.keys(message.map)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MessageMap_M.internalBinaryWrite(message.map[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MessageMap
 */
export const MessageMap = new MessageMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageMap_M$Type extends MessageType<MessageMap_M> {
    constructor() {
        super("proto_util_converter.testing.MessageMap.M", [
            { no: 1, name: "inner_int", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "inner_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageMap_M>): MessageMap_M {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.innerInt = 0;
        message.innerText = "";
        if (value !== undefined)
            reflectionMergePartial<MessageMap_M>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageMap_M): MessageMap_M {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 inner_int */ 1:
                    message.innerInt = reader.int32();
                    break;
                case /* string inner_text */ 2:
                    message.innerText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageMap_M, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 inner_int = 1; */
        if (message.innerInt !== 0)
            writer.tag(1, WireType.Varint).int32(message.innerInt);
        /* string inner_text = 2; */
        if (message.innerText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.innerText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.MessageMap.M
 */
export const MessageMap_M = new MessageMap_M$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleValueMessage$Type extends MessageType<DoubleValueMessage> {
    constructor() {
        super("proto_util_converter.testing.DoubleValueMessage", [
            { no: 1, name: "double", kind: "message", T: () => DoubleValue }
        ]);
    }
    create(value?: PartialMessage<DoubleValueMessage>): DoubleValueMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DoubleValueMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleValueMessage): DoubleValueMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.DoubleValue double */ 1:
                    message.double = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.double);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleValueMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.DoubleValue double = 1; */
        if (message.double)
            DoubleValue.internalBinaryWrite(message.double, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto_util_converter.testing.DoubleValueMessage
 */
export const DoubleValueMessage = new DoubleValueMessage$Type();
/**
 * @generated ServiceType for protobuf service proto_util_converter.testing.DefaultValueTestService
 */
export const DefaultValueTestService = new ServiceType("proto_util_converter.testing.DefaultValueTestService", [
    { name: "Call", options: {}, I: RequestMessage, O: DefaultValueTestCases }
]);
