// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/util/json_format_proto3.proto" (package "proto3", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
import { TestAllExtensions } from "../unittest";
import { ListValue } from "../struct";
import { Value } from "../struct";
import { Any } from "../any";
import { Struct } from "../struct";
import { FieldMask } from "../field_mask";
import { Duration } from "../duration";
import { Timestamp } from "../timestamp";
import { BytesValue } from "../wrappers";
import { StringValue } from "../wrappers";
import { DoubleValue } from "../wrappers";
import { FloatValue } from "../wrappers";
import { UInt64Value } from "../wrappers";
import { UInt32Value } from "../wrappers";
import { Int64Value } from "../wrappers";
import { Int32Value } from "../wrappers";
import { BoolValue } from "../wrappers";
/**
 * @generated from protobuf message proto3.MessageType
 */
export interface MessageType {
    /**
     * @generated from protobuf field: int32 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message proto3.TestMessage
 */
export interface TestMessage {
    /**
     * @generated from protobuf field: bool bool_value = 1;
     */
    boolValue: boolean;
    /**
     * @generated from protobuf field: int32 int32_value = 2;
     */
    int32Value: number;
    /**
     * @generated from protobuf field: int64 int64_value = 3;
     */
    int64Value: string;
    /**
     * @generated from protobuf field: uint32 uint32_value = 4;
     */
    uint32Value: number;
    /**
     * @generated from protobuf field: uint64 uint64_value = 5;
     */
    uint64Value: string;
    /**
     * @generated from protobuf field: float float_value = 6;
     */
    floatValue: number;
    /**
     * @generated from protobuf field: double double_value = 7;
     */
    doubleValue: number;
    /**
     * @generated from protobuf field: string string_value = 8;
     */
    stringValue: string;
    /**
     * @generated from protobuf field: bytes bytes_value = 9;
     */
    bytesValue: Uint8Array;
    /**
     * @generated from protobuf field: proto3.EnumType enum_value = 10;
     */
    enumValue: EnumType;
    /**
     * @generated from protobuf field: proto3.MessageType message_value = 11;
     */
    messageValue?: MessageType;
    /**
     * @generated from protobuf field: repeated bool repeated_bool_value = 21;
     */
    repeatedBoolValue: boolean[];
    /**
     * @generated from protobuf field: repeated int32 repeated_int32_value = 22;
     */
    repeatedInt32Value: number[];
    /**
     * @generated from protobuf field: repeated int64 repeated_int64_value = 23;
     */
    repeatedInt64Value: string[];
    /**
     * @generated from protobuf field: repeated uint32 repeated_uint32_value = 24;
     */
    repeatedUint32Value: number[];
    /**
     * @generated from protobuf field: repeated uint64 repeated_uint64_value = 25;
     */
    repeatedUint64Value: string[];
    /**
     * @generated from protobuf field: repeated float repeated_float_value = 26;
     */
    repeatedFloatValue: number[];
    /**
     * @generated from protobuf field: repeated double repeated_double_value = 27;
     */
    repeatedDoubleValue: number[];
    /**
     * @generated from protobuf field: repeated string repeated_string_value = 28;
     */
    repeatedStringValue: string[];
    /**
     * @generated from protobuf field: repeated bytes repeated_bytes_value = 29;
     */
    repeatedBytesValue: Uint8Array[];
    /**
     * @generated from protobuf field: repeated proto3.EnumType repeated_enum_value = 30;
     */
    repeatedEnumValue: EnumType[];
    /**
     * @generated from protobuf field: repeated proto3.MessageType repeated_message_value = 31;
     */
    repeatedMessageValue: MessageType[];
}
/**
 * @generated from protobuf message proto3.TestOneof
 */
export interface TestOneof {
    /**
     * @generated from protobuf oneof: oneof_value
     */
    oneofValue: {
        oneofKind: "oneofInt32Value";
        /**
         * @generated from protobuf field: int32 oneof_int32_value = 1;
         */
        oneofInt32Value: number;
    } | {
        oneofKind: "oneofStringValue";
        /**
         * @generated from protobuf field: string oneof_string_value = 2;
         */
        oneofStringValue: string;
    } | {
        oneofKind: "oneofBytesValue";
        /**
         * @generated from protobuf field: bytes oneof_bytes_value = 3;
         */
        oneofBytesValue: Uint8Array;
    } | {
        oneofKind: "oneofEnumValue";
        /**
         * @generated from protobuf field: proto3.EnumType oneof_enum_value = 4;
         */
        oneofEnumValue: EnumType;
    } | {
        oneofKind: "oneofMessageValue";
        /**
         * @generated from protobuf field: proto3.MessageType oneof_message_value = 5;
         */
        oneofMessageValue: MessageType;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto3.TestMap
 */
export interface TestMap {
    /**
     * @generated from protobuf field: map<bool, int32> bool_map = 1;
     */
    boolMap: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<int32, int32> int32_map = 2;
     */
    int32Map: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int32> int64_map = 3;
     */
    int64Map: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, int32> uint32_map = 4;
     */
    uint32Map: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, int32> uint64_map = 5;
     */
    uint64Map: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<string, int32> string_map = 6;
     */
    stringMap: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto3.TestNestedMap
 */
export interface TestNestedMap {
    /**
     * @generated from protobuf field: map<bool, int32> bool_map = 1;
     */
    boolMap: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<int32, int32> int32_map = 2;
     */
    int32Map: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int32> int64_map = 3;
     */
    int64Map: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, int32> uint32_map = 4;
     */
    uint32Map: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, int32> uint64_map = 5;
     */
    uint64Map: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<string, int32> string_map = 6;
     */
    stringMap: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<string, proto3.TestNestedMap> map_map = 7;
     */
    mapMap: {
        [key: string]: TestNestedMap;
    };
}
/**
 * @generated from protobuf message proto3.TestStringMap
 */
export interface TestStringMap {
    /**
     * @generated from protobuf field: map<string, string> string_map = 1;
     */
    stringMap: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message proto3.TestWrapper
 */
export interface TestWrapper {
    /**
     * @generated from protobuf field: google.protobuf.BoolValue bool_value = 1;
     */
    boolValue?: BoolValue;
    /**
     * @generated from protobuf field: google.protobuf.Int32Value int32_value = 2;
     */
    int32Value?: Int32Value;
    /**
     * @generated from protobuf field: google.protobuf.Int64Value int64_value = 3;
     */
    int64Value?: Int64Value;
    /**
     * @generated from protobuf field: google.protobuf.UInt32Value uint32_value = 4;
     */
    uint32Value?: UInt32Value;
    /**
     * @generated from protobuf field: google.protobuf.UInt64Value uint64_value = 5;
     */
    uint64Value?: UInt64Value;
    /**
     * @generated from protobuf field: google.protobuf.FloatValue float_value = 6;
     */
    floatValue?: FloatValue;
    /**
     * @generated from protobuf field: google.protobuf.DoubleValue double_value = 7;
     */
    doubleValue?: DoubleValue;
    /**
     * @generated from protobuf field: google.protobuf.StringValue string_value = 8;
     */
    stringValue?: StringValue;
    /**
     * @generated from protobuf field: google.protobuf.BytesValue bytes_value = 9;
     */
    bytesValue?: BytesValue;
    /**
     * @generated from protobuf field: repeated google.protobuf.BoolValue repeated_bool_value = 11;
     */
    repeatedBoolValue: BoolValue[];
    /**
     * @generated from protobuf field: repeated google.protobuf.Int32Value repeated_int32_value = 12;
     */
    repeatedInt32Value: Int32Value[];
    /**
     * @generated from protobuf field: repeated google.protobuf.Int64Value repeated_int64_value = 13;
     */
    repeatedInt64Value: Int64Value[];
    /**
     * @generated from protobuf field: repeated google.protobuf.UInt32Value repeated_uint32_value = 14;
     */
    repeatedUint32Value: UInt32Value[];
    /**
     * @generated from protobuf field: repeated google.protobuf.UInt64Value repeated_uint64_value = 15;
     */
    repeatedUint64Value: UInt64Value[];
    /**
     * @generated from protobuf field: repeated google.protobuf.FloatValue repeated_float_value = 16;
     */
    repeatedFloatValue: FloatValue[];
    /**
     * @generated from protobuf field: repeated google.protobuf.DoubleValue repeated_double_value = 17;
     */
    repeatedDoubleValue: DoubleValue[];
    /**
     * @generated from protobuf field: repeated google.protobuf.StringValue repeated_string_value = 18;
     */
    repeatedStringValue: StringValue[];
    /**
     * @generated from protobuf field: repeated google.protobuf.BytesValue repeated_bytes_value = 19;
     */
    repeatedBytesValue: BytesValue[];
}
/**
 * @generated from protobuf message proto3.TestTimestamp
 */
export interface TestTimestamp {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp value = 1;
     */
    value?: Timestamp;
    /**
     * @generated from protobuf field: repeated google.protobuf.Timestamp repeated_value = 2;
     */
    repeatedValue: Timestamp[];
}
/**
 * @generated from protobuf message proto3.TestDuration
 */
export interface TestDuration {
    /**
     * @generated from protobuf field: google.protobuf.Duration value = 1;
     */
    value?: Duration;
    /**
     * @generated from protobuf field: repeated google.protobuf.Duration repeated_value = 2;
     */
    repeatedValue: Duration[];
}
/**
 * @generated from protobuf message proto3.TestFieldMask
 */
export interface TestFieldMask {
    /**
     * @generated from protobuf field: google.protobuf.FieldMask value = 1;
     */
    value?: FieldMask;
}
/**
 * @generated from protobuf message proto3.TestStruct
 */
export interface TestStruct {
    /**
     * @generated from protobuf field: google.protobuf.Struct value = 1;
     */
    value?: Struct;
    /**
     * @generated from protobuf field: repeated google.protobuf.Struct repeated_value = 2;
     */
    repeatedValue: Struct[];
}
/**
 * @generated from protobuf message proto3.TestAny
 */
export interface TestAny {
    /**
     * @generated from protobuf field: google.protobuf.Any value = 1;
     */
    value?: Any;
    /**
     * @generated from protobuf field: repeated google.protobuf.Any repeated_value = 2;
     */
    repeatedValue: Any[];
}
/**
 * @generated from protobuf message proto3.TestValue
 */
export interface TestValue {
    /**
     * @generated from protobuf field: google.protobuf.Value value = 1;
     */
    value?: Value;
    /**
     * @generated from protobuf field: repeated google.protobuf.Value repeated_value = 2;
     */
    repeatedValue: Value[];
}
/**
 * @generated from protobuf message proto3.TestListValue
 */
export interface TestListValue {
    /**
     * @generated from protobuf field: google.protobuf.ListValue value = 1;
     */
    value?: ListValue;
    /**
     * @generated from protobuf field: repeated google.protobuf.ListValue repeated_value = 2;
     */
    repeatedValue: ListValue[];
}
/**
 * @generated from protobuf message proto3.TestBoolValue
 */
export interface TestBoolValue {
    /**
     * @generated from protobuf field: bool bool_value = 1;
     */
    boolValue: boolean;
    /**
     * @generated from protobuf field: map<bool, int32> bool_map = 2;
     */
    boolMap: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message proto3.TestCustomJsonName
 */
export interface TestCustomJsonName {
    /**
     * @generated from protobuf field: int32 value = 1 [json_name = "@value"];
     */
    value: number;
}
/**
 * @generated from protobuf message proto3.TestExtensions
 */
export interface TestExtensions {
    /**
     * @generated from protobuf field: protobuf_unittest.TestAllExtensions extensions = 1;
     */
    extensions?: TestAllExtensions;
}
/**
 * @generated from protobuf message proto3.TestEnumValue
 */
export interface TestEnumValue {
    /**
     * @generated from protobuf field: proto3.EnumType enum_value1 = 1;
     */
    enumValue1: EnumType;
    /**
     * @generated from protobuf field: proto3.EnumType enum_value2 = 2;
     */
    enumValue2: EnumType;
    /**
     * @generated from protobuf field: proto3.EnumType enum_value3 = 3;
     */
    enumValue3: EnumType;
}
/**
 * @generated from protobuf enum proto3.EnumType
 */
export enum EnumType {
    /**
     * @generated from protobuf enum value: FOO = 0;
     */
    FOO = 0,
    /**
     * @generated from protobuf enum value: BAR = 1;
     */
    BAR = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class MessageType$Type extends MessageType$<MessageType> {
    constructor() {
        super("proto3.MessageType", [
            { no: 1, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MessageType>): MessageType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<MessageType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageType): MessageType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 value */ 1:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.MessageType
 */
export const MessageType = new MessageType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMessage$Type extends MessageType$<TestMessage> {
    constructor() {
        super("proto3.TestMessage", [
            { no: 1, name: "bool_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "int32_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "int64_value", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "uint32_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "uint64_value", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 6, name: "float_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "double_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "string_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "bytes_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "enum_value", kind: "enum", T: () => ["proto3.EnumType", EnumType] },
            { no: 11, name: "message_value", kind: "message", T: () => MessageType },
            { no: 21, name: "repeated_bool_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "repeated_int32_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "repeated_int64_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/ },
            { no: 24, name: "repeated_uint32_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "repeated_uint64_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ },
            { no: 26, name: "repeated_float_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 27, name: "repeated_double_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 28, name: "repeated_string_value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "repeated_bytes_value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 30, name: "repeated_enum_value", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["proto3.EnumType", EnumType] },
            { no: 31, name: "repeated_message_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MessageType }
        ]);
    }
    create(value?: PartialMessage<TestMessage>): TestMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boolValue = false;
        message.int32Value = 0;
        message.int64Value = "0";
        message.uint32Value = 0;
        message.uint64Value = "0";
        message.floatValue = 0;
        message.doubleValue = 0;
        message.stringValue = "";
        message.bytesValue = new Uint8Array(0);
        message.enumValue = 0;
        message.repeatedBoolValue = [];
        message.repeatedInt32Value = [];
        message.repeatedInt64Value = [];
        message.repeatedUint32Value = [];
        message.repeatedUint64Value = [];
        message.repeatedFloatValue = [];
        message.repeatedDoubleValue = [];
        message.repeatedStringValue = [];
        message.repeatedBytesValue = [];
        message.repeatedEnumValue = [];
        message.repeatedMessageValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMessage): TestMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_value */ 1:
                    message.boolValue = reader.bool();
                    break;
                case /* int32 int32_value */ 2:
                    message.int32Value = reader.int32();
                    break;
                case /* int64 int64_value */ 3:
                    message.int64Value = reader.int64().toString();
                    break;
                case /* uint32 uint32_value */ 4:
                    message.uint32Value = reader.uint32();
                    break;
                case /* uint64 uint64_value */ 5:
                    message.uint64Value = reader.uint64().toString();
                    break;
                case /* float float_value */ 6:
                    message.floatValue = reader.float();
                    break;
                case /* double double_value */ 7:
                    message.doubleValue = reader.double();
                    break;
                case /* string string_value */ 8:
                    message.stringValue = reader.string();
                    break;
                case /* bytes bytes_value */ 9:
                    message.bytesValue = reader.bytes();
                    break;
                case /* proto3.EnumType enum_value */ 10:
                    message.enumValue = reader.int32();
                    break;
                case /* proto3.MessageType message_value */ 11:
                    message.messageValue = MessageType.internalBinaryRead(reader, reader.uint32(), options, message.messageValue);
                    break;
                case /* repeated bool repeated_bool_value */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedBoolValue.push(reader.bool());
                    else
                        message.repeatedBoolValue.push(reader.bool());
                    break;
                case /* repeated int32 repeated_int32_value */ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt32Value.push(reader.int32());
                    else
                        message.repeatedInt32Value.push(reader.int32());
                    break;
                case /* repeated int64 repeated_int64_value */ 23:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedInt64Value.push(reader.int64().toString());
                    else
                        message.repeatedInt64Value.push(reader.int64().toString());
                    break;
                case /* repeated uint32 repeated_uint32_value */ 24:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedUint32Value.push(reader.uint32());
                    else
                        message.repeatedUint32Value.push(reader.uint32());
                    break;
                case /* repeated uint64 repeated_uint64_value */ 25:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedUint64Value.push(reader.uint64().toString());
                    else
                        message.repeatedUint64Value.push(reader.uint64().toString());
                    break;
                case /* repeated float repeated_float_value */ 26:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedFloatValue.push(reader.float());
                    else
                        message.repeatedFloatValue.push(reader.float());
                    break;
                case /* repeated double repeated_double_value */ 27:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedDoubleValue.push(reader.double());
                    else
                        message.repeatedDoubleValue.push(reader.double());
                    break;
                case /* repeated string repeated_string_value */ 28:
                    message.repeatedStringValue.push(reader.string());
                    break;
                case /* repeated bytes repeated_bytes_value */ 29:
                    message.repeatedBytesValue.push(reader.bytes());
                    break;
                case /* repeated proto3.EnumType repeated_enum_value */ 30:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.repeatedEnumValue.push(reader.int32());
                    else
                        message.repeatedEnumValue.push(reader.int32());
                    break;
                case /* repeated proto3.MessageType repeated_message_value */ 31:
                    message.repeatedMessageValue.push(MessageType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool bool_value = 1; */
        if (message.boolValue !== false)
            writer.tag(1, WireType.Varint).bool(message.boolValue);
        /* int32 int32_value = 2; */
        if (message.int32Value !== 0)
            writer.tag(2, WireType.Varint).int32(message.int32Value);
        /* int64 int64_value = 3; */
        if (message.int64Value !== "0")
            writer.tag(3, WireType.Varint).int64(message.int64Value);
        /* uint32 uint32_value = 4; */
        if (message.uint32Value !== 0)
            writer.tag(4, WireType.Varint).uint32(message.uint32Value);
        /* uint64 uint64_value = 5; */
        if (message.uint64Value !== "0")
            writer.tag(5, WireType.Varint).uint64(message.uint64Value);
        /* float float_value = 6; */
        if (message.floatValue !== 0)
            writer.tag(6, WireType.Bit32).float(message.floatValue);
        /* double double_value = 7; */
        if (message.doubleValue !== 0)
            writer.tag(7, WireType.Bit64).double(message.doubleValue);
        /* string string_value = 8; */
        if (message.stringValue !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.stringValue);
        /* bytes bytes_value = 9; */
        if (message.bytesValue.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.bytesValue);
        /* proto3.EnumType enum_value = 10; */
        if (message.enumValue !== 0)
            writer.tag(10, WireType.Varint).int32(message.enumValue);
        /* proto3.MessageType message_value = 11; */
        if (message.messageValue)
            MessageType.internalBinaryWrite(message.messageValue, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated bool repeated_bool_value = 21; */
        if (message.repeatedBoolValue.length) {
            writer.tag(21, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedBoolValue.length; i++)
                writer.bool(message.repeatedBoolValue[i]);
            writer.join();
        }
        /* repeated int32 repeated_int32_value = 22; */
        if (message.repeatedInt32Value.length) {
            writer.tag(22, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedInt32Value.length; i++)
                writer.int32(message.repeatedInt32Value[i]);
            writer.join();
        }
        /* repeated int64 repeated_int64_value = 23; */
        if (message.repeatedInt64Value.length) {
            writer.tag(23, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedInt64Value.length; i++)
                writer.int64(message.repeatedInt64Value[i]);
            writer.join();
        }
        /* repeated uint32 repeated_uint32_value = 24; */
        if (message.repeatedUint32Value.length) {
            writer.tag(24, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedUint32Value.length; i++)
                writer.uint32(message.repeatedUint32Value[i]);
            writer.join();
        }
        /* repeated uint64 repeated_uint64_value = 25; */
        if (message.repeatedUint64Value.length) {
            writer.tag(25, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedUint64Value.length; i++)
                writer.uint64(message.repeatedUint64Value[i]);
            writer.join();
        }
        /* repeated float repeated_float_value = 26; */
        if (message.repeatedFloatValue.length) {
            writer.tag(26, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedFloatValue.length; i++)
                writer.float(message.repeatedFloatValue[i]);
            writer.join();
        }
        /* repeated double repeated_double_value = 27; */
        if (message.repeatedDoubleValue.length) {
            writer.tag(27, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedDoubleValue.length; i++)
                writer.double(message.repeatedDoubleValue[i]);
            writer.join();
        }
        /* repeated string repeated_string_value = 28; */
        for (let i = 0; i < message.repeatedStringValue.length; i++)
            writer.tag(28, WireType.LengthDelimited).string(message.repeatedStringValue[i]);
        /* repeated bytes repeated_bytes_value = 29; */
        for (let i = 0; i < message.repeatedBytesValue.length; i++)
            writer.tag(29, WireType.LengthDelimited).bytes(message.repeatedBytesValue[i]);
        /* repeated proto3.EnumType repeated_enum_value = 30; */
        if (message.repeatedEnumValue.length) {
            writer.tag(30, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.repeatedEnumValue.length; i++)
                writer.int32(message.repeatedEnumValue[i]);
            writer.join();
        }
        /* repeated proto3.MessageType repeated_message_value = 31; */
        for (let i = 0; i < message.repeatedMessageValue.length; i++)
            MessageType.internalBinaryWrite(message.repeatedMessageValue[i], writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestMessage
 */
export const TestMessage = new TestMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestOneof$Type extends MessageType$<TestOneof> {
    constructor() {
        super("proto3.TestOneof", [
            { no: 1, name: "oneof_int32_value", kind: "scalar", oneof: "oneofValue", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "oneof_string_value", kind: "scalar", oneof: "oneofValue", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oneof_bytes_value", kind: "scalar", oneof: "oneofValue", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "oneof_enum_value", kind: "enum", oneof: "oneofValue", T: () => ["proto3.EnumType", EnumType] },
            { no: 5, name: "oneof_message_value", kind: "message", oneof: "oneofValue", T: () => MessageType }
        ]);
    }
    create(value?: PartialMessage<TestOneof>): TestOneof {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oneofValue = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TestOneof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestOneof): TestOneof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 oneof_int32_value */ 1:
                    message.oneofValue = {
                        oneofKind: "oneofInt32Value",
                        oneofInt32Value: reader.int32()
                    };
                    break;
                case /* string oneof_string_value */ 2:
                    message.oneofValue = {
                        oneofKind: "oneofStringValue",
                        oneofStringValue: reader.string()
                    };
                    break;
                case /* bytes oneof_bytes_value */ 3:
                    message.oneofValue = {
                        oneofKind: "oneofBytesValue",
                        oneofBytesValue: reader.bytes()
                    };
                    break;
                case /* proto3.EnumType oneof_enum_value */ 4:
                    message.oneofValue = {
                        oneofKind: "oneofEnumValue",
                        oneofEnumValue: reader.int32()
                    };
                    break;
                case /* proto3.MessageType oneof_message_value */ 5:
                    message.oneofValue = {
                        oneofKind: "oneofMessageValue",
                        oneofMessageValue: MessageType.internalBinaryRead(reader, reader.uint32(), options, (message.oneofValue as any).oneofMessageValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestOneof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 oneof_int32_value = 1; */
        if (message.oneofValue.oneofKind === "oneofInt32Value")
            writer.tag(1, WireType.Varint).int32(message.oneofValue.oneofInt32Value);
        /* string oneof_string_value = 2; */
        if (message.oneofValue.oneofKind === "oneofStringValue")
            writer.tag(2, WireType.LengthDelimited).string(message.oneofValue.oneofStringValue);
        /* bytes oneof_bytes_value = 3; */
        if (message.oneofValue.oneofKind === "oneofBytesValue")
            writer.tag(3, WireType.LengthDelimited).bytes(message.oneofValue.oneofBytesValue);
        /* proto3.EnumType oneof_enum_value = 4; */
        if (message.oneofValue.oneofKind === "oneofEnumValue")
            writer.tag(4, WireType.Varint).int32(message.oneofValue.oneofEnumValue);
        /* proto3.MessageType oneof_message_value = 5; */
        if (message.oneofValue.oneofKind === "oneofMessageValue")
            MessageType.internalBinaryWrite(message.oneofValue.oneofMessageValue, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestOneof
 */
export const TestOneof = new TestOneof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMap$Type extends MessageType$<TestMap> {
    constructor() {
        super("proto3.TestMap", [
            { no: 1, name: "bool_map", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "int32_map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 3, name: "int64_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 4, name: "uint32_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 5, name: "uint64_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 6, name: "string_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestMap>): TestMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boolMap = {};
        message.int32Map = {};
        message.int64Map = {};
        message.uint32Map = {};
        message.uint64Map = {};
        message.stringMap = {};
        if (value !== undefined)
            reflectionMergePartial<TestMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMap): TestMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<bool, int32> bool_map */ 1:
                    this.binaryReadMap1(message.boolMap, reader, options);
                    break;
                case /* map<int32, int32> int32_map */ 2:
                    this.binaryReadMap2(message.int32Map, reader, options);
                    break;
                case /* map<int64, int32> int64_map */ 3:
                    this.binaryReadMap3(message.int64Map, reader, options);
                    break;
                case /* map<uint32, int32> uint32_map */ 4:
                    this.binaryReadMap4(message.uint32Map, reader, options);
                    break;
                case /* map<uint64, int32> uint64_map */ 5:
                    this.binaryReadMap5(message.uint64Map, reader, options);
                    break;
                case /* map<string, int32> string_map */ 6:
                    this.binaryReadMap6(message.stringMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMap["boolMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["boolMap"] | undefined, val: TestMap["boolMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.bool_map");
            }
        }
        map[key ?? "false"] = val ?? 0;
    }
    private binaryReadMap2(map: TestMap["int32Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["int32Map"] | undefined, val: TestMap["int32Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.int32_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap3(map: TestMap["int64Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["int64Map"] | undefined, val: TestMap["int64Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.int64_map");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    private binaryReadMap4(map: TestMap["uint32Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["uint32Map"] | undefined, val: TestMap["uint32Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.uint32_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap5(map: TestMap["uint64Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["uint64Map"] | undefined, val: TestMap["uint64Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.uint64_map");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    private binaryReadMap6(map: TestMap["stringMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["stringMap"] | undefined, val: TestMap["stringMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestMap.string_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: TestMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<bool, int32> bool_map = 1; */
        for (let k of globalThis.Object.keys(message.boolMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).int32(message.boolMap[k]).join();
        /* map<int32, int32> int32_map = 2; */
        for (let k of globalThis.Object.keys(message.int32Map))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.int32Map[k as any]).join();
        /* map<int64, int32> int64_map = 3; */
        for (let k of globalThis.Object.keys(message.int64Map))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int32(message.int64Map[k]).join();
        /* map<uint32, int32> uint32_map = 4; */
        for (let k of globalThis.Object.keys(message.uint32Map))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).int32(message.uint32Map[k as any]).join();
        /* map<uint64, int32> uint64_map = 5; */
        for (let k of globalThis.Object.keys(message.uint64Map))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).int32(message.uint64Map[k]).join();
        /* map<string, int32> string_map = 6; */
        for (let k of globalThis.Object.keys(message.stringMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.stringMap[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestMap
 */
export const TestMap = new TestMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNestedMap$Type extends MessageType$<TestNestedMap> {
    constructor() {
        super("proto3.TestNestedMap", [
            { no: 1, name: "bool_map", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "int32_map", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 3, name: "int64_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 4, name: "uint32_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 5, name: "uint64_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 6, name: "string_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 7, name: "map_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TestNestedMap } }
        ]);
    }
    create(value?: PartialMessage<TestNestedMap>): TestNestedMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boolMap = {};
        message.int32Map = {};
        message.int64Map = {};
        message.uint32Map = {};
        message.uint64Map = {};
        message.stringMap = {};
        message.mapMap = {};
        if (value !== undefined)
            reflectionMergePartial<TestNestedMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNestedMap): TestNestedMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<bool, int32> bool_map */ 1:
                    this.binaryReadMap1(message.boolMap, reader, options);
                    break;
                case /* map<int32, int32> int32_map */ 2:
                    this.binaryReadMap2(message.int32Map, reader, options);
                    break;
                case /* map<int64, int32> int64_map */ 3:
                    this.binaryReadMap3(message.int64Map, reader, options);
                    break;
                case /* map<uint32, int32> uint32_map */ 4:
                    this.binaryReadMap4(message.uint32Map, reader, options);
                    break;
                case /* map<uint64, int32> uint64_map */ 5:
                    this.binaryReadMap5(message.uint64Map, reader, options);
                    break;
                case /* map<string, int32> string_map */ 6:
                    this.binaryReadMap6(message.stringMap, reader, options);
                    break;
                case /* map<string, proto3.TestNestedMap> map_map */ 7:
                    this.binaryReadMap7(message.mapMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestNestedMap["boolMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["boolMap"] | undefined, val: TestNestedMap["boolMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.bool_map");
            }
        }
        map[key ?? "false"] = val ?? 0;
    }
    private binaryReadMap2(map: TestNestedMap["int32Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["int32Map"] | undefined, val: TestNestedMap["int32Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.int32_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap3(map: TestNestedMap["int64Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["int64Map"] | undefined, val: TestNestedMap["int64Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.int64_map");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    private binaryReadMap4(map: TestNestedMap["uint32Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["uint32Map"] | undefined, val: TestNestedMap["uint32Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.uint32_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap5(map: TestNestedMap["uint64Map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["uint64Map"] | undefined, val: TestNestedMap["uint64Map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.uint64_map");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    private binaryReadMap6(map: TestNestedMap["stringMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["stringMap"] | undefined, val: TestNestedMap["stringMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.string_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap7(map: TestNestedMap["mapMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestNestedMap["mapMap"] | undefined, val: TestNestedMap["mapMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TestNestedMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestNestedMap.map_map");
            }
        }
        map[key ?? ""] = val ?? TestNestedMap.create();
    }
    internalBinaryWrite(message: TestNestedMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<bool, int32> bool_map = 1; */
        for (let k of globalThis.Object.keys(message.boolMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).int32(message.boolMap[k]).join();
        /* map<int32, int32> int32_map = 2; */
        for (let k of globalThis.Object.keys(message.int32Map))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.int32Map[k as any]).join();
        /* map<int64, int32> int64_map = 3; */
        for (let k of globalThis.Object.keys(message.int64Map))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int32(message.int64Map[k]).join();
        /* map<uint32, int32> uint32_map = 4; */
        for (let k of globalThis.Object.keys(message.uint32Map))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).int32(message.uint32Map[k as any]).join();
        /* map<uint64, int32> uint64_map = 5; */
        for (let k of globalThis.Object.keys(message.uint64Map))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).int32(message.uint64Map[k]).join();
        /* map<string, int32> string_map = 6; */
        for (let k of globalThis.Object.keys(message.stringMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.stringMap[k]).join();
        /* map<string, proto3.TestNestedMap> map_map = 7; */
        for (let k of globalThis.Object.keys(message.mapMap)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestNestedMap.internalBinaryWrite(message.mapMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestNestedMap
 */
export const TestNestedMap = new TestNestedMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestStringMap$Type extends MessageType$<TestStringMap> {
    constructor() {
        super("proto3.TestStringMap", [
            { no: 1, name: "string_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TestStringMap>): TestStringMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stringMap = {};
        if (value !== undefined)
            reflectionMergePartial<TestStringMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestStringMap): TestStringMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> string_map */ 1:
                    this.binaryReadMap1(message.stringMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestStringMap["stringMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestStringMap["stringMap"] | undefined, val: TestStringMap["stringMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestStringMap.string_map");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TestStringMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> string_map = 1; */
        for (let k of globalThis.Object.keys(message.stringMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.stringMap[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestStringMap
 */
export const TestStringMap = new TestStringMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestWrapper$Type extends MessageType$<TestWrapper> {
    constructor() {
        super("proto3.TestWrapper", [
            { no: 1, name: "bool_value", kind: "message", T: () => BoolValue },
            { no: 2, name: "int32_value", kind: "message", T: () => Int32Value },
            { no: 3, name: "int64_value", kind: "message", T: () => Int64Value },
            { no: 4, name: "uint32_value", kind: "message", T: () => UInt32Value },
            { no: 5, name: "uint64_value", kind: "message", T: () => UInt64Value },
            { no: 6, name: "float_value", kind: "message", T: () => FloatValue },
            { no: 7, name: "double_value", kind: "message", T: () => DoubleValue },
            { no: 8, name: "string_value", kind: "message", T: () => StringValue },
            { no: 9, name: "bytes_value", kind: "message", T: () => BytesValue },
            { no: 11, name: "repeated_bool_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BoolValue },
            { no: 12, name: "repeated_int32_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int32Value },
            { no: 13, name: "repeated_int64_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int64Value },
            { no: 14, name: "repeated_uint32_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UInt32Value },
            { no: 15, name: "repeated_uint64_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UInt64Value },
            { no: 16, name: "repeated_float_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FloatValue },
            { no: 17, name: "repeated_double_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DoubleValue },
            { no: 18, name: "repeated_string_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringValue },
            { no: 19, name: "repeated_bytes_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BytesValue }
        ]);
    }
    create(value?: PartialMessage<TestWrapper>): TestWrapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedBoolValue = [];
        message.repeatedInt32Value = [];
        message.repeatedInt64Value = [];
        message.repeatedUint32Value = [];
        message.repeatedUint64Value = [];
        message.repeatedFloatValue = [];
        message.repeatedDoubleValue = [];
        message.repeatedStringValue = [];
        message.repeatedBytesValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestWrapper): TestWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue bool_value */ 1:
                    message.boolValue = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.boolValue);
                    break;
                case /* google.protobuf.Int32Value int32_value */ 2:
                    message.int32Value = Int32Value.internalBinaryRead(reader, reader.uint32(), options, message.int32Value);
                    break;
                case /* google.protobuf.Int64Value int64_value */ 3:
                    message.int64Value = Int64Value.internalBinaryRead(reader, reader.uint32(), options, message.int64Value);
                    break;
                case /* google.protobuf.UInt32Value uint32_value */ 4:
                    message.uint32Value = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.uint32Value);
                    break;
                case /* google.protobuf.UInt64Value uint64_value */ 5:
                    message.uint64Value = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.uint64Value);
                    break;
                case /* google.protobuf.FloatValue float_value */ 6:
                    message.floatValue = FloatValue.internalBinaryRead(reader, reader.uint32(), options, message.floatValue);
                    break;
                case /* google.protobuf.DoubleValue double_value */ 7:
                    message.doubleValue = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.doubleValue);
                    break;
                case /* google.protobuf.StringValue string_value */ 8:
                    message.stringValue = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.stringValue);
                    break;
                case /* google.protobuf.BytesValue bytes_value */ 9:
                    message.bytesValue = BytesValue.internalBinaryRead(reader, reader.uint32(), options, message.bytesValue);
                    break;
                case /* repeated google.protobuf.BoolValue repeated_bool_value */ 11:
                    message.repeatedBoolValue.push(BoolValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Int32Value repeated_int32_value */ 12:
                    message.repeatedInt32Value.push(Int32Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Int64Value repeated_int64_value */ 13:
                    message.repeatedInt64Value.push(Int64Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.UInt32Value repeated_uint32_value */ 14:
                    message.repeatedUint32Value.push(UInt32Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.UInt64Value repeated_uint64_value */ 15:
                    message.repeatedUint64Value.push(UInt64Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.FloatValue repeated_float_value */ 16:
                    message.repeatedFloatValue.push(FloatValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.DoubleValue repeated_double_value */ 17:
                    message.repeatedDoubleValue.push(DoubleValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.StringValue repeated_string_value */ 18:
                    message.repeatedStringValue.push(StringValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.BytesValue repeated_bytes_value */ 19:
                    message.repeatedBytesValue.push(BytesValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue bool_value = 1; */
        if (message.boolValue)
            BoolValue.internalBinaryWrite(message.boolValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Int32Value int32_value = 2; */
        if (message.int32Value)
            Int32Value.internalBinaryWrite(message.int32Value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Int64Value int64_value = 3; */
        if (message.int64Value)
            Int64Value.internalBinaryWrite(message.int64Value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value uint32_value = 4; */
        if (message.uint32Value)
            UInt32Value.internalBinaryWrite(message.uint32Value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt64Value uint64_value = 5; */
        if (message.uint64Value)
            UInt64Value.internalBinaryWrite(message.uint64Value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FloatValue float_value = 6; */
        if (message.floatValue)
            FloatValue.internalBinaryWrite(message.floatValue, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.DoubleValue double_value = 7; */
        if (message.doubleValue)
            DoubleValue.internalBinaryWrite(message.doubleValue, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue string_value = 8; */
        if (message.stringValue)
            StringValue.internalBinaryWrite(message.stringValue, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BytesValue bytes_value = 9; */
        if (message.bytesValue)
            BytesValue.internalBinaryWrite(message.bytesValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.BoolValue repeated_bool_value = 11; */
        for (let i = 0; i < message.repeatedBoolValue.length; i++)
            BoolValue.internalBinaryWrite(message.repeatedBoolValue[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Int32Value repeated_int32_value = 12; */
        for (let i = 0; i < message.repeatedInt32Value.length; i++)
            Int32Value.internalBinaryWrite(message.repeatedInt32Value[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Int64Value repeated_int64_value = 13; */
        for (let i = 0; i < message.repeatedInt64Value.length; i++)
            Int64Value.internalBinaryWrite(message.repeatedInt64Value[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.UInt32Value repeated_uint32_value = 14; */
        for (let i = 0; i < message.repeatedUint32Value.length; i++)
            UInt32Value.internalBinaryWrite(message.repeatedUint32Value[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.UInt64Value repeated_uint64_value = 15; */
        for (let i = 0; i < message.repeatedUint64Value.length; i++)
            UInt64Value.internalBinaryWrite(message.repeatedUint64Value[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.FloatValue repeated_float_value = 16; */
        for (let i = 0; i < message.repeatedFloatValue.length; i++)
            FloatValue.internalBinaryWrite(message.repeatedFloatValue[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.DoubleValue repeated_double_value = 17; */
        for (let i = 0; i < message.repeatedDoubleValue.length; i++)
            DoubleValue.internalBinaryWrite(message.repeatedDoubleValue[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.StringValue repeated_string_value = 18; */
        for (let i = 0; i < message.repeatedStringValue.length; i++)
            StringValue.internalBinaryWrite(message.repeatedStringValue[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.BytesValue repeated_bytes_value = 19; */
        for (let i = 0; i < message.repeatedBytesValue.length; i++)
            BytesValue.internalBinaryWrite(message.repeatedBytesValue[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestWrapper
 */
export const TestWrapper = new TestWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestTimestamp$Type extends MessageType$<TestTimestamp> {
    constructor() {
        super("proto3.TestTimestamp", [
            { no: 1, name: "value", kind: "message", T: () => Timestamp },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TestTimestamp>): TestTimestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestTimestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestTimestamp): TestTimestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp value */ 1:
                    message.value = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.Timestamp repeated_value */ 2:
                    message.repeatedValue.push(Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestTimestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp value = 1; */
        if (message.value)
            Timestamp.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Timestamp repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            Timestamp.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestTimestamp
 */
export const TestTimestamp = new TestTimestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDuration$Type extends MessageType$<TestDuration> {
    constructor() {
        super("proto3.TestDuration", [
            { no: 1, name: "value", kind: "message", T: () => Duration },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<TestDuration>): TestDuration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestDuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDuration): TestDuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration value */ 1:
                    message.value = Duration.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.Duration repeated_value */ 2:
                    message.repeatedValue.push(Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration value = 1; */
        if (message.value)
            Duration.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            Duration.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestDuration
 */
export const TestDuration = new TestDuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFieldMask$Type extends MessageType$<TestFieldMask> {
    constructor() {
        super("proto3.TestFieldMask", [
            { no: 1, name: "value", kind: "message", T: () => FieldMask }
        ]);
    }
    create(value?: PartialMessage<TestFieldMask>): TestFieldMask {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestFieldMask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFieldMask): TestFieldMask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.FieldMask value */ 1:
                    message.value = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFieldMask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.FieldMask value = 1; */
        if (message.value)
            FieldMask.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestFieldMask
 */
export const TestFieldMask = new TestFieldMask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestStruct$Type extends MessageType$<TestStruct> {
    constructor() {
        super("proto3.TestStruct", [
            { no: 1, name: "value", kind: "message", T: () => Struct },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<TestStruct>): TestStruct {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestStruct): TestStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct value */ 1:
                    message.value = Struct.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.Struct repeated_value */ 2:
                    message.repeatedValue.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct value = 1; */
        if (message.value)
            Struct.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Struct repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            Struct.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestStruct
 */
export const TestStruct = new TestStruct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestAny$Type extends MessageType$<TestAny> {
    constructor() {
        super("proto3.TestAny", [
            { no: 1, name: "value", kind: "message", T: () => Any },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any }
        ]);
    }
    create(value?: PartialMessage<TestAny>): TestAny {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestAny>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestAny): TestAny {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any value */ 1:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.Any repeated_value */ 2:
                    message.repeatedValue.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestAny, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any value = 1; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Any repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            Any.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestAny
 */
export const TestAny = new TestAny$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestValue$Type extends MessageType$<TestValue> {
    constructor() {
        super("proto3.TestValue", [
            { no: 1, name: "value", kind: "message", T: () => Value },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<TestValue>): TestValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestValue): TestValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Value value */ 1:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.Value repeated_value */ 2:
                    message.repeatedValue.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Value value = 1; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Value repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            Value.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestValue
 */
export const TestValue = new TestValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestListValue$Type extends MessageType$<TestListValue> {
    constructor() {
        super("proto3.TestListValue", [
            { no: 1, name: "value", kind: "message", T: () => ListValue },
            { no: 2, name: "repeated_value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListValue }
        ]);
    }
    create(value?: PartialMessage<TestListValue>): TestListValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.repeatedValue = [];
        if (value !== undefined)
            reflectionMergePartial<TestListValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestListValue): TestListValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.ListValue value */ 1:
                    message.value = ListValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated google.protobuf.ListValue repeated_value */ 2:
                    message.repeatedValue.push(ListValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestListValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.ListValue value = 1; */
        if (message.value)
            ListValue.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.ListValue repeated_value = 2; */
        for (let i = 0; i < message.repeatedValue.length; i++)
            ListValue.internalBinaryWrite(message.repeatedValue[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestListValue
 */
export const TestListValue = new TestListValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestBoolValue$Type extends MessageType$<TestBoolValue> {
    constructor() {
        super("proto3.TestBoolValue", [
            { no: 1, name: "bool_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "bool_map", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestBoolValue>): TestBoolValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boolValue = false;
        message.boolMap = {};
        if (value !== undefined)
            reflectionMergePartial<TestBoolValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestBoolValue): TestBoolValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_value */ 1:
                    message.boolValue = reader.bool();
                    break;
                case /* map<bool, int32> bool_map */ 2:
                    this.binaryReadMap2(message.boolMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: TestBoolValue["boolMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestBoolValue["boolMap"] | undefined, val: TestBoolValue["boolMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field proto3.TestBoolValue.bool_map");
            }
        }
        map[key ?? "false"] = val ?? 0;
    }
    internalBinaryWrite(message: TestBoolValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool bool_value = 1; */
        if (message.boolValue !== false)
            writer.tag(1, WireType.Varint).bool(message.boolValue);
        /* map<bool, int32> bool_map = 2; */
        for (let k of globalThis.Object.keys(message.boolMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).int32(message.boolMap[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestBoolValue
 */
export const TestBoolValue = new TestBoolValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestCustomJsonName$Type extends MessageType$<TestCustomJsonName> {
    constructor() {
        super("proto3.TestCustomJsonName", [
            { no: 1, name: "value", kind: "scalar", jsonName: "@value", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestCustomJsonName>): TestCustomJsonName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<TestCustomJsonName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestCustomJsonName): TestCustomJsonName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 value = 1 [json_name = "@value"];*/ 1:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestCustomJsonName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 value = 1 [json_name = "@value"]; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestCustomJsonName
 */
export const TestCustomJsonName = new TestCustomJsonName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestExtensions$Type extends MessageType$<TestExtensions> {
    constructor() {
        super("proto3.TestExtensions", [
            { no: 1, name: "extensions", kind: "message", T: () => TestAllExtensions }
        ]);
    }
    create(value?: PartialMessage<TestExtensions>): TestExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestExtensions): TestExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protobuf_unittest.TestAllExtensions extensions */ 1:
                    message.extensions = TestAllExtensions.internalBinaryRead(reader, reader.uint32(), options, message.extensions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protobuf_unittest.TestAllExtensions extensions = 1; */
        if (message.extensions)
            TestAllExtensions.internalBinaryWrite(message.extensions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestExtensions
 */
export const TestExtensions = new TestExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEnumValue$Type extends MessageType$<TestEnumValue> {
    constructor() {
        super("proto3.TestEnumValue", [
            { no: 1, name: "enum_value1", kind: "enum", T: () => ["proto3.EnumType", EnumType] },
            { no: 2, name: "enum_value2", kind: "enum", T: () => ["proto3.EnumType", EnumType] },
            { no: 3, name: "enum_value3", kind: "enum", T: () => ["proto3.EnumType", EnumType] }
        ]);
    }
    create(value?: PartialMessage<TestEnumValue>): TestEnumValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enumValue1 = 0;
        message.enumValue2 = 0;
        message.enumValue3 = 0;
        if (value !== undefined)
            reflectionMergePartial<TestEnumValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEnumValue): TestEnumValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto3.EnumType enum_value1 */ 1:
                    message.enumValue1 = reader.int32();
                    break;
                case /* proto3.EnumType enum_value2 */ 2:
                    message.enumValue2 = reader.int32();
                    break;
                case /* proto3.EnumType enum_value3 */ 3:
                    message.enumValue3 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestEnumValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto3.EnumType enum_value1 = 1; */
        if (message.enumValue1 !== 0)
            writer.tag(1, WireType.Varint).int32(message.enumValue1);
        /* proto3.EnumType enum_value2 = 2; */
        if (message.enumValue2 !== 0)
            writer.tag(2, WireType.Varint).int32(message.enumValue2);
        /* proto3.EnumType enum_value3 = 3; */
        if (message.enumValue3 !== 0)
            writer.tag(3, WireType.Varint).int32(message.enumValue3);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto3.TestEnumValue
 */
export const TestEnumValue = new TestEnumValue$Type();
