// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/unittest_proto3_optional.proto" (package "protobuf_unittest", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message protobuf_unittest.TestProto3Optional
 */
export interface TestProto3Optional {
    /**
     * Singular
     *
     * @generated from protobuf field: optional int32 optional_int32 = 1;
     */
    optionalInt32?: number;
    /**
     * @generated from protobuf field: optional int64 optional_int64 = 2;
     */
    optionalInt64?: string;
    /**
     * @generated from protobuf field: optional uint32 optional_uint32 = 3;
     */
    optionalUint32?: number;
    /**
     * @generated from protobuf field: optional uint64 optional_uint64 = 4;
     */
    optionalUint64?: string;
    /**
     * @generated from protobuf field: optional sint32 optional_sint32 = 5;
     */
    optionalSint32?: number;
    /**
     * @generated from protobuf field: optional sint64 optional_sint64 = 6;
     */
    optionalSint64?: string;
    /**
     * @generated from protobuf field: optional fixed32 optional_fixed32 = 7;
     */
    optionalFixed32?: number;
    /**
     * @generated from protobuf field: optional fixed64 optional_fixed64 = 8;
     */
    optionalFixed64?: string;
    /**
     * @generated from protobuf field: optional sfixed32 optional_sfixed32 = 9;
     */
    optionalSfixed32?: number;
    /**
     * @generated from protobuf field: optional sfixed64 optional_sfixed64 = 10;
     */
    optionalSfixed64?: string;
    /**
     * @generated from protobuf field: optional float optional_float = 11;
     */
    optionalFloat?: number;
    /**
     * @generated from protobuf field: optional double optional_double = 12;
     */
    optionalDouble?: number;
    /**
     * @generated from protobuf field: optional bool optional_bool = 13;
     */
    optionalBool?: boolean;
    /**
     * @generated from protobuf field: optional string optional_string = 14;
     */
    optionalString?: string;
    /**
     * @generated from protobuf field: optional bytes optional_bytes = 15;
     */
    optionalBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional string optional_cord = 16;
     */
    optionalCord?: string;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestProto3Optional.NestedMessage optional_nested_message = 18;
     */
    optionalNestedMessage?: TestProto3Optional_NestedMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestProto3Optional.NestedMessage lazy_nested_message = 19;
     */
    lazyNestedMessage?: TestProto3Optional_NestedMessage;
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestProto3Optional.NestedEnum optional_nested_enum = 21;
     */
    optionalNestedEnum?: TestProto3Optional_NestedEnum;
    /**
     * Add some non-optional fields to verify we can mix them.
     *
     * @generated from protobuf field: int32 singular_int32 = 22;
     */
    singularInt32: number;
    /**
     * @generated from protobuf field: int64 singular_int64 = 23;
     */
    singularInt64: string;
}
/**
 * @generated from protobuf message protobuf_unittest.TestProto3Optional.NestedMessage
 */
export interface TestProto3Optional_NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     *
     * @generated from protobuf field: optional int32 bb = 1;
     */
    bb?: number;
}
/**
 * @generated from protobuf enum protobuf_unittest.TestProto3Optional.NestedEnum
 */
export enum TestProto3Optional_NestedEnum {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FOO = 1;
     */
    FOO = 1,
    /**
     * @generated from protobuf enum value: BAR = 2;
     */
    BAR = 2,
    /**
     * @generated from protobuf enum value: BAZ = 3;
     */
    BAZ = 3,
    /**
     * Intentionally negative.
     *
     * @generated from protobuf enum value: NEG = -1;
     */
    NEG = -1
}
// @generated message type with reflection information, may provide speed optimized methods
class TestProto3Optional$Type extends MessageType<TestProto3Optional> {
    constructor() {
        super("protobuf_unittest.TestProto3Optional", [
            { no: 1, name: "optional_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "optional_int64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "optional_uint32", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "optional_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "optional_sint32", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "optional_sint64", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/ },
            { no: 7, name: "optional_fixed32", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "optional_fixed64", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/ },
            { no: 9, name: "optional_sfixed32", kind: "scalar", opt: true, T: 15 /*ScalarType.SFIXED32*/ },
            { no: 10, name: "optional_sfixed64", kind: "scalar", opt: true, T: 16 /*ScalarType.SFIXED64*/ },
            { no: 11, name: "optional_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "optional_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "optional_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "optional_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "optional_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 16, name: "optional_cord", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "optional_nested_message", kind: "message", T: () => TestProto3Optional_NestedMessage },
            { no: 19, name: "lazy_nested_message", kind: "message", T: () => TestProto3Optional_NestedMessage },
            { no: 21, name: "optional_nested_enum", kind: "enum", opt: true, T: () => ["protobuf_unittest.TestProto3Optional.NestedEnum", TestProto3Optional_NestedEnum] },
            { no: 22, name: "singular_int32", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "singular_int64", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<TestProto3Optional>): TestProto3Optional {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.singularInt32 = 0;
        message.singularInt64 = "0";
        if (value !== undefined)
            reflectionMergePartial<TestProto3Optional>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestProto3Optional): TestProto3Optional {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 optional_int32 */ 1:
                    message.optionalInt32 = reader.int32();
                    break;
                case /* optional int64 optional_int64 */ 2:
                    message.optionalInt64 = reader.int64().toString();
                    break;
                case /* optional uint32 optional_uint32 */ 3:
                    message.optionalUint32 = reader.uint32();
                    break;
                case /* optional uint64 optional_uint64 */ 4:
                    message.optionalUint64 = reader.uint64().toString();
                    break;
                case /* optional sint32 optional_sint32 */ 5:
                    message.optionalSint32 = reader.sint32();
                    break;
                case /* optional sint64 optional_sint64 */ 6:
                    message.optionalSint64 = reader.sint64().toString();
                    break;
                case /* optional fixed32 optional_fixed32 */ 7:
                    message.optionalFixed32 = reader.fixed32();
                    break;
                case /* optional fixed64 optional_fixed64 */ 8:
                    message.optionalFixed64 = reader.fixed64().toString();
                    break;
                case /* optional sfixed32 optional_sfixed32 */ 9:
                    message.optionalSfixed32 = reader.sfixed32();
                    break;
                case /* optional sfixed64 optional_sfixed64 */ 10:
                    message.optionalSfixed64 = reader.sfixed64().toString();
                    break;
                case /* optional float optional_float */ 11:
                    message.optionalFloat = reader.float();
                    break;
                case /* optional double optional_double */ 12:
                    message.optionalDouble = reader.double();
                    break;
                case /* optional bool optional_bool */ 13:
                    message.optionalBool = reader.bool();
                    break;
                case /* optional string optional_string */ 14:
                    message.optionalString = reader.string();
                    break;
                case /* optional bytes optional_bytes */ 15:
                    message.optionalBytes = reader.bytes();
                    break;
                case /* optional string optional_cord */ 16:
                    message.optionalCord = reader.string();
                    break;
                case /* optional protobuf_unittest.TestProto3Optional.NestedMessage optional_nested_message */ 18:
                    message.optionalNestedMessage = TestProto3Optional_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.optionalNestedMessage);
                    break;
                case /* optional protobuf_unittest.TestProto3Optional.NestedMessage lazy_nested_message */ 19:
                    message.lazyNestedMessage = TestProto3Optional_NestedMessage.internalBinaryRead(reader, reader.uint32(), options, message.lazyNestedMessage);
                    break;
                case /* optional protobuf_unittest.TestProto3Optional.NestedEnum optional_nested_enum */ 21:
                    message.optionalNestedEnum = reader.int32();
                    break;
                case /* int32 singular_int32 */ 22:
                    message.singularInt32 = reader.int32();
                    break;
                case /* int64 singular_int64 */ 23:
                    message.singularInt64 = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestProto3Optional, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 optional_int32 = 1; */
        if (message.optionalInt32 !== undefined)
            writer.tag(1, WireType.Varint).int32(message.optionalInt32);
        /* optional int64 optional_int64 = 2; */
        if (message.optionalInt64 !== undefined)
            writer.tag(2, WireType.Varint).int64(message.optionalInt64);
        /* optional uint32 optional_uint32 = 3; */
        if (message.optionalUint32 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.optionalUint32);
        /* optional uint64 optional_uint64 = 4; */
        if (message.optionalUint64 !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.optionalUint64);
        /* optional sint32 optional_sint32 = 5; */
        if (message.optionalSint32 !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.optionalSint32);
        /* optional sint64 optional_sint64 = 6; */
        if (message.optionalSint64 !== undefined)
            writer.tag(6, WireType.Varint).sint64(message.optionalSint64);
        /* optional fixed32 optional_fixed32 = 7; */
        if (message.optionalFixed32 !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.optionalFixed32);
        /* optional fixed64 optional_fixed64 = 8; */
        if (message.optionalFixed64 !== undefined)
            writer.tag(8, WireType.Bit64).fixed64(message.optionalFixed64);
        /* optional sfixed32 optional_sfixed32 = 9; */
        if (message.optionalSfixed32 !== undefined)
            writer.tag(9, WireType.Bit32).sfixed32(message.optionalSfixed32);
        /* optional sfixed64 optional_sfixed64 = 10; */
        if (message.optionalSfixed64 !== undefined)
            writer.tag(10, WireType.Bit64).sfixed64(message.optionalSfixed64);
        /* optional float optional_float = 11; */
        if (message.optionalFloat !== undefined)
            writer.tag(11, WireType.Bit32).float(message.optionalFloat);
        /* optional double optional_double = 12; */
        if (message.optionalDouble !== undefined)
            writer.tag(12, WireType.Bit64).double(message.optionalDouble);
        /* optional bool optional_bool = 13; */
        if (message.optionalBool !== undefined)
            writer.tag(13, WireType.Varint).bool(message.optionalBool);
        /* optional string optional_string = 14; */
        if (message.optionalString !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.optionalString);
        /* optional bytes optional_bytes = 15; */
        if (message.optionalBytes !== undefined)
            writer.tag(15, WireType.LengthDelimited).bytes(message.optionalBytes);
        /* optional string optional_cord = 16; */
        if (message.optionalCord !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.optionalCord);
        /* optional protobuf_unittest.TestProto3Optional.NestedMessage optional_nested_message = 18; */
        if (message.optionalNestedMessage)
            TestProto3Optional_NestedMessage.internalBinaryWrite(message.optionalNestedMessage, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestProto3Optional.NestedMessage lazy_nested_message = 19; */
        if (message.lazyNestedMessage)
            TestProto3Optional_NestedMessage.internalBinaryWrite(message.lazyNestedMessage, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional protobuf_unittest.TestProto3Optional.NestedEnum optional_nested_enum = 21; */
        if (message.optionalNestedEnum !== undefined)
            writer.tag(21, WireType.Varint).int32(message.optionalNestedEnum);
        /* int32 singular_int32 = 22; */
        if (message.singularInt32 !== 0)
            writer.tag(22, WireType.Varint).int32(message.singularInt32);
        /* int64 singular_int64 = 23; */
        if (message.singularInt64 !== "0")
            writer.tag(23, WireType.Varint).int64(message.singularInt64);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestProto3Optional
 */
export const TestProto3Optional = new TestProto3Optional$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestProto3Optional_NestedMessage$Type extends MessageType<TestProto3Optional_NestedMessage> {
    constructor() {
        super("protobuf_unittest.TestProto3Optional.NestedMessage", [
            { no: 1, name: "bb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestProto3Optional_NestedMessage>): TestProto3Optional_NestedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestProto3Optional_NestedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestProto3Optional_NestedMessage): TestProto3Optional_NestedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 bb */ 1:
                    message.bb = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestProto3Optional_NestedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 bb = 1; */
        if (message.bb !== undefined)
            writer.tag(1, WireType.Varint).int32(message.bb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestProto3Optional.NestedMessage
 */
export const TestProto3Optional_NestedMessage = new TestProto3Optional_NestedMessage$Type();
