// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/map_proto2_unittest.proto" (package "protobuf_unittest", syntax proto2)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ImportEnumForMap } from "./unittest_import";
/**
 * @generated from protobuf message protobuf_unittest.TestEnumMap
 */
export interface TestEnumMap {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnum> known_map_field = 101;
     */
    knownMapField: {
        [key: number]: Proto2MapEnum;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnum> unknown_map_field = 102;
     */
    unknownMapField: {
        [key: number]: Proto2MapEnum;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestEnumMapPlusExtra
 */
export interface TestEnumMapPlusExtra {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> known_map_field = 101;
     */
    knownMapField: {
        [key: number]: Proto2MapEnumPlusExtra;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> unknown_map_field = 102;
     */
    unknownMapField: {
        [key: number]: Proto2MapEnumPlusExtra;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestImportEnumMap
 */
export interface TestImportEnumMap {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest_import.ImportEnumForMap> import_enum_amp = 1;
     */
    importEnumAmp: {
        [key: number]: ImportEnumForMap;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestIntIntMap
 */
export interface TestIntIntMap {
    /**
     * @generated from protobuf field: map<int32, int32> m = 1;
     */
    m: {
        [key: number]: number;
    };
}
/**
 * Test all key types: string, plus the non-floating-point scalars.
 *
 * @generated from protobuf message protobuf_unittest.TestMaps
 */
export interface TestMaps {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestIntIntMap> m_int32 = 1;
     */
    mInt32: {
        [key: number]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<int64, protobuf_unittest.TestIntIntMap> m_int64 = 2;
     */
    mInt64: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<uint32, protobuf_unittest.TestIntIntMap> m_uint32 = 3;
     */
    mUint32: {
        [key: number]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<uint64, protobuf_unittest.TestIntIntMap> m_uint64 = 4;
     */
    mUint64: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<sint32, protobuf_unittest.TestIntIntMap> m_sint32 = 5;
     */
    mSint32: {
        [key: number]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<sint64, protobuf_unittest.TestIntIntMap> m_sint64 = 6;
     */
    mSint64: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<fixed32, protobuf_unittest.TestIntIntMap> m_fixed32 = 7;
     */
    mFixed32: {
        [key: number]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<fixed64, protobuf_unittest.TestIntIntMap> m_fixed64 = 8;
     */
    mFixed64: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<sfixed32, protobuf_unittest.TestIntIntMap> m_sfixed32 = 9;
     */
    mSfixed32: {
        [key: number]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<sfixed64, protobuf_unittest.TestIntIntMap> m_sfixed64 = 10;
     */
    mSfixed64: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<bool, protobuf_unittest.TestIntIntMap> m_bool = 11;
     */
    mBool: {
        [key: string]: TestIntIntMap;
    };
    /**
     * @generated from protobuf field: map<string, protobuf_unittest.TestIntIntMap> m_string = 12;
     */
    mString: {
        [key: string]: TestIntIntMap;
    };
}
/**
 * Test maps in submessages.
 *
 * @generated from protobuf message protobuf_unittest.TestSubmessageMaps
 */
export interface TestSubmessageMaps {
    /**
     * @generated from protobuf field: optional protobuf_unittest.TestMaps m = 1;
     */
    m?: TestMaps;
}
/**
 * @generated from protobuf enum protobuf_unittest.Proto2MapEnum
 */
export enum Proto2MapEnum {
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_FOO = 0;
     */
    FOO = 0,
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_BAR = 1;
     */
    BAR = 1,
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_BAZ = 2;
     */
    BAZ = 2
}
/**
 * @generated from protobuf enum protobuf_unittest.Proto2MapEnumPlusExtra
 */
export enum Proto2MapEnumPlusExtra {
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_FOO = 0;
     */
    E_PROTO2_MAP_ENUM_FOO = 0,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_BAR = 1;
     */
    E_PROTO2_MAP_ENUM_BAR = 1,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_BAZ = 2;
     */
    E_PROTO2_MAP_ENUM_BAZ = 2,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_EXTRA = 3;
     */
    E_PROTO2_MAP_ENUM_EXTRA = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class TestEnumMap$Type extends MessageType<TestEnumMap> {
    constructor() {
        super("protobuf_unittest.TestEnumMap", [
            { no: 101, name: "known_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnum", Proto2MapEnum, "PROTO2_MAP_ENUM_"] } },
            { no: 102, name: "unknown_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnum", Proto2MapEnum, "PROTO2_MAP_ENUM_"] } }
        ]);
    }
    create(value?: PartialMessage<TestEnumMap>): TestEnumMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.knownMapField = {};
        message.unknownMapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestEnumMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEnumMap): TestEnumMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.Proto2MapEnum> known_map_field */ 101:
                    this.binaryReadMap101(message.knownMapField, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.Proto2MapEnum> unknown_map_field */ 102:
                    this.binaryReadMap102(message.unknownMapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap101(map: TestEnumMap["knownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMap["knownMapField"] | undefined, val: TestEnumMap["knownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestEnumMap.known_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap102(map: TestEnumMap["unknownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMap["unknownMapField"] | undefined, val: TestEnumMap["unknownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestEnumMap.unknown_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestEnumMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.Proto2MapEnum> known_map_field = 101; */
        for (let k of globalThis.Object.keys(message.knownMapField))
            writer.tag(101, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.knownMapField[k as any]).join();
        /* map<int32, protobuf_unittest.Proto2MapEnum> unknown_map_field = 102; */
        for (let k of globalThis.Object.keys(message.unknownMapField))
            writer.tag(102, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.unknownMapField[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEnumMap
 */
export const TestEnumMap = new TestEnumMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEnumMapPlusExtra$Type extends MessageType<TestEnumMapPlusExtra> {
    constructor() {
        super("protobuf_unittest.TestEnumMapPlusExtra", [
            { no: 101, name: "known_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumPlusExtra", Proto2MapEnumPlusExtra] } },
            { no: 102, name: "unknown_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumPlusExtra", Proto2MapEnumPlusExtra] } }
        ]);
    }
    create(value?: PartialMessage<TestEnumMapPlusExtra>): TestEnumMapPlusExtra {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.knownMapField = {};
        message.unknownMapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestEnumMapPlusExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEnumMapPlusExtra): TestEnumMapPlusExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> known_map_field */ 101:
                    this.binaryReadMap101(message.knownMapField, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> unknown_map_field */ 102:
                    this.binaryReadMap102(message.unknownMapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap101(map: TestEnumMapPlusExtra["knownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapPlusExtra["knownMapField"] | undefined, val: TestEnumMapPlusExtra["knownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestEnumMapPlusExtra.known_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap102(map: TestEnumMapPlusExtra["unknownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapPlusExtra["unknownMapField"] | undefined, val: TestEnumMapPlusExtra["unknownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestEnumMapPlusExtra.unknown_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestEnumMapPlusExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> known_map_field = 101; */
        for (let k of globalThis.Object.keys(message.knownMapField))
            writer.tag(101, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.knownMapField[k as any]).join();
        /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtra> unknown_map_field = 102; */
        for (let k of globalThis.Object.keys(message.unknownMapField))
            writer.tag(102, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.unknownMapField[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEnumMapPlusExtra
 */
export const TestEnumMapPlusExtra = new TestEnumMapPlusExtra$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestImportEnumMap$Type extends MessageType<TestImportEnumMap> {
    constructor() {
        super("protobuf_unittest.TestImportEnumMap", [
            { no: 1, name: "import_enum_amp", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest_import.ImportEnumForMap", ImportEnumForMap] } }
        ]);
    }
    create(value?: PartialMessage<TestImportEnumMap>): TestImportEnumMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.importEnumAmp = {};
        if (value !== undefined)
            reflectionMergePartial<TestImportEnumMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestImportEnumMap): TestImportEnumMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest_import.ImportEnumForMap> import_enum_amp */ 1:
                    this.binaryReadMap1(message.importEnumAmp, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestImportEnumMap["importEnumAmp"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestImportEnumMap["importEnumAmp"] | undefined, val: TestImportEnumMap["importEnumAmp"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestImportEnumMap.import_enum_amp");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestImportEnumMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest_import.ImportEnumForMap> import_enum_amp = 1; */
        for (let k of globalThis.Object.keys(message.importEnumAmp))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.importEnumAmp[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestImportEnumMap
 */
export const TestImportEnumMap = new TestImportEnumMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestIntIntMap$Type extends MessageType<TestIntIntMap> {
    constructor() {
        super("protobuf_unittest.TestIntIntMap", [
            { no: 1, name: "m", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestIntIntMap>): TestIntIntMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.m = {};
        if (value !== undefined)
            reflectionMergePartial<TestIntIntMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestIntIntMap): TestIntIntMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> m */ 1:
                    this.binaryReadMap1(message.m, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestIntIntMap["m"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestIntIntMap["m"] | undefined, val: TestIntIntMap["m"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestIntIntMap.m");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestIntIntMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> m = 1; */
        for (let k of globalThis.Object.keys(message.m))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.m[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestIntIntMap
 */
export const TestIntIntMap = new TestIntIntMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMaps$Type extends MessageType<TestMaps> {
    constructor() {
        super("protobuf_unittest.TestMaps", [
            { no: 1, name: "m_int32", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 2, name: "m_int64", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 3, name: "m_uint32", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 4, name: "m_uint64", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 5, name: "m_sint32", kind: "map", K: 17 /*ScalarType.SINT32*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 6, name: "m_sint64", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 7, name: "m_fixed32", kind: "map", K: 7 /*ScalarType.FIXED32*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 8, name: "m_fixed64", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 9, name: "m_sfixed32", kind: "map", K: 15 /*ScalarType.SFIXED32*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 10, name: "m_sfixed64", kind: "map", K: 16 /*ScalarType.SFIXED64*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 11, name: "m_bool", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "message", T: () => TestIntIntMap } },
            { no: 12, name: "m_string", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TestIntIntMap } }
        ]);
    }
    create(value?: PartialMessage<TestMaps>): TestMaps {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mInt32 = {};
        message.mInt64 = {};
        message.mUint32 = {};
        message.mUint64 = {};
        message.mSint32 = {};
        message.mSint64 = {};
        message.mFixed32 = {};
        message.mFixed64 = {};
        message.mSfixed32 = {};
        message.mSfixed64 = {};
        message.mBool = {};
        message.mString = {};
        if (value !== undefined)
            reflectionMergePartial<TestMaps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMaps): TestMaps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.TestIntIntMap> m_int32 */ 1:
                    this.binaryReadMap1(message.mInt32, reader, options);
                    break;
                case /* map<int64, protobuf_unittest.TestIntIntMap> m_int64 */ 2:
                    this.binaryReadMap2(message.mInt64, reader, options);
                    break;
                case /* map<uint32, protobuf_unittest.TestIntIntMap> m_uint32 */ 3:
                    this.binaryReadMap3(message.mUint32, reader, options);
                    break;
                case /* map<uint64, protobuf_unittest.TestIntIntMap> m_uint64 */ 4:
                    this.binaryReadMap4(message.mUint64, reader, options);
                    break;
                case /* map<sint32, protobuf_unittest.TestIntIntMap> m_sint32 */ 5:
                    this.binaryReadMap5(message.mSint32, reader, options);
                    break;
                case /* map<sint64, protobuf_unittest.TestIntIntMap> m_sint64 */ 6:
                    this.binaryReadMap6(message.mSint64, reader, options);
                    break;
                case /* map<fixed32, protobuf_unittest.TestIntIntMap> m_fixed32 */ 7:
                    this.binaryReadMap7(message.mFixed32, reader, options);
                    break;
                case /* map<fixed64, protobuf_unittest.TestIntIntMap> m_fixed64 */ 8:
                    this.binaryReadMap8(message.mFixed64, reader, options);
                    break;
                case /* map<sfixed32, protobuf_unittest.TestIntIntMap> m_sfixed32 */ 9:
                    this.binaryReadMap9(message.mSfixed32, reader, options);
                    break;
                case /* map<sfixed64, protobuf_unittest.TestIntIntMap> m_sfixed64 */ 10:
                    this.binaryReadMap10(message.mSfixed64, reader, options);
                    break;
                case /* map<bool, protobuf_unittest.TestIntIntMap> m_bool */ 11:
                    this.binaryReadMap11(message.mBool, reader, options);
                    break;
                case /* map<string, protobuf_unittest.TestIntIntMap> m_string */ 12:
                    this.binaryReadMap12(message.mString, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMaps["mInt32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mInt32"] | undefined, val: TestMaps["mInt32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_int32");
            }
        }
        map[key ?? 0] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap2(map: TestMaps["mInt64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mInt64"] | undefined, val: TestMaps["mInt64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_int64");
            }
        }
        map[key ?? "0"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap3(map: TestMaps["mUint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mUint32"] | undefined, val: TestMaps["mUint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_uint32");
            }
        }
        map[key ?? 0] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap4(map: TestMaps["mUint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mUint64"] | undefined, val: TestMaps["mUint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_uint64");
            }
        }
        map[key ?? "0"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap5(map: TestMaps["mSint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mSint32"] | undefined, val: TestMaps["mSint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint32();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_sint32");
            }
        }
        map[key ?? 0] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap6(map: TestMaps["mSint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mSint64"] | undefined, val: TestMaps["mSint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_sint64");
            }
        }
        map[key ?? "0"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap7(map: TestMaps["mFixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mFixed32"] | undefined, val: TestMaps["mFixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed32();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_fixed32");
            }
        }
        map[key ?? 0] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap8(map: TestMaps["mFixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mFixed64"] | undefined, val: TestMaps["mFixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_fixed64");
            }
        }
        map[key ?? "0"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap9(map: TestMaps["mSfixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mSfixed32"] | undefined, val: TestMaps["mSfixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed32();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_sfixed32");
            }
        }
        map[key ?? 0] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap10(map: TestMaps["mSfixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mSfixed64"] | undefined, val: TestMaps["mSfixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed64().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_sfixed64");
            }
        }
        map[key ?? "0"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap11(map: TestMaps["mBool"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mBool"] | undefined, val: TestMaps["mBool"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_bool");
            }
        }
        map[key ?? "false"] = val ?? TestIntIntMap.create();
    }
    private binaryReadMap12(map: TestMaps["mString"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMaps["mString"] | undefined, val: TestMaps["mString"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TestIntIntMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMaps.m_string");
            }
        }
        map[key ?? ""] = val ?? TestIntIntMap.create();
    }
    internalBinaryWrite(message: TestMaps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.TestIntIntMap> m_int32 = 1; */
        for (let k of globalThis.Object.keys(message.mInt32)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mInt32[k as any], writer, options);
            writer.join().join();
        }
        /* map<int64, protobuf_unittest.TestIntIntMap> m_int64 = 2; */
        for (let k of globalThis.Object.keys(message.mInt64)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mInt64[k], writer, options);
            writer.join().join();
        }
        /* map<uint32, protobuf_unittest.TestIntIntMap> m_uint32 = 3; */
        for (let k of globalThis.Object.keys(message.mUint32)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mUint32[k as any], writer, options);
            writer.join().join();
        }
        /* map<uint64, protobuf_unittest.TestIntIntMap> m_uint64 = 4; */
        for (let k of globalThis.Object.keys(message.mUint64)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mUint64[k], writer, options);
            writer.join().join();
        }
        /* map<sint32, protobuf_unittest.TestIntIntMap> m_sint32 = 5; */
        for (let k of globalThis.Object.keys(message.mSint32)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mSint32[k as any], writer, options);
            writer.join().join();
        }
        /* map<sint64, protobuf_unittest.TestIntIntMap> m_sint64 = 6; */
        for (let k of globalThis.Object.keys(message.mSint64)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mSint64[k], writer, options);
            writer.join().join();
        }
        /* map<fixed32, protobuf_unittest.TestIntIntMap> m_fixed32 = 7; */
        for (let k of globalThis.Object.keys(message.mFixed32)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).fixed32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mFixed32[k as any], writer, options);
            writer.join().join();
        }
        /* map<fixed64, protobuf_unittest.TestIntIntMap> m_fixed64 = 8; */
        for (let k of globalThis.Object.keys(message.mFixed64)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mFixed64[k], writer, options);
            writer.join().join();
        }
        /* map<sfixed32, protobuf_unittest.TestIntIntMap> m_sfixed32 = 9; */
        for (let k of globalThis.Object.keys(message.mSfixed32)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).sfixed32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mSfixed32[k as any], writer, options);
            writer.join().join();
        }
        /* map<sfixed64, protobuf_unittest.TestIntIntMap> m_sfixed64 = 10; */
        for (let k of globalThis.Object.keys(message.mSfixed64)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).sfixed64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mSfixed64[k], writer, options);
            writer.join().join();
        }
        /* map<bool, protobuf_unittest.TestIntIntMap> m_bool = 11; */
        for (let k of globalThis.Object.keys(message.mBool)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true");
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mBool[k], writer, options);
            writer.join().join();
        }
        /* map<string, protobuf_unittest.TestIntIntMap> m_string = 12; */
        for (let k of globalThis.Object.keys(message.mString)) {
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestIntIntMap.internalBinaryWrite(message.mString[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMaps
 */
export const TestMaps = new TestMaps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestSubmessageMaps$Type extends MessageType<TestSubmessageMaps> {
    constructor() {
        super("protobuf_unittest.TestSubmessageMaps", [
            { no: 1, name: "m", kind: "message", T: () => TestMaps }
        ]);
    }
    create(value?: PartialMessage<TestSubmessageMaps>): TestSubmessageMaps {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestSubmessageMaps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestSubmessageMaps): TestSubmessageMaps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional protobuf_unittest.TestMaps m */ 1:
                    message.m = TestMaps.internalBinaryRead(reader, reader.uint32(), options, message.m);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestSubmessageMaps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional protobuf_unittest.TestMaps m = 1; */
        if (message.m)
            TestMaps.internalBinaryWrite(message.m, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestSubmessageMaps
 */
export const TestSubmessageMaps = new TestSubmessageMaps$Type();
