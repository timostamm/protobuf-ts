// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/map_unittest.proto" (package "protobuf_unittest", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TestRequired } from "./unittest";
import { TestAllTypes } from "./unittest";
import { ForeignMessage } from "./unittest";
/**
 * Tests maps.
 *
 * @generated from protobuf message protobuf_unittest.TestMap
 */
export interface TestMap {
    /**
     * @generated from protobuf field: map<int32, int32> map_int32_int32 = 1;
     */
    mapInt32Int32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int64> map_int64_int64 = 2;
     */
    mapInt64Int64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> map_uint32_uint32 = 3;
     */
    mapUint32Uint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, uint64> map_uint64_uint64 = 4;
     */
    mapUint64Uint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sint32, sint32> map_sint32_sint32 = 5;
     */
    mapSint32Sint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sint64, sint64> map_sint64_sint64 = 6;
     */
    mapSint64Sint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<fixed32, fixed32> map_fixed32_fixed32 = 7;
     */
    mapFixed32Fixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<fixed64, fixed64> map_fixed64_fixed64 = 8;
     */
    mapFixed64Fixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9;
     */
    mapSfixed32Sfixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10;
     */
    mapSfixed64Sfixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, float> map_int32_float = 11;
     */
    mapInt32Float: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int32, double> map_int32_double = 12;
     */
    mapInt32Double: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<bool, bool> map_bool_bool = 13;
     */
    mapBoolBool: {
        [key: string]: boolean;
    };
    /**
     * @generated from protobuf field: map<string, string> map_string_string = 14;
     */
    mapStringString: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, bytes> map_int32_bytes = 15;
     */
    mapInt32Bytes: {
        [key: number]: Uint8Array;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.MapEnum> map_int32_enum = 16;
     */
    mapInt32Enum: {
        [key: number]: MapEnum;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message = 17;
     */
    mapInt32ForeignMessage: {
        [key: number]: ForeignMessage;
    };
    /**
     * @generated from protobuf field: map<string, protobuf_unittest.ForeignMessage> map_string_foreign_message = 18;
     */
    mapStringForeignMessage: {
        [key: string]: ForeignMessage;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestAllTypes> map_int32_all_types = 19;
     */
    mapInt32AllTypes: {
        [key: number]: TestAllTypes;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestMapSubmessage
 */
export interface TestMapSubmessage {
    /**
     * @generated from protobuf field: protobuf_unittest.TestMap test_map = 1;
     */
    testMap?: TestMap;
}
/**
 * @generated from protobuf message protobuf_unittest.TestMessageMap
 */
export interface TestMessageMap {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestAllTypes> map_int32_message = 1;
     */
    mapInt32Message: {
        [key: number]: TestAllTypes;
    };
}
/**
 * Two map fields share the same entry default instance.
 *
 * @generated from protobuf message protobuf_unittest.TestSameTypeMap
 */
export interface TestSameTypeMap {
    /**
     * @generated from protobuf field: map<int32, int32> map1 = 1;
     */
    map1: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int32, int32> map2 = 2;
     */
    map2: {
        [key: number]: number;
    };
}
/**
 * Test embedded message with required fields
 *
 * @generated from protobuf message protobuf_unittest.TestRequiredMessageMap
 */
export interface TestRequiredMessageMap {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestRequired> map_field = 1;
     */
    mapField: {
        [key: number]: TestRequired;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestArenaMap
 */
export interface TestArenaMap {
    /**
     * @generated from protobuf field: map<int32, int32> map_int32_int32 = 1;
     */
    mapInt32Int32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int64> map_int64_int64 = 2;
     */
    mapInt64Int64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> map_uint32_uint32 = 3;
     */
    mapUint32Uint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, uint64> map_uint64_uint64 = 4;
     */
    mapUint64Uint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sint32, sint32> map_sint32_sint32 = 5;
     */
    mapSint32Sint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sint64, sint64> map_sint64_sint64 = 6;
     */
    mapSint64Sint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<fixed32, fixed32> map_fixed32_fixed32 = 7;
     */
    mapFixed32Fixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<fixed64, fixed64> map_fixed64_fixed64 = 8;
     */
    mapFixed64Fixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9;
     */
    mapSfixed32Sfixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10;
     */
    mapSfixed64Sfixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, float> map_int32_float = 11;
     */
    mapInt32Float: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int32, double> map_int32_double = 12;
     */
    mapInt32Double: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<bool, bool> map_bool_bool = 13;
     */
    mapBoolBool: {
        [key: string]: boolean;
    };
    /**
     * @generated from protobuf field: map<string, string> map_string_string = 14;
     */
    mapStringString: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, bytes> map_int32_bytes = 15;
     */
    mapInt32Bytes: {
        [key: number]: Uint8Array;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.MapEnum> map_int32_enum = 16;
     */
    mapInt32Enum: {
        [key: number]: MapEnum;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message = 17;
     */
    mapInt32ForeignMessage: {
        [key: number]: ForeignMessage;
    };
}
/**
 * Previously, message containing enum called Type cannot be used as value of
 * map field.
 *
 * @generated from protobuf message protobuf_unittest.MessageContainingEnumCalledType
 */
export interface MessageContainingEnumCalledType {
    /**
     * @generated from protobuf field: map<string, protobuf_unittest.MessageContainingEnumCalledType> type = 1;
     */
    type: {
        [key: string]: MessageContainingEnumCalledType;
    };
}
/**
 * @generated from protobuf enum protobuf_unittest.MessageContainingEnumCalledType.Type
 */
export enum MessageContainingEnumCalledType_Type {
    /**
     * @generated from protobuf enum value: TYPE_FOO = 0;
     */
    FOO = 0
}
/**
 * Previously, message cannot contain map field called "entry".
 *
 * @generated from protobuf message protobuf_unittest.MessageContainingMapCalledEntry
 */
export interface MessageContainingMapCalledEntry {
    /**
     * @generated from protobuf field: map<int32, int32> entry = 1;
     */
    entry: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestRecursiveMapMessage
 */
export interface TestRecursiveMapMessage {
    /**
     * @generated from protobuf field: map<string, protobuf_unittest.TestRecursiveMapMessage> a = 1;
     */
    a: {
        [key: string]: TestRecursiveMapMessage;
    };
}
/**
 * @generated from protobuf enum protobuf_unittest.MapEnum
 */
export enum MapEnum {
    /**
     * @generated from protobuf enum value: MAP_ENUM_FOO = 0;
     */
    FOO = 0,
    /**
     * @generated from protobuf enum value: MAP_ENUM_BAR = 1;
     */
    BAR = 1,
    /**
     * @generated from protobuf enum value: MAP_ENUM_BAZ = 2;
     */
    BAZ = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TestMap$Type extends MessageType<TestMap> {
    constructor() {
        super("protobuf_unittest.TestMap", [
            { no: 1, name: "map_int32_int32", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "map_int64_int64", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 3, name: "map_uint32_uint32", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 4, name: "map_uint64_uint64", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/ } },
            { no: 5, name: "map_sint32_sint32", kind: "map", K: 17 /*ScalarType.SINT32*/, V: { kind: "scalar", T: 17 /*ScalarType.SINT32*/ } },
            { no: 6, name: "map_sint64_sint64", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "scalar", T: 18 /*ScalarType.SINT64*/ } },
            { no: 7, name: "map_fixed32_fixed32", kind: "map", K: 7 /*ScalarType.FIXED32*/, V: { kind: "scalar", T: 7 /*ScalarType.FIXED32*/ } },
            { no: 8, name: "map_fixed64_fixed64", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "scalar", T: 6 /*ScalarType.FIXED64*/ } },
            { no: 9, name: "map_sfixed32_sfixed32", kind: "map", K: 15 /*ScalarType.SFIXED32*/, V: { kind: "scalar", T: 15 /*ScalarType.SFIXED32*/ } },
            { no: 10, name: "map_sfixed64_sfixed64", kind: "map", K: 16 /*ScalarType.SFIXED64*/, V: { kind: "scalar", T: 16 /*ScalarType.SFIXED64*/ } },
            { no: 11, name: "map_int32_float", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 12, name: "map_int32_double", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 13, name: "map_bool_bool", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 14, name: "map_string_string", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "map_int32_bytes", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 16, name: "map_int32_enum", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.MapEnum", MapEnum, "MAP_ENUM_"] } },
            { no: 17, name: "map_int32_foreign_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ForeignMessage } },
            { no: 18, name: "map_string_foreign_message", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ForeignMessage } },
            { no: 19, name: "map_int32_all_types", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestAllTypes } }
        ]);
    }
    create(value?: PartialMessage<TestMap>): TestMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Int32 = {};
        message.mapInt64Int64 = {};
        message.mapUint32Uint32 = {};
        message.mapUint64Uint64 = {};
        message.mapSint32Sint32 = {};
        message.mapSint64Sint64 = {};
        message.mapFixed32Fixed32 = {};
        message.mapFixed64Fixed64 = {};
        message.mapSfixed32Sfixed32 = {};
        message.mapSfixed64Sfixed64 = {};
        message.mapInt32Float = {};
        message.mapInt32Double = {};
        message.mapBoolBool = {};
        message.mapStringString = {};
        message.mapInt32Bytes = {};
        message.mapInt32Enum = {};
        message.mapInt32ForeignMessage = {};
        message.mapStringForeignMessage = {};
        message.mapInt32AllTypes = {};
        if (value !== undefined)
            reflectionMergePartial<TestMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMap): TestMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map_int32_int32 */ 1:
                    this.binaryReadMap1(message.mapInt32Int32, reader, options);
                    break;
                case /* map<int64, int64> map_int64_int64 */ 2:
                    this.binaryReadMap2(message.mapInt64Int64, reader, options);
                    break;
                case /* map<uint32, uint32> map_uint32_uint32 */ 3:
                    this.binaryReadMap3(message.mapUint32Uint32, reader, options);
                    break;
                case /* map<uint64, uint64> map_uint64_uint64 */ 4:
                    this.binaryReadMap4(message.mapUint64Uint64, reader, options);
                    break;
                case /* map<sint32, sint32> map_sint32_sint32 */ 5:
                    this.binaryReadMap5(message.mapSint32Sint32, reader, options);
                    break;
                case /* map<sint64, sint64> map_sint64_sint64 */ 6:
                    this.binaryReadMap6(message.mapSint64Sint64, reader, options);
                    break;
                case /* map<fixed32, fixed32> map_fixed32_fixed32 */ 7:
                    this.binaryReadMap7(message.mapFixed32Fixed32, reader, options);
                    break;
                case /* map<fixed64, fixed64> map_fixed64_fixed64 */ 8:
                    this.binaryReadMap8(message.mapFixed64Fixed64, reader, options);
                    break;
                case /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 */ 9:
                    this.binaryReadMap9(message.mapSfixed32Sfixed32, reader, options);
                    break;
                case /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 */ 10:
                    this.binaryReadMap10(message.mapSfixed64Sfixed64, reader, options);
                    break;
                case /* map<int32, float> map_int32_float */ 11:
                    this.binaryReadMap11(message.mapInt32Float, reader, options);
                    break;
                case /* map<int32, double> map_int32_double */ 12:
                    this.binaryReadMap12(message.mapInt32Double, reader, options);
                    break;
                case /* map<bool, bool> map_bool_bool */ 13:
                    this.binaryReadMap13(message.mapBoolBool, reader, options);
                    break;
                case /* map<string, string> map_string_string */ 14:
                    this.binaryReadMap14(message.mapStringString, reader, options);
                    break;
                case /* map<int32, bytes> map_int32_bytes */ 15:
                    this.binaryReadMap15(message.mapInt32Bytes, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.MapEnum> map_int32_enum */ 16:
                    this.binaryReadMap16(message.mapInt32Enum, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message */ 17:
                    this.binaryReadMap17(message.mapInt32ForeignMessage, reader, options);
                    break;
                case /* map<string, protobuf_unittest.ForeignMessage> map_string_foreign_message */ 18:
                    this.binaryReadMap18(message.mapStringForeignMessage, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.TestAllTypes> map_int32_all_types */ 19:
                    this.binaryReadMap19(message.mapInt32AllTypes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMap["mapInt32Int32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32Int32"] | undefined, val: TestMap["mapInt32Int32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_int32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: TestMap["mapInt64Int64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt64Int64"] | undefined, val: TestMap["mapInt64Int64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int64_int64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap3(map: TestMap["mapUint32Uint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapUint32Uint32"] | undefined, val: TestMap["mapUint32Uint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_uint32_uint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap4(map: TestMap["mapUint64Uint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapUint64Uint64"] | undefined, val: TestMap["mapUint64Uint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.uint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_uint64_uint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap5(map: TestMap["mapSint32Sint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapSint32Sint32"] | undefined, val: TestMap["mapSint32Sint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint32();
                    break;
                case 2:
                    val = reader.sint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_sint32_sint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: TestMap["mapSint64Sint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapSint64Sint64"] | undefined, val: TestMap["mapSint64Sint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = reader.sint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_sint64_sint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap7(map: TestMap["mapFixed32Fixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapFixed32Fixed32"] | undefined, val: TestMap["mapFixed32Fixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed32();
                    break;
                case 2:
                    val = reader.fixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_fixed32_fixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap8(map: TestMap["mapFixed64Fixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapFixed64Fixed64"] | undefined, val: TestMap["mapFixed64Fixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = reader.fixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_fixed64_fixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap9(map: TestMap["mapSfixed32Sfixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapSfixed32Sfixed32"] | undefined, val: TestMap["mapSfixed32Sfixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed32();
                    break;
                case 2:
                    val = reader.sfixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_sfixed32_sfixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap10(map: TestMap["mapSfixed64Sfixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapSfixed64Sfixed64"] | undefined, val: TestMap["mapSfixed64Sfixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed64().toString();
                    break;
                case 2:
                    val = reader.sfixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_sfixed64_sfixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap11(map: TestMap["mapInt32Float"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32Float"] | undefined, val: TestMap["mapInt32Float"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_float");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap12(map: TestMap["mapInt32Double"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32Double"] | undefined, val: TestMap["mapInt32Double"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_double");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap13(map: TestMap["mapBoolBool"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapBoolBool"] | undefined, val: TestMap["mapBoolBool"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_bool_bool");
            }
        }
        map[key ?? "false"] = val ?? false;
    }
    private binaryReadMap14(map: TestMap["mapStringString"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapStringString"] | undefined, val: TestMap["mapStringString"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_string_string");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap15(map: TestMap["mapInt32Bytes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32Bytes"] | undefined, val: TestMap["mapInt32Bytes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_bytes");
            }
        }
        map[key ?? 0] = val ?? new Uint8Array(0);
    }
    private binaryReadMap16(map: TestMap["mapInt32Enum"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32Enum"] | undefined, val: TestMap["mapInt32Enum"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_enum");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap17(map: TestMap["mapInt32ForeignMessage"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32ForeignMessage"] | undefined, val: TestMap["mapInt32ForeignMessage"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_foreign_message");
            }
        }
        map[key ?? 0] = val ?? ForeignMessage.create();
    }
    private binaryReadMap18(map: TestMap["mapStringForeignMessage"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapStringForeignMessage"] | undefined, val: TestMap["mapStringForeignMessage"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_string_foreign_message");
            }
        }
        map[key ?? ""] = val ?? ForeignMessage.create();
    }
    private binaryReadMap19(map: TestMap["mapInt32AllTypes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMap["mapInt32AllTypes"] | undefined, val: TestMap["mapInt32AllTypes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMap.map_int32_all_types");
            }
        }
        map[key ?? 0] = val ?? TestAllTypes.create();
    }
    internalBinaryWrite(message: TestMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map_int32_int32 = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Int32))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Int32[k as any]).join();
        /* map<int64, int64> map_int64_int64 = 2; */
        for (let k of globalThis.Object.keys(message.mapInt64Int64))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int64(message.mapInt64Int64[k]).join();
        /* map<uint32, uint32> map_uint32_uint32 = 3; */
        for (let k of globalThis.Object.keys(message.mapUint32Uint32))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.mapUint32Uint32[k as any]).join();
        /* map<uint64, uint64> map_uint64_uint64 = 4; */
        for (let k of globalThis.Object.keys(message.mapUint64Uint64))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).uint64(message.mapUint64Uint64[k]).join();
        /* map<sint32, sint32> map_sint32_sint32 = 5; */
        for (let k of globalThis.Object.keys(message.mapSint32Sint32))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint32(parseInt(k)).tag(2, WireType.Varint).sint32(message.mapSint32Sint32[k as any]).join();
        /* map<sint64, sint64> map_sint64_sint64 = 6; */
        for (let k of globalThis.Object.keys(message.mapSint64Sint64))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.Varint).sint64(message.mapSint64Sint64[k]).join();
        /* map<fixed32, fixed32> map_fixed32_fixed32 = 7; */
        for (let k of globalThis.Object.keys(message.mapFixed32Fixed32))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).fixed32(parseInt(k)).tag(2, WireType.Bit32).fixed32(message.mapFixed32Fixed32[k as any]).join();
        /* map<fixed64, fixed64> map_fixed64_fixed64 = 8; */
        for (let k of globalThis.Object.keys(message.mapFixed64Fixed64))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k).tag(2, WireType.Bit64).fixed64(message.mapFixed64Fixed64[k]).join();
        /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9; */
        for (let k of globalThis.Object.keys(message.mapSfixed32Sfixed32))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).sfixed32(parseInt(k)).tag(2, WireType.Bit32).sfixed32(message.mapSfixed32Sfixed32[k as any]).join();
        /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10; */
        for (let k of globalThis.Object.keys(message.mapSfixed64Sfixed64))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).sfixed64(k).tag(2, WireType.Bit64).sfixed64(message.mapSfixed64Sfixed64[k]).join();
        /* map<int32, float> map_int32_float = 11; */
        for (let k of globalThis.Object.keys(message.mapInt32Float))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit32).float(message.mapInt32Float[k as any]).join();
        /* map<int32, double> map_int32_double = 12; */
        for (let k of globalThis.Object.keys(message.mapInt32Double))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.mapInt32Double[k as any]).join();
        /* map<bool, bool> map_bool_bool = 13; */
        for (let k of globalThis.Object.keys(message.mapBoolBool))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).bool(message.mapBoolBool[k]).join();
        /* map<string, string> map_string_string = 14; */
        for (let k of globalThis.Object.keys(message.mapStringString))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapStringString[k]).join();
        /* map<int32, bytes> map_int32_bytes = 15; */
        for (let k of globalThis.Object.keys(message.mapInt32Bytes))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).bytes(message.mapInt32Bytes[k as any]).join();
        /* map<int32, protobuf_unittest.MapEnum> map_int32_enum = 16; */
        for (let k of globalThis.Object.keys(message.mapInt32Enum))
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Enum[k as any]).join();
        /* map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message = 17; */
        for (let k of globalThis.Object.keys(message.mapInt32ForeignMessage)) {
            writer.tag(17, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForeignMessage.internalBinaryWrite(message.mapInt32ForeignMessage[k as any], writer, options);
            writer.join().join();
        }
        /* map<string, protobuf_unittest.ForeignMessage> map_string_foreign_message = 18; */
        for (let k of globalThis.Object.keys(message.mapStringForeignMessage)) {
            writer.tag(18, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ForeignMessage.internalBinaryWrite(message.mapStringForeignMessage[k], writer, options);
            writer.join().join();
        }
        /* map<int32, protobuf_unittest.TestAllTypes> map_int32_all_types = 19; */
        for (let k of globalThis.Object.keys(message.mapInt32AllTypes)) {
            writer.tag(19, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestAllTypes.internalBinaryWrite(message.mapInt32AllTypes[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMap
 */
export const TestMap = new TestMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMapSubmessage$Type extends MessageType<TestMapSubmessage> {
    constructor() {
        super("protobuf_unittest.TestMapSubmessage", [
            { no: 1, name: "test_map", kind: "message", T: () => TestMap }
        ]);
    }
    create(value?: PartialMessage<TestMapSubmessage>): TestMapSubmessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestMapSubmessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMapSubmessage): TestMapSubmessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protobuf_unittest.TestMap test_map */ 1:
                    message.testMap = TestMap.internalBinaryRead(reader, reader.uint32(), options, message.testMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestMapSubmessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protobuf_unittest.TestMap test_map = 1; */
        if (message.testMap)
            TestMap.internalBinaryWrite(message.testMap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMapSubmessage
 */
export const TestMapSubmessage = new TestMapSubmessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMessageMap$Type extends MessageType<TestMessageMap> {
    constructor() {
        super("protobuf_unittest.TestMessageMap", [
            { no: 1, name: "map_int32_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestAllTypes } }
        ]);
    }
    create(value?: PartialMessage<TestMessageMap>): TestMessageMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Message = {};
        if (value !== undefined)
            reflectionMergePartial<TestMessageMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMessageMap): TestMessageMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.TestAllTypes> map_int32_message */ 1:
                    this.binaryReadMap1(message.mapInt32Message, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMessageMap["mapInt32Message"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMessageMap["mapInt32Message"] | undefined, val: TestMessageMap["mapInt32Message"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestAllTypes.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestMessageMap.map_int32_message");
            }
        }
        map[key ?? 0] = val ?? TestAllTypes.create();
    }
    internalBinaryWrite(message: TestMessageMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.TestAllTypes> map_int32_message = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Message)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestAllTypes.internalBinaryWrite(message.mapInt32Message[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMessageMap
 */
export const TestMessageMap = new TestMessageMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestSameTypeMap$Type extends MessageType<TestSameTypeMap> {
    constructor() {
        super("protobuf_unittest.TestSameTypeMap", [
            { no: 1, name: "map1", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "map2", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestSameTypeMap>): TestSameTypeMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map1 = {};
        message.map2 = {};
        if (value !== undefined)
            reflectionMergePartial<TestSameTypeMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestSameTypeMap): TestSameTypeMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map1 */ 1:
                    this.binaryReadMap1(message.map1, reader, options);
                    break;
                case /* map<int32, int32> map2 */ 2:
                    this.binaryReadMap2(message.map2, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestSameTypeMap["map1"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestSameTypeMap["map1"] | undefined, val: TestSameTypeMap["map1"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestSameTypeMap.map1");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: TestSameTypeMap["map2"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestSameTypeMap["map2"] | undefined, val: TestSameTypeMap["map2"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestSameTypeMap.map2");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestSameTypeMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map1 = 1; */
        for (let k of globalThis.Object.keys(message.map1))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.map1[k as any]).join();
        /* map<int32, int32> map2 = 2; */
        for (let k of globalThis.Object.keys(message.map2))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.map2[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestSameTypeMap
 */
export const TestSameTypeMap = new TestSameTypeMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredMessageMap$Type extends MessageType<TestRequiredMessageMap> {
    constructor() {
        super("protobuf_unittest.TestRequiredMessageMap", [
            { no: 1, name: "map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestRequired } }
        ]);
    }
    create(value?: PartialMessage<TestRequiredMessageMap>): TestRequiredMessageMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestRequiredMessageMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredMessageMap): TestRequiredMessageMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.TestRequired> map_field */ 1:
                    this.binaryReadMap1(message.mapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestRequiredMessageMap["mapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestRequiredMessageMap["mapField"] | undefined, val: TestRequiredMessageMap["mapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestRequired.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestRequiredMessageMap.map_field");
            }
        }
        map[key ?? 0] = val ?? TestRequired.create();
    }
    internalBinaryWrite(message: TestRequiredMessageMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.TestRequired> map_field = 1; */
        for (let k of globalThis.Object.keys(message.mapField)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestRequired.internalBinaryWrite(message.mapField[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredMessageMap
 */
export const TestRequiredMessageMap = new TestRequiredMessageMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestArenaMap$Type extends MessageType<TestArenaMap> {
    constructor() {
        super("protobuf_unittest.TestArenaMap", [
            { no: 1, name: "map_int32_int32", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "map_int64_int64", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 3, name: "map_uint32_uint32", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 4, name: "map_uint64_uint64", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/ } },
            { no: 5, name: "map_sint32_sint32", kind: "map", K: 17 /*ScalarType.SINT32*/, V: { kind: "scalar", T: 17 /*ScalarType.SINT32*/ } },
            { no: 6, name: "map_sint64_sint64", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "scalar", T: 18 /*ScalarType.SINT64*/ } },
            { no: 7, name: "map_fixed32_fixed32", kind: "map", K: 7 /*ScalarType.FIXED32*/, V: { kind: "scalar", T: 7 /*ScalarType.FIXED32*/ } },
            { no: 8, name: "map_fixed64_fixed64", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "scalar", T: 6 /*ScalarType.FIXED64*/ } },
            { no: 9, name: "map_sfixed32_sfixed32", kind: "map", K: 15 /*ScalarType.SFIXED32*/, V: { kind: "scalar", T: 15 /*ScalarType.SFIXED32*/ } },
            { no: 10, name: "map_sfixed64_sfixed64", kind: "map", K: 16 /*ScalarType.SFIXED64*/, V: { kind: "scalar", T: 16 /*ScalarType.SFIXED64*/ } },
            { no: 11, name: "map_int32_float", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 12, name: "map_int32_double", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 13, name: "map_bool_bool", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 14, name: "map_string_string", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "map_int32_bytes", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 16, name: "map_int32_enum", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.MapEnum", MapEnum, "MAP_ENUM_"] } },
            { no: 17, name: "map_int32_foreign_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ForeignMessage } }
        ]);
    }
    create(value?: PartialMessage<TestArenaMap>): TestArenaMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Int32 = {};
        message.mapInt64Int64 = {};
        message.mapUint32Uint32 = {};
        message.mapUint64Uint64 = {};
        message.mapSint32Sint32 = {};
        message.mapSint64Sint64 = {};
        message.mapFixed32Fixed32 = {};
        message.mapFixed64Fixed64 = {};
        message.mapSfixed32Sfixed32 = {};
        message.mapSfixed64Sfixed64 = {};
        message.mapInt32Float = {};
        message.mapInt32Double = {};
        message.mapBoolBool = {};
        message.mapStringString = {};
        message.mapInt32Bytes = {};
        message.mapInt32Enum = {};
        message.mapInt32ForeignMessage = {};
        if (value !== undefined)
            reflectionMergePartial<TestArenaMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestArenaMap): TestArenaMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map_int32_int32 */ 1:
                    this.binaryReadMap1(message.mapInt32Int32, reader, options);
                    break;
                case /* map<int64, int64> map_int64_int64 */ 2:
                    this.binaryReadMap2(message.mapInt64Int64, reader, options);
                    break;
                case /* map<uint32, uint32> map_uint32_uint32 */ 3:
                    this.binaryReadMap3(message.mapUint32Uint32, reader, options);
                    break;
                case /* map<uint64, uint64> map_uint64_uint64 */ 4:
                    this.binaryReadMap4(message.mapUint64Uint64, reader, options);
                    break;
                case /* map<sint32, sint32> map_sint32_sint32 */ 5:
                    this.binaryReadMap5(message.mapSint32Sint32, reader, options);
                    break;
                case /* map<sint64, sint64> map_sint64_sint64 */ 6:
                    this.binaryReadMap6(message.mapSint64Sint64, reader, options);
                    break;
                case /* map<fixed32, fixed32> map_fixed32_fixed32 */ 7:
                    this.binaryReadMap7(message.mapFixed32Fixed32, reader, options);
                    break;
                case /* map<fixed64, fixed64> map_fixed64_fixed64 */ 8:
                    this.binaryReadMap8(message.mapFixed64Fixed64, reader, options);
                    break;
                case /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 */ 9:
                    this.binaryReadMap9(message.mapSfixed32Sfixed32, reader, options);
                    break;
                case /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 */ 10:
                    this.binaryReadMap10(message.mapSfixed64Sfixed64, reader, options);
                    break;
                case /* map<int32, float> map_int32_float */ 11:
                    this.binaryReadMap11(message.mapInt32Float, reader, options);
                    break;
                case /* map<int32, double> map_int32_double */ 12:
                    this.binaryReadMap12(message.mapInt32Double, reader, options);
                    break;
                case /* map<bool, bool> map_bool_bool */ 13:
                    this.binaryReadMap13(message.mapBoolBool, reader, options);
                    break;
                case /* map<string, string> map_string_string */ 14:
                    this.binaryReadMap14(message.mapStringString, reader, options);
                    break;
                case /* map<int32, bytes> map_int32_bytes */ 15:
                    this.binaryReadMap15(message.mapInt32Bytes, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.MapEnum> map_int32_enum */ 16:
                    this.binaryReadMap16(message.mapInt32Enum, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message */ 17:
                    this.binaryReadMap17(message.mapInt32ForeignMessage, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestArenaMap["mapInt32Int32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32Int32"] | undefined, val: TestArenaMap["mapInt32Int32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_int32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: TestArenaMap["mapInt64Int64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt64Int64"] | undefined, val: TestArenaMap["mapInt64Int64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int64_int64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap3(map: TestArenaMap["mapUint32Uint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapUint32Uint32"] | undefined, val: TestArenaMap["mapUint32Uint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_uint32_uint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap4(map: TestArenaMap["mapUint64Uint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapUint64Uint64"] | undefined, val: TestArenaMap["mapUint64Uint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.uint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_uint64_uint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap5(map: TestArenaMap["mapSint32Sint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapSint32Sint32"] | undefined, val: TestArenaMap["mapSint32Sint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint32();
                    break;
                case 2:
                    val = reader.sint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_sint32_sint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: TestArenaMap["mapSint64Sint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapSint64Sint64"] | undefined, val: TestArenaMap["mapSint64Sint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = reader.sint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_sint64_sint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap7(map: TestArenaMap["mapFixed32Fixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapFixed32Fixed32"] | undefined, val: TestArenaMap["mapFixed32Fixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed32();
                    break;
                case 2:
                    val = reader.fixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_fixed32_fixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap8(map: TestArenaMap["mapFixed64Fixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapFixed64Fixed64"] | undefined, val: TestArenaMap["mapFixed64Fixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = reader.fixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_fixed64_fixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap9(map: TestArenaMap["mapSfixed32Sfixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapSfixed32Sfixed32"] | undefined, val: TestArenaMap["mapSfixed32Sfixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed32();
                    break;
                case 2:
                    val = reader.sfixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_sfixed32_sfixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap10(map: TestArenaMap["mapSfixed64Sfixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapSfixed64Sfixed64"] | undefined, val: TestArenaMap["mapSfixed64Sfixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed64().toString();
                    break;
                case 2:
                    val = reader.sfixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_sfixed64_sfixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap11(map: TestArenaMap["mapInt32Float"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32Float"] | undefined, val: TestArenaMap["mapInt32Float"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_float");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap12(map: TestArenaMap["mapInt32Double"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32Double"] | undefined, val: TestArenaMap["mapInt32Double"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_double");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap13(map: TestArenaMap["mapBoolBool"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapBoolBool"] | undefined, val: TestArenaMap["mapBoolBool"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_bool_bool");
            }
        }
        map[key ?? "false"] = val ?? false;
    }
    private binaryReadMap14(map: TestArenaMap["mapStringString"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapStringString"] | undefined, val: TestArenaMap["mapStringString"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_string_string");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap15(map: TestArenaMap["mapInt32Bytes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32Bytes"] | undefined, val: TestArenaMap["mapInt32Bytes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_bytes");
            }
        }
        map[key ?? 0] = val ?? new Uint8Array(0);
    }
    private binaryReadMap16(map: TestArenaMap["mapInt32Enum"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32Enum"] | undefined, val: TestArenaMap["mapInt32Enum"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_enum");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap17(map: TestArenaMap["mapInt32ForeignMessage"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMap["mapInt32ForeignMessage"] | undefined, val: TestArenaMap["mapInt32ForeignMessage"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ForeignMessage.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestArenaMap.map_int32_foreign_message");
            }
        }
        map[key ?? 0] = val ?? ForeignMessage.create();
    }
    internalBinaryWrite(message: TestArenaMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map_int32_int32 = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Int32))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Int32[k as any]).join();
        /* map<int64, int64> map_int64_int64 = 2; */
        for (let k of globalThis.Object.keys(message.mapInt64Int64))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int64(message.mapInt64Int64[k]).join();
        /* map<uint32, uint32> map_uint32_uint32 = 3; */
        for (let k of globalThis.Object.keys(message.mapUint32Uint32))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.mapUint32Uint32[k as any]).join();
        /* map<uint64, uint64> map_uint64_uint64 = 4; */
        for (let k of globalThis.Object.keys(message.mapUint64Uint64))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).uint64(message.mapUint64Uint64[k]).join();
        /* map<sint32, sint32> map_sint32_sint32 = 5; */
        for (let k of globalThis.Object.keys(message.mapSint32Sint32))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint32(parseInt(k)).tag(2, WireType.Varint).sint32(message.mapSint32Sint32[k as any]).join();
        /* map<sint64, sint64> map_sint64_sint64 = 6; */
        for (let k of globalThis.Object.keys(message.mapSint64Sint64))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.Varint).sint64(message.mapSint64Sint64[k]).join();
        /* map<fixed32, fixed32> map_fixed32_fixed32 = 7; */
        for (let k of globalThis.Object.keys(message.mapFixed32Fixed32))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).fixed32(parseInt(k)).tag(2, WireType.Bit32).fixed32(message.mapFixed32Fixed32[k as any]).join();
        /* map<fixed64, fixed64> map_fixed64_fixed64 = 8; */
        for (let k of globalThis.Object.keys(message.mapFixed64Fixed64))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k).tag(2, WireType.Bit64).fixed64(message.mapFixed64Fixed64[k]).join();
        /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9; */
        for (let k of globalThis.Object.keys(message.mapSfixed32Sfixed32))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).sfixed32(parseInt(k)).tag(2, WireType.Bit32).sfixed32(message.mapSfixed32Sfixed32[k as any]).join();
        /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10; */
        for (let k of globalThis.Object.keys(message.mapSfixed64Sfixed64))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).sfixed64(k).tag(2, WireType.Bit64).sfixed64(message.mapSfixed64Sfixed64[k]).join();
        /* map<int32, float> map_int32_float = 11; */
        for (let k of globalThis.Object.keys(message.mapInt32Float))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit32).float(message.mapInt32Float[k as any]).join();
        /* map<int32, double> map_int32_double = 12; */
        for (let k of globalThis.Object.keys(message.mapInt32Double))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.mapInt32Double[k as any]).join();
        /* map<bool, bool> map_bool_bool = 13; */
        for (let k of globalThis.Object.keys(message.mapBoolBool))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).bool(message.mapBoolBool[k]).join();
        /* map<string, string> map_string_string = 14; */
        for (let k of globalThis.Object.keys(message.mapStringString))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapStringString[k]).join();
        /* map<int32, bytes> map_int32_bytes = 15; */
        for (let k of globalThis.Object.keys(message.mapInt32Bytes))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).bytes(message.mapInt32Bytes[k as any]).join();
        /* map<int32, protobuf_unittest.MapEnum> map_int32_enum = 16; */
        for (let k of globalThis.Object.keys(message.mapInt32Enum))
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Enum[k as any]).join();
        /* map<int32, protobuf_unittest.ForeignMessage> map_int32_foreign_message = 17; */
        for (let k of globalThis.Object.keys(message.mapInt32ForeignMessage)) {
            writer.tag(17, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForeignMessage.internalBinaryWrite(message.mapInt32ForeignMessage[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestArenaMap
 */
export const TestArenaMap = new TestArenaMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageContainingEnumCalledType$Type extends MessageType<MessageContainingEnumCalledType> {
    constructor() {
        super("protobuf_unittest.MessageContainingEnumCalledType", [
            { no: 1, name: "type", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MessageContainingEnumCalledType } }
        ]);
    }
    create(value?: PartialMessage<MessageContainingEnumCalledType>): MessageContainingEnumCalledType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = {};
        if (value !== undefined)
            reflectionMergePartial<MessageContainingEnumCalledType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageContainingEnumCalledType): MessageContainingEnumCalledType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protobuf_unittest.MessageContainingEnumCalledType> type */ 1:
                    this.binaryReadMap1(message.type, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MessageContainingEnumCalledType["type"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MessageContainingEnumCalledType["type"] | undefined, val: MessageContainingEnumCalledType["type"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MessageContainingEnumCalledType.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.MessageContainingEnumCalledType.type");
            }
        }
        map[key ?? ""] = val ?? MessageContainingEnumCalledType.create();
    }
    internalBinaryWrite(message: MessageContainingEnumCalledType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protobuf_unittest.MessageContainingEnumCalledType> type = 1; */
        for (let k of globalThis.Object.keys(message.type)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MessageContainingEnumCalledType.internalBinaryWrite(message.type[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.MessageContainingEnumCalledType
 */
export const MessageContainingEnumCalledType = new MessageContainingEnumCalledType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageContainingMapCalledEntry$Type extends MessageType<MessageContainingMapCalledEntry> {
    constructor() {
        super("protobuf_unittest.MessageContainingMapCalledEntry", [
            { no: 1, name: "entry", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<MessageContainingMapCalledEntry>): MessageContainingMapCalledEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entry = {};
        if (value !== undefined)
            reflectionMergePartial<MessageContainingMapCalledEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageContainingMapCalledEntry): MessageContainingMapCalledEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> entry */ 1:
                    this.binaryReadMap1(message.entry, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MessageContainingMapCalledEntry["entry"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MessageContainingMapCalledEntry["entry"] | undefined, val: MessageContainingMapCalledEntry["entry"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.MessageContainingMapCalledEntry.entry");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: MessageContainingMapCalledEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> entry = 1; */
        for (let k of globalThis.Object.keys(message.entry))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.entry[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.MessageContainingMapCalledEntry
 */
export const MessageContainingMapCalledEntry = new MessageContainingMapCalledEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRecursiveMapMessage$Type extends MessageType<TestRecursiveMapMessage> {
    constructor() {
        super("protobuf_unittest.TestRecursiveMapMessage", [
            { no: 1, name: "a", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TestRecursiveMapMessage } }
        ]);
    }
    create(value?: PartialMessage<TestRecursiveMapMessage>): TestRecursiveMapMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.a = {};
        if (value !== undefined)
            reflectionMergePartial<TestRecursiveMapMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRecursiveMapMessage): TestRecursiveMapMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protobuf_unittest.TestRecursiveMapMessage> a */ 1:
                    this.binaryReadMap1(message.a, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestRecursiveMapMessage["a"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestRecursiveMapMessage["a"] | undefined, val: TestRecursiveMapMessage["a"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TestRecursiveMapMessage.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protobuf_unittest.TestRecursiveMapMessage.a");
            }
        }
        map[key ?? ""] = val ?? TestRecursiveMapMessage.create();
    }
    internalBinaryWrite(message: TestRecursiveMapMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protobuf_unittest.TestRecursiveMapMessage> a = 1; */
        for (let k of globalThis.Object.keys(message.a)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TestRecursiveMapMessage.internalBinaryWrite(message.a[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRecursiveMapMessage
 */
export const TestRecursiveMapMessage = new TestRecursiveMapMessage$Type();
