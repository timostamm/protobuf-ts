// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "name-clash.proto" (package "spec", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message spec.ReservedFieldNames
 */
export interface ReservedFieldNames {
    /**
     * not allowed as object property, should be escaped
     *
     * @generated from protobuf field: string __proto__ = 1;
     */
    Proto: string;
    /**
     * not allowed as object property, should be escaped
     *
     * @generated from protobuf field: string to_string = 2;
     */
    toString$: string;
    /**
     * reserved for our ADT discriminator, should be escaped
     *
     * @generated from protobuf field: string oneofKind = 3;
     */
    oneofKind$: string;
}
/**
 * @generated from protobuf message spec.ReservedFieldNamesInOneof
 */
export interface ReservedFieldNamesInOneof {
    /**
     * @generated from protobuf oneof: oneof_group
     */
    oneofGroup: {
        oneofKind: "oneofKind$";
        /**
         * reserved for our ADT discriminator, should be escaped
         *
         * @generated from protobuf field: string oneofKind = 1;
         */
        oneofKind$: string;
    } | {
        oneofKind: "Proto";
        /**
         * not allowed as object property, should be escaped
         *
         * @generated from protobuf field: string __proto__ = 2;
         */
        Proto: string;
    } | {
        oneofKind: "toString$";
        /**
         * not allowed as object property, should be escaped
         *
         * @generated from protobuf field: string to_string = 3;
         */
        toString$: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.interface
 */
export interface interface$ {
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.function
 */
export interface function$ {
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.instanceof
 */
export interface instanceof$ {
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.switch
 */
export interface switch$ {
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.case
 */
export interface case$ {
}
/**
 * reserved word, should be escaped
 *
 * @generated from protobuf message spec.return
 */
export interface return$ {
}
/**
 * clash with runtime, must either be escaped or
 * `MessageType` must be imported under different name
 *
 * @generated from protobuf message spec.MessageType
 */
export interface MessageType {
}
/**
 * clash with global type "Error"
 * either this message name is escaped in generated code, or the generated
 * code must escape it's calls to the global error object (i.e. `new Error`)
 *
 * @generated from protobuf message spec.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string field_name = 1;
     */
    fieldName: string;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.Object
 */
export interface Object {
}
/**
 * @generated from protobuf message spec.object
 */
export interface object$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.Uint8Array
 */
export interface Uint8Array$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.array
 */
export interface array$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.Array
 */
export interface Array$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.string
 */
export interface string$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.String
 */
export interface String$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.number
 */
export interface number$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.Number
 */
export interface Number$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.boolean
 */
export interface boolean$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.Boolean
 */
export interface Boolean$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.bigint
 */
export interface bigint$ {
}
/**
 * clash with global type
 *
 * @generated from protobuf message spec.BigInt
 */
export interface BigInt$ {
}
/**
 * @generated from protobuf message spec.ClashParent
 */
export interface ClashParent {
}
/**
 * should clash with message ClashParent_ClashChild
 *
 * @generated from protobuf message spec.ClashParent.ClashChild
 */
export interface ClashParent_ClashChild {
}
/**
 * should clash with name of ClashParent.ClashChild
 *
 * @generated from protobuf message spec.ClashParent_ClashChild
 */
export interface ClashParent_ClashChild$1 {
}
/**
 * @generated from protobuf message spec.NoClashFields
 */
export interface NoClashFields {
    /**
     * ok as object property
     *
     * @generated from protobuf field: string const = 1;
     */
    const: string;
    /**
     * ok as object property
     *
     * @generated from protobuf field: string switch = 2;
     */
    switch: string;
    /**
     * ok as object property
     *
     * @generated from protobuf field: string case = 3;
     */
    case: string;
    /**
     * ok as object property
     *
     * @generated from protobuf field: string function = 4;
     */
    function: string;
    /**
     * ok as object property
     *
     * @generated from protobuf field: string interface = 5;
     */
    interface: string;
    /**
     * ok as object property
     *
     * @generated from protobuf field: string return = 6;
     */
    return: string;
}
/**
 * @generated from protobuf message spec.NoClashOneof
 */
export interface NoClashOneof {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "const";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string const = 1;
         */
        const: string;
    } | {
        oneofKind: "switch";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string switch = 2;
         */
        switch: string;
    } | {
        oneofKind: "case";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string case = 3;
         */
        case: string;
    } | {
        oneofKind: "function";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string function = 4;
         */
        function: string;
    } | {
        oneofKind: "interface";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string interface = 5;
         */
        interface: string;
    } | {
        oneofKind: "return";
        /**
         * ok as object property
         *
         * @generated from protobuf field: string return = 6;
         */
        return: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * just here as a "namespace" for the enum
 *
 * @generated from protobuf message spec.NoClashEnumWrap
 */
export interface NoClashEnumWrap {
}
/**
 * @generated from protobuf enum spec.NoClashEnumWrap.X
 */
export enum NoClashEnumWrap_X {
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: instanceof = 0;
     */
    instanceof = 0,
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: switch = 1;
     */
    switch = 1,
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: case = 3;
     */
    case = 3,
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: function = 4;
     */
    function = 4,
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: interface = 5;
     */
    interface = 5,
    /**
     * ok as object property
     *
     * @generated from protobuf enum value: return = 6;
     */
    return = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class ReservedFieldNames$Type extends MessageType$<ReservedFieldNames> {
    constructor() {
        super("spec.ReservedFieldNames", [
            { no: 1, name: "__proto__", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_string", kind: "scalar", localName: "toString$", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "oneofKind", kind: "scalar", localName: "oneofKind$", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReservedFieldNames>): ReservedFieldNames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.Proto = "";
        message.toString$ = "";
        message.oneofKind$ = "";
        if (value !== undefined)
            reflectionMergePartial<ReservedFieldNames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReservedFieldNames): ReservedFieldNames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string __proto__ */ 1:
                    message.Proto = reader.string();
                    break;
                case /* string to_string */ 2:
                    message.toString$ = reader.string();
                    break;
                case /* string oneofKind */ 3:
                    message.oneofKind$ = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReservedFieldNames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string __proto__ = 1; */
        if (message.Proto !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.Proto);
        /* string to_string = 2; */
        if (message.toString$ !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toString$);
        /* string oneofKind = 3; */
        if (message.oneofKind$ !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oneofKind$);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.ReservedFieldNames
 */
export const ReservedFieldNames = new ReservedFieldNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReservedFieldNamesInOneof$Type extends MessageType$<ReservedFieldNamesInOneof> {
    constructor() {
        super("spec.ReservedFieldNamesInOneof", [
            { no: 1, name: "oneofKind", kind: "scalar", localName: "oneofKind$", oneof: "oneofGroup", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "__proto__", kind: "scalar", oneof: "oneofGroup", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "to_string", kind: "scalar", localName: "toString$", oneof: "oneofGroup", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReservedFieldNamesInOneof>): ReservedFieldNamesInOneof {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oneofGroup = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReservedFieldNamesInOneof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReservedFieldNamesInOneof): ReservedFieldNamesInOneof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string oneofKind */ 1:
                    message.oneofGroup = {
                        oneofKind: "oneofKind$",
                        oneofKind$: reader.string()
                    };
                    break;
                case /* string __proto__ */ 2:
                    message.oneofGroup = {
                        oneofKind: "Proto",
                        Proto: reader.string()
                    };
                    break;
                case /* string to_string */ 3:
                    message.oneofGroup = {
                        oneofKind: "toString$",
                        toString$: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReservedFieldNamesInOneof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string oneofKind = 1; */
        if (message.oneofGroup.oneofKind === "oneofKind$")
            writer.tag(1, WireType.LengthDelimited).string(message.oneofGroup.oneofKind$);
        /* string __proto__ = 2; */
        if (message.oneofGroup.oneofKind === "Proto")
            writer.tag(2, WireType.LengthDelimited).string(message.oneofGroup.Proto);
        /* string to_string = 3; */
        if (message.oneofGroup.oneofKind === "toString$")
            writer.tag(3, WireType.LengthDelimited).string(message.oneofGroup.toString$);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.ReservedFieldNamesInOneof
 */
export const ReservedFieldNamesInOneof = new ReservedFieldNamesInOneof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class interface$$Type extends MessageType$<interface$> {
    constructor() {
        super("spec.interface", []);
    }
    create(value?: PartialMessage<interface$>): interface$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<interface$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: interface$): interface$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: interface$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.interface
 */
export const interface$ = new interface$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class function$$Type extends MessageType$<function$> {
    constructor() {
        super("spec.function", []);
    }
    create(value?: PartialMessage<function$>): function$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<function$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: function$): function$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: function$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.function
 */
export const function$ = new function$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class instanceof$$Type extends MessageType$<instanceof$> {
    constructor() {
        super("spec.instanceof", []);
    }
    create(value?: PartialMessage<instanceof$>): instanceof$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<instanceof$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: instanceof$): instanceof$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: instanceof$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.instanceof
 */
export const instanceof$ = new instanceof$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class switch$$Type extends MessageType$<switch$> {
    constructor() {
        super("spec.switch", []);
    }
    create(value?: PartialMessage<switch$>): switch$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<switch$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: switch$): switch$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: switch$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.switch
 */
export const switch$ = new switch$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class case$$Type extends MessageType$<case$> {
    constructor() {
        super("spec.case", []);
    }
    create(value?: PartialMessage<case$>): case$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<case$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: case$): case$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: case$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.case
 */
export const case$ = new case$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class return$$Type extends MessageType$<return$> {
    constructor() {
        super("spec.return", []);
    }
    create(value?: PartialMessage<return$>): return$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<return$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: return$): return$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: return$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.return
 */
export const return$ = new return$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageType$Type extends MessageType$<MessageType> {
    constructor() {
        super("spec.MessageType", []);
    }
    create(value?: PartialMessage<MessageType>): MessageType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessageType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageType): MessageType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.MessageType
 */
export const MessageType = new MessageType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType$<Error> {
    constructor() {
        super("spec.Error", [
            { no: 1, name: "field_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fieldName = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field_name */ 1:
                    message.fieldName = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field_name = 1; */
        if (message.fieldName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fieldName);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType$<Object> {
    constructor() {
        super("spec.Object", []);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class object$$Type extends MessageType$<object$> {
    constructor() {
        super("spec.object", []);
    }
    create(value?: PartialMessage<object$>): object$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<object$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: object$): object$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: object$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.object
 */
export const object$ = new object$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uint8Array$$Type extends MessageType$<Uint8Array$> {
    constructor() {
        super("spec.Uint8Array", []);
    }
    create(value?: PartialMessage<Uint8Array$>): Uint8Array$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Uint8Array$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uint8Array$): Uint8Array$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uint8Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Uint8Array
 */
export const Uint8Array$ = new Uint8Array$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class array$$Type extends MessageType$<array$> {
    constructor() {
        super("spec.array", []);
    }
    create(value?: PartialMessage<array$>): array$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<array$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: array$): array$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.array
 */
export const array$ = new array$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Array$$Type extends MessageType$<Array$> {
    constructor() {
        super("spec.Array", []);
    }
    create(value?: PartialMessage<Array$>): Array$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Array$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Array$): Array$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Array
 */
export const Array$ = new Array$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class string$$Type extends MessageType$<string$> {
    constructor() {
        super("spec.string", []);
    }
    create(value?: PartialMessage<string$>): string$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<string$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: string$): string$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: string$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.string
 */
export const string$ = new string$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class String$$Type extends MessageType$<String$> {
    constructor() {
        super("spec.String", []);
    }
    create(value?: PartialMessage<String$>): String$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<String$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: String$): String$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: String$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.String
 */
export const String$ = new String$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class number$$Type extends MessageType$<number$> {
    constructor() {
        super("spec.number", []);
    }
    create(value?: PartialMessage<number$>): number$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<number$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: number$): number$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: number$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.number
 */
export const number$ = new number$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Number$$Type extends MessageType$<Number$> {
    constructor() {
        super("spec.Number", []);
    }
    create(value?: PartialMessage<Number$>): Number$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Number$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Number$): Number$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Number$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Number
 */
export const Number$ = new Number$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class boolean$$Type extends MessageType$<boolean$> {
    constructor() {
        super("spec.boolean", []);
    }
    create(value?: PartialMessage<boolean$>): boolean$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<boolean$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: boolean$): boolean$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: boolean$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.boolean
 */
export const boolean$ = new boolean$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Boolean$$Type extends MessageType$<Boolean$> {
    constructor() {
        super("spec.Boolean", []);
    }
    create(value?: PartialMessage<Boolean$>): Boolean$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Boolean$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Boolean$): Boolean$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Boolean$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.Boolean
 */
export const Boolean$ = new Boolean$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class bigint$$Type extends MessageType$<bigint$> {
    constructor() {
        super("spec.bigint", []);
    }
    create(value?: PartialMessage<bigint$>): bigint$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<bigint$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: bigint$): bigint$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: bigint$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.bigint
 */
export const bigint$ = new bigint$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BigInt$$Type extends MessageType$<BigInt$> {
    constructor() {
        super("spec.BigInt", []);
    }
    create(value?: PartialMessage<BigInt$>): BigInt$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BigInt$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BigInt$): BigInt$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BigInt$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.BigInt
 */
export const BigInt$ = new BigInt$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClashParent$Type extends MessageType$<ClashParent> {
    constructor() {
        super("spec.ClashParent", []);
    }
    create(value?: PartialMessage<ClashParent>): ClashParent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClashParent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClashParent): ClashParent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClashParent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.ClashParent
 */
export const ClashParent = new ClashParent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClashParent_ClashChild$Type extends MessageType$<ClashParent_ClashChild> {
    constructor() {
        super("spec.ClashParent.ClashChild", []);
    }
    create(value?: PartialMessage<ClashParent_ClashChild>): ClashParent_ClashChild {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClashParent_ClashChild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClashParent_ClashChild): ClashParent_ClashChild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClashParent_ClashChild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.ClashParent.ClashChild
 */
export const ClashParent_ClashChild = new ClashParent_ClashChild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClashParent_ClashChild$1$Type extends MessageType$<ClashParent_ClashChild$1> {
    constructor() {
        super("spec.ClashParent_ClashChild", []);
    }
    create(value?: PartialMessage<ClashParent_ClashChild$1>): ClashParent_ClashChild$1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClashParent_ClashChild$1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClashParent_ClashChild$1): ClashParent_ClashChild$1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClashParent_ClashChild$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.ClashParent_ClashChild
 */
export const ClashParent_ClashChild$1 = new ClashParent_ClashChild$1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoClashFields$Type extends MessageType$<NoClashFields> {
    constructor() {
        super("spec.NoClashFields", [
            { no: 1, name: "const", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "switch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "case", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "function", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "interface", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "return", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NoClashFields>): NoClashFields {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.const = "";
        message.switch = "";
        message.case = "";
        message.function = "";
        message.interface = "";
        message.return = "";
        if (value !== undefined)
            reflectionMergePartial<NoClashFields>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoClashFields): NoClashFields {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string const */ 1:
                    message.const = reader.string();
                    break;
                case /* string switch */ 2:
                    message.switch = reader.string();
                    break;
                case /* string case */ 3:
                    message.case = reader.string();
                    break;
                case /* string function */ 4:
                    message.function = reader.string();
                    break;
                case /* string interface */ 5:
                    message.interface = reader.string();
                    break;
                case /* string return */ 6:
                    message.return = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoClashFields, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string const = 1; */
        if (message.const !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.const);
        /* string switch = 2; */
        if (message.switch !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.switch);
        /* string case = 3; */
        if (message.case !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.case);
        /* string function = 4; */
        if (message.function !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.function);
        /* string interface = 5; */
        if (message.interface !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.interface);
        /* string return = 6; */
        if (message.return !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.return);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.NoClashFields
 */
export const NoClashFields = new NoClashFields$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoClashOneof$Type extends MessageType$<NoClashOneof> {
    constructor() {
        super("spec.NoClashOneof", [
            { no: 1, name: "const", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "switch", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "case", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "function", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "interface", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "return", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NoClashOneof>): NoClashOneof {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<NoClashOneof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoClashOneof): NoClashOneof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string const */ 1:
                    message.kind = {
                        oneofKind: "const",
                        const: reader.string()
                    };
                    break;
                case /* string switch */ 2:
                    message.kind = {
                        oneofKind: "switch",
                        switch: reader.string()
                    };
                    break;
                case /* string case */ 3:
                    message.kind = {
                        oneofKind: "case",
                        case: reader.string()
                    };
                    break;
                case /* string function */ 4:
                    message.kind = {
                        oneofKind: "function",
                        function: reader.string()
                    };
                    break;
                case /* string interface */ 5:
                    message.kind = {
                        oneofKind: "interface",
                        interface: reader.string()
                    };
                    break;
                case /* string return */ 6:
                    message.kind = {
                        oneofKind: "return",
                        return: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoClashOneof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string const = 1; */
        if (message.kind.oneofKind === "const")
            writer.tag(1, WireType.LengthDelimited).string(message.kind.const);
        /* string switch = 2; */
        if (message.kind.oneofKind === "switch")
            writer.tag(2, WireType.LengthDelimited).string(message.kind.switch);
        /* string case = 3; */
        if (message.kind.oneofKind === "case")
            writer.tag(3, WireType.LengthDelimited).string(message.kind.case);
        /* string function = 4; */
        if (message.kind.oneofKind === "function")
            writer.tag(4, WireType.LengthDelimited).string(message.kind.function);
        /* string interface = 5; */
        if (message.kind.oneofKind === "interface")
            writer.tag(5, WireType.LengthDelimited).string(message.kind.interface);
        /* string return = 6; */
        if (message.kind.oneofKind === "return")
            writer.tag(6, WireType.LengthDelimited).string(message.kind.return);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.NoClashOneof
 */
export const NoClashOneof = new NoClashOneof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoClashEnumWrap$Type extends MessageType$<NoClashEnumWrap> {
    constructor() {
        super("spec.NoClashEnumWrap", []);
    }
    create(value?: PartialMessage<NoClashEnumWrap>): NoClashEnumWrap {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NoClashEnumWrap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoClashEnumWrap): NoClashEnumWrap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoClashEnumWrap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spec.NoClashEnumWrap
 */
export const NoClashEnumWrap = new NoClashEnumWrap$Type();
/**
 * @generated ServiceType for protobuf service spec.NameClashService
 */
export const NameClashService = new ServiceType("spec.NameClashService", [
    { name: "__proto__", options: {}, I: Error, O: Error },
    { name: "toString", localName: "toString$", options: {}, I: Error, O: Error },
    { name: "name", localName: "name$", options: {}, I: Error, O: Error },
    { name: "constructor", localName: "constructor$", options: {}, I: Error, O: Error },
    { name: "methods", localName: "methods$", options: {}, I: Error, O: Error },
    { name: "typeName", localName: "typeName$", options: {}, I: Error, O: Error },
    { name: "options", localName: "options$", options: {}, I: Error, O: Error },
    { name: "_transport", options: {}, I: Error, O: Error }
]);
