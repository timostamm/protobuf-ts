// @generated by protobuf-ts 2.10.0 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/map_lite_unittest.proto" (package "protobuf_unittest", syntax proto2)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TestAllTypesLite } from "./unittest_lite";
import { ForeignMessageLite } from "./unittest_lite";
/**
 * @generated from protobuf message protobuf_unittest.TestMapLite
 */
export interface TestMapLite {
    /**
     * @generated from protobuf field: map<int32, int32> map_int32_int32 = 1
     */
    mapInt32Int32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int64> map_int64_int64 = 2
     */
    mapInt64Int64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> map_uint32_uint32 = 3
     */
    mapUint32Uint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, uint64> map_uint64_uint64 = 4
     */
    mapUint64Uint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sint32, sint32> map_sint32_sint32 = 5
     */
    mapSint32Sint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sint64, sint64> map_sint64_sint64 = 6
     */
    mapSint64Sint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<fixed32, fixed32> map_fixed32_fixed32 = 7
     */
    mapFixed32Fixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<fixed64, fixed64> map_fixed64_fixed64 = 8
     */
    mapFixed64Fixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9
     */
    mapSfixed32Sfixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10
     */
    mapSfixed64Sfixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, float> map_int32_float = 11
     */
    mapInt32Float: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int32, double> map_int32_double = 12
     */
    mapInt32Double: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<bool, bool> map_bool_bool = 13
     */
    mapBoolBool: {
        [key: string]: boolean;
    };
    /**
     * @generated from protobuf field: map<string, string> map_string_string = 14
     */
    mapStringString: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, bytes> map_int32_bytes = 15
     */
    mapInt32Bytes: {
        [key: number]: Uint8Array;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.MapEnumLite> map_int32_enum = 16
     */
    mapInt32Enum: {
        [key: number]: MapEnumLite;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.ForeignMessageLite> map_int32_foreign_message = 17
     */
    mapInt32ForeignMessage: {
        [key: number]: ForeignMessageLite;
    };
    /**
     * @generated from protobuf field: map<int32, int32> teboring = 18
     */
    teboring: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestArenaMapLite
 */
export interface TestArenaMapLite {
    /**
     * @generated from protobuf field: map<int32, int32> map_int32_int32 = 1
     */
    mapInt32Int32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int64, int64> map_int64_int64 = 2
     */
    mapInt64Int64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> map_uint32_uint32 = 3
     */
    mapUint32Uint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint64, uint64> map_uint64_uint64 = 4
     */
    mapUint64Uint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sint32, sint32> map_sint32_sint32 = 5
     */
    mapSint32Sint32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sint64, sint64> map_sint64_sint64 = 6
     */
    mapSint64Sint64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<fixed32, fixed32> map_fixed32_fixed32 = 7
     */
    mapFixed32Fixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<fixed64, fixed64> map_fixed64_fixed64 = 8
     */
    mapFixed64Fixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9
     */
    mapSfixed32Sfixed32: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10
     */
    mapSfixed64Sfixed64: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, float> map_int32_float = 11
     */
    mapInt32Float: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<int32, double> map_int32_double = 12
     */
    mapInt32Double: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<bool, bool> map_bool_bool = 13
     */
    mapBoolBool: {
        [key: string]: boolean;
    };
    /**
     * @generated from protobuf field: map<string, string> map_string_string = 14
     */
    mapStringString: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<int32, bytes> map_int32_bytes = 15
     */
    mapInt32Bytes: {
        [key: number]: Uint8Array;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.MapEnumLite> map_int32_enum = 16
     */
    mapInt32Enum: {
        [key: number]: MapEnumLite;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.ForeignMessageArenaLite> map_int32_foreign_message = 17
     */
    mapInt32ForeignMessage: {
        [key: number]: ForeignMessageArenaLite;
    };
}
/**
 * Test embedded message with required fields
 *
 * @generated from protobuf message protobuf_unittest.TestRequiredMessageMapLite
 */
export interface TestRequiredMessageMapLite {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestRequiredLite> map_field = 1
     */
    mapField: {
        [key: number]: TestRequiredLite;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestEnumMapLite
 */
export interface TestEnumMapLite {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumLite> known_map_field = 101
     */
    knownMapField: {
        [key: number]: Proto2MapEnumLite;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumLite> unknown_map_field = 102
     */
    unknownMapField: {
        [key: number]: Proto2MapEnumLite;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestEnumMapPlusExtraLite
 */
export interface TestEnumMapPlusExtraLite {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> known_map_field = 101
     */
    knownMapField: {
        [key: number]: Proto2MapEnumPlusExtraLite;
    };
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> unknown_map_field = 102
     */
    unknownMapField: {
        [key: number]: Proto2MapEnumPlusExtraLite;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestMessageMapLite
 */
export interface TestMessageMapLite {
    /**
     * @generated from protobuf field: map<int32, protobuf_unittest.TestAllTypesLite> map_int32_message = 1
     */
    mapInt32Message: {
        [key: number]: TestAllTypesLite;
    };
}
/**
 * @generated from protobuf message protobuf_unittest.TestRequiredLite
 */
export interface TestRequiredLite {
    /**
     * @generated from protobuf field: required int32 a = 1
     */
    a: number;
    /**
     * @generated from protobuf field: required int32 b = 2
     */
    b: number;
    /**
     * @generated from protobuf field: required int32 c = 3
     */
    c: number;
}
/**
 * @generated from protobuf message protobuf_unittest.ForeignMessageArenaLite
 */
export interface ForeignMessageArenaLite {
    /**
     * @generated from protobuf field: optional int32 c = 1
     */
    c?: number;
}
/**
 * @generated from protobuf enum protobuf_unittest.Proto2MapEnumLite
 */
export enum Proto2MapEnumLite {
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_FOO_LITE = 0;
     */
    PROTO2_MAP_ENUM_FOO_LITE = 0,
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_BAR_LITE = 1;
     */
    PROTO2_MAP_ENUM_BAR_LITE = 1,
    /**
     * @generated from protobuf enum value: PROTO2_MAP_ENUM_BAZ_LITE = 2;
     */
    PROTO2_MAP_ENUM_BAZ_LITE = 2
}
/**
 * @generated from protobuf enum protobuf_unittest.Proto2MapEnumPlusExtraLite
 */
export enum Proto2MapEnumPlusExtraLite {
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_FOO_LITE = 0;
     */
    E_PROTO2_MAP_ENUM_FOO_LITE = 0,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_BAR_LITE = 1;
     */
    E_PROTO2_MAP_ENUM_BAR_LITE = 1,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_BAZ_LITE = 2;
     */
    E_PROTO2_MAP_ENUM_BAZ_LITE = 2,
    /**
     * @generated from protobuf enum value: E_PROTO2_MAP_ENUM_EXTRA_LITE = 3;
     */
    E_PROTO2_MAP_ENUM_EXTRA_LITE = 3
}
/**
 * @generated from protobuf enum protobuf_unittest.MapEnumLite
 */
export enum MapEnumLite {
    /**
     * @generated from protobuf enum value: MAP_ENUM_FOO_LITE = 0;
     */
    MAP_ENUM_FOO_LITE = 0,
    /**
     * @generated from protobuf enum value: MAP_ENUM_BAR_LITE = 1;
     */
    MAP_ENUM_BAR_LITE = 1,
    /**
     * @generated from protobuf enum value: MAP_ENUM_BAZ_LITE = 2;
     */
    MAP_ENUM_BAZ_LITE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TestMapLite$Type extends MessageType<TestMapLite> {
    constructor() {
        super("protobuf_unittest.TestMapLite", [
            { no: 1, name: "map_int32_int32", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "map_int64_int64", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 3, name: "map_uint32_uint32", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 4, name: "map_uint64_uint64", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/ } },
            { no: 5, name: "map_sint32_sint32", kind: "map", K: 17 /*ScalarType.SINT32*/, V: { kind: "scalar", T: 17 /*ScalarType.SINT32*/ } },
            { no: 6, name: "map_sint64_sint64", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "scalar", T: 18 /*ScalarType.SINT64*/ } },
            { no: 7, name: "map_fixed32_fixed32", kind: "map", K: 7 /*ScalarType.FIXED32*/, V: { kind: "scalar", T: 7 /*ScalarType.FIXED32*/ } },
            { no: 8, name: "map_fixed64_fixed64", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "scalar", T: 6 /*ScalarType.FIXED64*/ } },
            { no: 9, name: "map_sfixed32_sfixed32", kind: "map", K: 15 /*ScalarType.SFIXED32*/, V: { kind: "scalar", T: 15 /*ScalarType.SFIXED32*/ } },
            { no: 10, name: "map_sfixed64_sfixed64", kind: "map", K: 16 /*ScalarType.SFIXED64*/, V: { kind: "scalar", T: 16 /*ScalarType.SFIXED64*/ } },
            { no: 11, name: "map_int32_float", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 12, name: "map_int32_double", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 13, name: "map_bool_bool", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 14, name: "map_string_string", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "map_int32_bytes", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 16, name: "map_int32_enum", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.MapEnumLite", MapEnumLite] } },
            { no: 17, name: "map_int32_foreign_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ForeignMessageLite } },
            { no: 18, name: "teboring", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestMapLite>): TestMapLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Int32 = {};
        message.mapInt64Int64 = {};
        message.mapUint32Uint32 = {};
        message.mapUint64Uint64 = {};
        message.mapSint32Sint32 = {};
        message.mapSint64Sint64 = {};
        message.mapFixed32Fixed32 = {};
        message.mapFixed64Fixed64 = {};
        message.mapSfixed32Sfixed32 = {};
        message.mapSfixed64Sfixed64 = {};
        message.mapInt32Float = {};
        message.mapInt32Double = {};
        message.mapBoolBool = {};
        message.mapStringString = {};
        message.mapInt32Bytes = {};
        message.mapInt32Enum = {};
        message.mapInt32ForeignMessage = {};
        message.teboring = {};
        if (value !== undefined)
            reflectionMergePartial<TestMapLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMapLite): TestMapLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map_int32_int32 */ 1:
                    this.binaryReadMap1(message.mapInt32Int32, reader, options);
                    break;
                case /* map<int64, int64> map_int64_int64 */ 2:
                    this.binaryReadMap2(message.mapInt64Int64, reader, options);
                    break;
                case /* map<uint32, uint32> map_uint32_uint32 */ 3:
                    this.binaryReadMap3(message.mapUint32Uint32, reader, options);
                    break;
                case /* map<uint64, uint64> map_uint64_uint64 */ 4:
                    this.binaryReadMap4(message.mapUint64Uint64, reader, options);
                    break;
                case /* map<sint32, sint32> map_sint32_sint32 */ 5:
                    this.binaryReadMap5(message.mapSint32Sint32, reader, options);
                    break;
                case /* map<sint64, sint64> map_sint64_sint64 */ 6:
                    this.binaryReadMap6(message.mapSint64Sint64, reader, options);
                    break;
                case /* map<fixed32, fixed32> map_fixed32_fixed32 */ 7:
                    this.binaryReadMap7(message.mapFixed32Fixed32, reader, options);
                    break;
                case /* map<fixed64, fixed64> map_fixed64_fixed64 */ 8:
                    this.binaryReadMap8(message.mapFixed64Fixed64, reader, options);
                    break;
                case /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 */ 9:
                    this.binaryReadMap9(message.mapSfixed32Sfixed32, reader, options);
                    break;
                case /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 */ 10:
                    this.binaryReadMap10(message.mapSfixed64Sfixed64, reader, options);
                    break;
                case /* map<int32, float> map_int32_float */ 11:
                    this.binaryReadMap11(message.mapInt32Float, reader, options);
                    break;
                case /* map<int32, double> map_int32_double */ 12:
                    this.binaryReadMap12(message.mapInt32Double, reader, options);
                    break;
                case /* map<bool, bool> map_bool_bool */ 13:
                    this.binaryReadMap13(message.mapBoolBool, reader, options);
                    break;
                case /* map<string, string> map_string_string */ 14:
                    this.binaryReadMap14(message.mapStringString, reader, options);
                    break;
                case /* map<int32, bytes> map_int32_bytes */ 15:
                    this.binaryReadMap15(message.mapInt32Bytes, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.MapEnumLite> map_int32_enum */ 16:
                    this.binaryReadMap16(message.mapInt32Enum, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.ForeignMessageLite> map_int32_foreign_message */ 17:
                    this.binaryReadMap17(message.mapInt32ForeignMessage, reader, options);
                    break;
                case /* map<int32, int32> teboring */ 18:
                    this.binaryReadMap18(message.teboring, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMapLite["mapInt32Int32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32Int32"] | undefined, val: TestMapLite["mapInt32Int32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_int32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: TestMapLite["mapInt64Int64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt64Int64"] | undefined, val: TestMapLite["mapInt64Int64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int64_int64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap3(map: TestMapLite["mapUint32Uint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapUint32Uint32"] | undefined, val: TestMapLite["mapUint32Uint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_uint32_uint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap4(map: TestMapLite["mapUint64Uint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapUint64Uint64"] | undefined, val: TestMapLite["mapUint64Uint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.uint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_uint64_uint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap5(map: TestMapLite["mapSint32Sint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapSint32Sint32"] | undefined, val: TestMapLite["mapSint32Sint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint32();
                    break;
                case 2:
                    val = reader.sint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_sint32_sint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: TestMapLite["mapSint64Sint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapSint64Sint64"] | undefined, val: TestMapLite["mapSint64Sint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = reader.sint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_sint64_sint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap7(map: TestMapLite["mapFixed32Fixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapFixed32Fixed32"] | undefined, val: TestMapLite["mapFixed32Fixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed32();
                    break;
                case 2:
                    val = reader.fixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_fixed32_fixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap8(map: TestMapLite["mapFixed64Fixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapFixed64Fixed64"] | undefined, val: TestMapLite["mapFixed64Fixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = reader.fixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_fixed64_fixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap9(map: TestMapLite["mapSfixed32Sfixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapSfixed32Sfixed32"] | undefined, val: TestMapLite["mapSfixed32Sfixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed32();
                    break;
                case 2:
                    val = reader.sfixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_sfixed32_sfixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap10(map: TestMapLite["mapSfixed64Sfixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapSfixed64Sfixed64"] | undefined, val: TestMapLite["mapSfixed64Sfixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed64().toString();
                    break;
                case 2:
                    val = reader.sfixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_sfixed64_sfixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap11(map: TestMapLite["mapInt32Float"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32Float"] | undefined, val: TestMapLite["mapInt32Float"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_float");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap12(map: TestMapLite["mapInt32Double"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32Double"] | undefined, val: TestMapLite["mapInt32Double"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_double");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap13(map: TestMapLite["mapBoolBool"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapBoolBool"] | undefined, val: TestMapLite["mapBoolBool"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_bool_bool");
            }
        }
        map[key ?? "false"] = val ?? false;
    }
    private binaryReadMap14(map: TestMapLite["mapStringString"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapStringString"] | undefined, val: TestMapLite["mapStringString"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_string_string");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap15(map: TestMapLite["mapInt32Bytes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32Bytes"] | undefined, val: TestMapLite["mapInt32Bytes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_bytes");
            }
        }
        map[key ?? 0] = val ?? new Uint8Array(0);
    }
    private binaryReadMap16(map: TestMapLite["mapInt32Enum"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32Enum"] | undefined, val: TestMapLite["mapInt32Enum"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_enum");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap17(map: TestMapLite["mapInt32ForeignMessage"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["mapInt32ForeignMessage"] | undefined, val: TestMapLite["mapInt32ForeignMessage"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ForeignMessageLite.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.map_int32_foreign_message");
            }
        }
        map[key ?? 0] = val ?? ForeignMessageLite.create();
    }
    private binaryReadMap18(map: TestMapLite["teboring"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMapLite["teboring"] | undefined, val: TestMapLite["teboring"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMapLite.teboring");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestMapLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map_int32_int32 = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Int32))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Int32[k as any]).join();
        /* map<int64, int64> map_int64_int64 = 2; */
        for (let k of globalThis.Object.keys(message.mapInt64Int64))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int64(message.mapInt64Int64[k]).join();
        /* map<uint32, uint32> map_uint32_uint32 = 3; */
        for (let k of globalThis.Object.keys(message.mapUint32Uint32))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.mapUint32Uint32[k as any]).join();
        /* map<uint64, uint64> map_uint64_uint64 = 4; */
        for (let k of globalThis.Object.keys(message.mapUint64Uint64))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).uint64(message.mapUint64Uint64[k]).join();
        /* map<sint32, sint32> map_sint32_sint32 = 5; */
        for (let k of globalThis.Object.keys(message.mapSint32Sint32))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint32(parseInt(k)).tag(2, WireType.Varint).sint32(message.mapSint32Sint32[k as any]).join();
        /* map<sint64, sint64> map_sint64_sint64 = 6; */
        for (let k of globalThis.Object.keys(message.mapSint64Sint64))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.Varint).sint64(message.mapSint64Sint64[k]).join();
        /* map<fixed32, fixed32> map_fixed32_fixed32 = 7; */
        for (let k of globalThis.Object.keys(message.mapFixed32Fixed32))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).fixed32(parseInt(k)).tag(2, WireType.Bit32).fixed32(message.mapFixed32Fixed32[k as any]).join();
        /* map<fixed64, fixed64> map_fixed64_fixed64 = 8; */
        for (let k of globalThis.Object.keys(message.mapFixed64Fixed64))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k).tag(2, WireType.Bit64).fixed64(message.mapFixed64Fixed64[k]).join();
        /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9; */
        for (let k of globalThis.Object.keys(message.mapSfixed32Sfixed32))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).sfixed32(parseInt(k)).tag(2, WireType.Bit32).sfixed32(message.mapSfixed32Sfixed32[k as any]).join();
        /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10; */
        for (let k of globalThis.Object.keys(message.mapSfixed64Sfixed64))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).sfixed64(k).tag(2, WireType.Bit64).sfixed64(message.mapSfixed64Sfixed64[k]).join();
        /* map<int32, float> map_int32_float = 11; */
        for (let k of globalThis.Object.keys(message.mapInt32Float))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit32).float(message.mapInt32Float[k as any]).join();
        /* map<int32, double> map_int32_double = 12; */
        for (let k of globalThis.Object.keys(message.mapInt32Double))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.mapInt32Double[k as any]).join();
        /* map<bool, bool> map_bool_bool = 13; */
        for (let k of globalThis.Object.keys(message.mapBoolBool))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).bool(message.mapBoolBool[k]).join();
        /* map<string, string> map_string_string = 14; */
        for (let k of globalThis.Object.keys(message.mapStringString))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapStringString[k]).join();
        /* map<int32, bytes> map_int32_bytes = 15; */
        for (let k of globalThis.Object.keys(message.mapInt32Bytes))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).bytes(message.mapInt32Bytes[k as any]).join();
        /* map<int32, protobuf_unittest.MapEnumLite> map_int32_enum = 16; */
        for (let k of globalThis.Object.keys(message.mapInt32Enum))
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Enum[k as any]).join();
        /* map<int32, protobuf_unittest.ForeignMessageLite> map_int32_foreign_message = 17; */
        for (let k of globalThis.Object.keys(message.mapInt32ForeignMessage)) {
            writer.tag(17, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForeignMessageLite.internalBinaryWrite(message.mapInt32ForeignMessage[k as any], writer, options);
            writer.join().join();
        }
        /* map<int32, int32> teboring = 18; */
        for (let k of globalThis.Object.keys(message.teboring))
            writer.tag(18, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.teboring[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMapLite
 */
export const TestMapLite = new TestMapLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestArenaMapLite$Type extends MessageType<TestArenaMapLite> {
    constructor() {
        super("protobuf_unittest.TestArenaMapLite", [
            { no: 1, name: "map_int32_int32", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 2, name: "map_int64_int64", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 3, name: "map_uint32_uint32", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 4, name: "map_uint64_uint64", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/ } },
            { no: 5, name: "map_sint32_sint32", kind: "map", K: 17 /*ScalarType.SINT32*/, V: { kind: "scalar", T: 17 /*ScalarType.SINT32*/ } },
            { no: 6, name: "map_sint64_sint64", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "scalar", T: 18 /*ScalarType.SINT64*/ } },
            { no: 7, name: "map_fixed32_fixed32", kind: "map", K: 7 /*ScalarType.FIXED32*/, V: { kind: "scalar", T: 7 /*ScalarType.FIXED32*/ } },
            { no: 8, name: "map_fixed64_fixed64", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "scalar", T: 6 /*ScalarType.FIXED64*/ } },
            { no: 9, name: "map_sfixed32_sfixed32", kind: "map", K: 15 /*ScalarType.SFIXED32*/, V: { kind: "scalar", T: 15 /*ScalarType.SFIXED32*/ } },
            { no: 10, name: "map_sfixed64_sfixed64", kind: "map", K: 16 /*ScalarType.SFIXED64*/, V: { kind: "scalar", T: 16 /*ScalarType.SFIXED64*/ } },
            { no: 11, name: "map_int32_float", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 12, name: "map_int32_double", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 13, name: "map_bool_bool", kind: "map", K: 8 /*ScalarType.BOOL*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 14, name: "map_string_string", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "map_int32_bytes", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 16, name: "map_int32_enum", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.MapEnumLite", MapEnumLite] } },
            { no: 17, name: "map_int32_foreign_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ForeignMessageArenaLite } }
        ]);
    }
    create(value?: PartialMessage<TestArenaMapLite>): TestArenaMapLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Int32 = {};
        message.mapInt64Int64 = {};
        message.mapUint32Uint32 = {};
        message.mapUint64Uint64 = {};
        message.mapSint32Sint32 = {};
        message.mapSint64Sint64 = {};
        message.mapFixed32Fixed32 = {};
        message.mapFixed64Fixed64 = {};
        message.mapSfixed32Sfixed32 = {};
        message.mapSfixed64Sfixed64 = {};
        message.mapInt32Float = {};
        message.mapInt32Double = {};
        message.mapBoolBool = {};
        message.mapStringString = {};
        message.mapInt32Bytes = {};
        message.mapInt32Enum = {};
        message.mapInt32ForeignMessage = {};
        if (value !== undefined)
            reflectionMergePartial<TestArenaMapLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestArenaMapLite): TestArenaMapLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, int32> map_int32_int32 */ 1:
                    this.binaryReadMap1(message.mapInt32Int32, reader, options);
                    break;
                case /* map<int64, int64> map_int64_int64 */ 2:
                    this.binaryReadMap2(message.mapInt64Int64, reader, options);
                    break;
                case /* map<uint32, uint32> map_uint32_uint32 */ 3:
                    this.binaryReadMap3(message.mapUint32Uint32, reader, options);
                    break;
                case /* map<uint64, uint64> map_uint64_uint64 */ 4:
                    this.binaryReadMap4(message.mapUint64Uint64, reader, options);
                    break;
                case /* map<sint32, sint32> map_sint32_sint32 */ 5:
                    this.binaryReadMap5(message.mapSint32Sint32, reader, options);
                    break;
                case /* map<sint64, sint64> map_sint64_sint64 */ 6:
                    this.binaryReadMap6(message.mapSint64Sint64, reader, options);
                    break;
                case /* map<fixed32, fixed32> map_fixed32_fixed32 */ 7:
                    this.binaryReadMap7(message.mapFixed32Fixed32, reader, options);
                    break;
                case /* map<fixed64, fixed64> map_fixed64_fixed64 */ 8:
                    this.binaryReadMap8(message.mapFixed64Fixed64, reader, options);
                    break;
                case /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 */ 9:
                    this.binaryReadMap9(message.mapSfixed32Sfixed32, reader, options);
                    break;
                case /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 */ 10:
                    this.binaryReadMap10(message.mapSfixed64Sfixed64, reader, options);
                    break;
                case /* map<int32, float> map_int32_float */ 11:
                    this.binaryReadMap11(message.mapInt32Float, reader, options);
                    break;
                case /* map<int32, double> map_int32_double */ 12:
                    this.binaryReadMap12(message.mapInt32Double, reader, options);
                    break;
                case /* map<bool, bool> map_bool_bool */ 13:
                    this.binaryReadMap13(message.mapBoolBool, reader, options);
                    break;
                case /* map<string, string> map_string_string */ 14:
                    this.binaryReadMap14(message.mapStringString, reader, options);
                    break;
                case /* map<int32, bytes> map_int32_bytes */ 15:
                    this.binaryReadMap15(message.mapInt32Bytes, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.MapEnumLite> map_int32_enum */ 16:
                    this.binaryReadMap16(message.mapInt32Enum, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.ForeignMessageArenaLite> map_int32_foreign_message */ 17:
                    this.binaryReadMap17(message.mapInt32ForeignMessage, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestArenaMapLite["mapInt32Int32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32Int32"] | undefined, val: TestArenaMapLite["mapInt32Int32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_int32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: TestArenaMapLite["mapInt64Int64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt64Int64"] | undefined, val: TestArenaMapLite["mapInt64Int64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int64_int64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap3(map: TestArenaMapLite["mapUint32Uint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapUint32Uint32"] | undefined, val: TestArenaMapLite["mapUint32Uint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_uint32_uint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap4(map: TestArenaMapLite["mapUint64Uint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapUint64Uint64"] | undefined, val: TestArenaMapLite["mapUint64Uint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.uint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_uint64_uint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap5(map: TestArenaMapLite["mapSint32Sint32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapSint32Sint32"] | undefined, val: TestArenaMapLite["mapSint32Sint32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint32();
                    break;
                case 2:
                    val = reader.sint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_sint32_sint32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: TestArenaMapLite["mapSint64Sint64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapSint64Sint64"] | undefined, val: TestArenaMapLite["mapSint64Sint64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = reader.sint64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_sint64_sint64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap7(map: TestArenaMapLite["mapFixed32Fixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapFixed32Fixed32"] | undefined, val: TestArenaMapLite["mapFixed32Fixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed32();
                    break;
                case 2:
                    val = reader.fixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_fixed32_fixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap8(map: TestArenaMapLite["mapFixed64Fixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapFixed64Fixed64"] | undefined, val: TestArenaMapLite["mapFixed64Fixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = reader.fixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_fixed64_fixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap9(map: TestArenaMapLite["mapSfixed32Sfixed32"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapSfixed32Sfixed32"] | undefined, val: TestArenaMapLite["mapSfixed32Sfixed32"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed32();
                    break;
                case 2:
                    val = reader.sfixed32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_sfixed32_sfixed32");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap10(map: TestArenaMapLite["mapSfixed64Sfixed64"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapSfixed64Sfixed64"] | undefined, val: TestArenaMapLite["mapSfixed64Sfixed64"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sfixed64().toString();
                    break;
                case 2:
                    val = reader.sfixed64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_sfixed64_sfixed64");
            }
        }
        map[key ?? "0"] = val ?? "0";
    }
    private binaryReadMap11(map: TestArenaMapLite["mapInt32Float"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32Float"] | undefined, val: TestArenaMapLite["mapInt32Float"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_float");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap12(map: TestArenaMapLite["mapInt32Double"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32Double"] | undefined, val: TestArenaMapLite["mapInt32Double"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_double");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap13(map: TestArenaMapLite["mapBoolBool"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapBoolBool"] | undefined, val: TestArenaMapLite["mapBoolBool"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.bool().toString();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_bool_bool");
            }
        }
        map[key ?? "false"] = val ?? false;
    }
    private binaryReadMap14(map: TestArenaMapLite["mapStringString"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapStringString"] | undefined, val: TestArenaMapLite["mapStringString"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_string_string");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap15(map: TestArenaMapLite["mapInt32Bytes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32Bytes"] | undefined, val: TestArenaMapLite["mapInt32Bytes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_bytes");
            }
        }
        map[key ?? 0] = val ?? new Uint8Array(0);
    }
    private binaryReadMap16(map: TestArenaMapLite["mapInt32Enum"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32Enum"] | undefined, val: TestArenaMapLite["mapInt32Enum"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_enum");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap17(map: TestArenaMapLite["mapInt32ForeignMessage"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestArenaMapLite["mapInt32ForeignMessage"] | undefined, val: TestArenaMapLite["mapInt32ForeignMessage"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ForeignMessageArenaLite.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestArenaMapLite.map_int32_foreign_message");
            }
        }
        map[key ?? 0] = val ?? ForeignMessageArenaLite.create();
    }
    internalBinaryWrite(message: TestArenaMapLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, int32> map_int32_int32 = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Int32))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Int32[k as any]).join();
        /* map<int64, int64> map_int64_int64 = 2; */
        for (let k of globalThis.Object.keys(message.mapInt64Int64))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int64(message.mapInt64Int64[k]).join();
        /* map<uint32, uint32> map_uint32_uint32 = 3; */
        for (let k of globalThis.Object.keys(message.mapUint32Uint32))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.mapUint32Uint32[k as any]).join();
        /* map<uint64, uint64> map_uint64_uint64 = 4; */
        for (let k of globalThis.Object.keys(message.mapUint64Uint64))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).uint64(message.mapUint64Uint64[k]).join();
        /* map<sint32, sint32> map_sint32_sint32 = 5; */
        for (let k of globalThis.Object.keys(message.mapSint32Sint32))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint32(parseInt(k)).tag(2, WireType.Varint).sint32(message.mapSint32Sint32[k as any]).join();
        /* map<sint64, sint64> map_sint64_sint64 = 6; */
        for (let k of globalThis.Object.keys(message.mapSint64Sint64))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k).tag(2, WireType.Varint).sint64(message.mapSint64Sint64[k]).join();
        /* map<fixed32, fixed32> map_fixed32_fixed32 = 7; */
        for (let k of globalThis.Object.keys(message.mapFixed32Fixed32))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).fixed32(parseInt(k)).tag(2, WireType.Bit32).fixed32(message.mapFixed32Fixed32[k as any]).join();
        /* map<fixed64, fixed64> map_fixed64_fixed64 = 8; */
        for (let k of globalThis.Object.keys(message.mapFixed64Fixed64))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k).tag(2, WireType.Bit64).fixed64(message.mapFixed64Fixed64[k]).join();
        /* map<sfixed32, sfixed32> map_sfixed32_sfixed32 = 9; */
        for (let k of globalThis.Object.keys(message.mapSfixed32Sfixed32))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Bit32).sfixed32(parseInt(k)).tag(2, WireType.Bit32).sfixed32(message.mapSfixed32Sfixed32[k as any]).join();
        /* map<sfixed64, sfixed64> map_sfixed64_sfixed64 = 10; */
        for (let k of globalThis.Object.keys(message.mapSfixed64Sfixed64))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).sfixed64(k).tag(2, WireType.Bit64).sfixed64(message.mapSfixed64Sfixed64[k]).join();
        /* map<int32, float> map_int32_float = 11; */
        for (let k of globalThis.Object.keys(message.mapInt32Float))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit32).float(message.mapInt32Float[k as any]).join();
        /* map<int32, double> map_int32_double = 12; */
        for (let k of globalThis.Object.keys(message.mapInt32Double))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.mapInt32Double[k as any]).join();
        /* map<bool, bool> map_bool_bool = 13; */
        for (let k of globalThis.Object.keys(message.mapBoolBool))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).bool(k === "true").tag(2, WireType.Varint).bool(message.mapBoolBool[k]).join();
        /* map<string, string> map_string_string = 14; */
        for (let k of globalThis.Object.keys(message.mapStringString))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.mapStringString[k]).join();
        /* map<int32, bytes> map_int32_bytes = 15; */
        for (let k of globalThis.Object.keys(message.mapInt32Bytes))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).bytes(message.mapInt32Bytes[k as any]).join();
        /* map<int32, protobuf_unittest.MapEnumLite> map_int32_enum = 16; */
        for (let k of globalThis.Object.keys(message.mapInt32Enum))
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.mapInt32Enum[k as any]).join();
        /* map<int32, protobuf_unittest.ForeignMessageArenaLite> map_int32_foreign_message = 17; */
        for (let k of globalThis.Object.keys(message.mapInt32ForeignMessage)) {
            writer.tag(17, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForeignMessageArenaLite.internalBinaryWrite(message.mapInt32ForeignMessage[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestArenaMapLite
 */
export const TestArenaMapLite = new TestArenaMapLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredMessageMapLite$Type extends MessageType<TestRequiredMessageMapLite> {
    constructor() {
        super("protobuf_unittest.TestRequiredMessageMapLite", [
            { no: 1, name: "map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestRequiredLite } }
        ]);
    }
    create(value?: PartialMessage<TestRequiredMessageMapLite>): TestRequiredMessageMapLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestRequiredMessageMapLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredMessageMapLite): TestRequiredMessageMapLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.TestRequiredLite> map_field */ 1:
                    this.binaryReadMap1(message.mapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestRequiredMessageMapLite["mapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestRequiredMessageMapLite["mapField"] | undefined, val: TestRequiredMessageMapLite["mapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestRequiredLite.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestRequiredMessageMapLite.map_field");
            }
        }
        map[key ?? 0] = val ?? TestRequiredLite.create();
    }
    internalBinaryWrite(message: TestRequiredMessageMapLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.TestRequiredLite> map_field = 1; */
        for (let k of globalThis.Object.keys(message.mapField)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestRequiredLite.internalBinaryWrite(message.mapField[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredMessageMapLite
 */
export const TestRequiredMessageMapLite = new TestRequiredMessageMapLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEnumMapLite$Type extends MessageType<TestEnumMapLite> {
    constructor() {
        super("protobuf_unittest.TestEnumMapLite", [
            { no: 101, name: "known_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumLite", Proto2MapEnumLite] } },
            { no: 102, name: "unknown_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumLite", Proto2MapEnumLite] } }
        ]);
    }
    create(value?: PartialMessage<TestEnumMapLite>): TestEnumMapLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.knownMapField = {};
        message.unknownMapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestEnumMapLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEnumMapLite): TestEnumMapLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.Proto2MapEnumLite> known_map_field */ 101:
                    this.binaryReadMap101(message.knownMapField, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.Proto2MapEnumLite> unknown_map_field */ 102:
                    this.binaryReadMap102(message.unknownMapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap101(map: TestEnumMapLite["knownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapLite["knownMapField"] | undefined, val: TestEnumMapLite["knownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestEnumMapLite.known_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap102(map: TestEnumMapLite["unknownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapLite["unknownMapField"] | undefined, val: TestEnumMapLite["unknownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestEnumMapLite.unknown_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestEnumMapLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.Proto2MapEnumLite> known_map_field = 101; */
        for (let k of globalThis.Object.keys(message.knownMapField))
            writer.tag(101, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.knownMapField[k as any]).join();
        /* map<int32, protobuf_unittest.Proto2MapEnumLite> unknown_map_field = 102; */
        for (let k of globalThis.Object.keys(message.unknownMapField))
            writer.tag(102, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.unknownMapField[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEnumMapLite
 */
export const TestEnumMapLite = new TestEnumMapLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestEnumMapPlusExtraLite$Type extends MessageType<TestEnumMapPlusExtraLite> {
    constructor() {
        super("protobuf_unittest.TestEnumMapPlusExtraLite", [
            { no: 101, name: "known_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumPlusExtraLite", Proto2MapEnumPlusExtraLite] } },
            { no: 102, name: "unknown_map_field", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "enum", T: () => ["protobuf_unittest.Proto2MapEnumPlusExtraLite", Proto2MapEnumPlusExtraLite] } }
        ]);
    }
    create(value?: PartialMessage<TestEnumMapPlusExtraLite>): TestEnumMapPlusExtraLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.knownMapField = {};
        message.unknownMapField = {};
        if (value !== undefined)
            reflectionMergePartial<TestEnumMapPlusExtraLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestEnumMapPlusExtraLite): TestEnumMapPlusExtraLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> known_map_field */ 101:
                    this.binaryReadMap101(message.knownMapField, reader, options);
                    break;
                case /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> unknown_map_field */ 102:
                    this.binaryReadMap102(message.unknownMapField, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap101(map: TestEnumMapPlusExtraLite["knownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapPlusExtraLite["knownMapField"] | undefined, val: TestEnumMapPlusExtraLite["knownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestEnumMapPlusExtraLite.known_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap102(map: TestEnumMapPlusExtraLite["unknownMapField"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestEnumMapPlusExtraLite["unknownMapField"] | undefined, val: TestEnumMapPlusExtraLite["unknownMapField"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestEnumMapPlusExtraLite.unknown_map_field");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TestEnumMapPlusExtraLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> known_map_field = 101; */
        for (let k of globalThis.Object.keys(message.knownMapField))
            writer.tag(101, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.knownMapField[k as any]).join();
        /* map<int32, protobuf_unittest.Proto2MapEnumPlusExtraLite> unknown_map_field = 102; */
        for (let k of globalThis.Object.keys(message.unknownMapField))
            writer.tag(102, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).int32(message.unknownMapField[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestEnumMapPlusExtraLite
 */
export const TestEnumMapPlusExtraLite = new TestEnumMapPlusExtraLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestMessageMapLite$Type extends MessageType<TestMessageMapLite> {
    constructor() {
        super("protobuf_unittest.TestMessageMapLite", [
            { no: 1, name: "map_int32_message", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TestAllTypesLite } }
        ]);
    }
    create(value?: PartialMessage<TestMessageMapLite>): TestMessageMapLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapInt32Message = {};
        if (value !== undefined)
            reflectionMergePartial<TestMessageMapLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestMessageMapLite): TestMessageMapLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protobuf_unittest.TestAllTypesLite> map_int32_message */ 1:
                    this.binaryReadMap1(message.mapInt32Message, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TestMessageMapLite["mapInt32Message"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestMessageMapLite["mapInt32Message"] | undefined, val: TestMessageMapLite["mapInt32Message"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TestAllTypesLite.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protobuf_unittest.TestMessageMapLite.map_int32_message");
            }
        }
        map[key ?? 0] = val ?? TestAllTypesLite.create();
    }
    internalBinaryWrite(message: TestMessageMapLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protobuf_unittest.TestAllTypesLite> map_int32_message = 1; */
        for (let k of globalThis.Object.keys(message.mapInt32Message)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TestAllTypesLite.internalBinaryWrite(message.mapInt32Message[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestMessageMapLite
 */
export const TestMessageMapLite = new TestMessageMapLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequiredLite$Type extends MessageType<TestRequiredLite> {
    constructor() {
        super("protobuf_unittest.TestRequiredLite", [
            { no: 1, name: "a", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "b", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "c", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestRequiredLite>): TestRequiredLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.a = 0;
        message.b = 0;
        message.c = 0;
        if (value !== undefined)
            reflectionMergePartial<TestRequiredLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequiredLite): TestRequiredLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* required int32 a */ 1:
                    message.a = reader.int32();
                    break;
                case /* required int32 b */ 2:
                    message.b = reader.int32();
                    break;
                case /* required int32 c */ 3:
                    message.c = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequiredLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* required int32 a = 1; */
        if (message.a !== 0)
            writer.tag(1, WireType.Varint).int32(message.a);
        /* required int32 b = 2; */
        if (message.b !== 0)
            writer.tag(2, WireType.Varint).int32(message.b);
        /* required int32 c = 3; */
        if (message.c !== 0)
            writer.tag(3, WireType.Varint).int32(message.c);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.TestRequiredLite
 */
export const TestRequiredLite = new TestRequiredLite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForeignMessageArenaLite$Type extends MessageType<ForeignMessageArenaLite> {
    constructor() {
        super("protobuf_unittest.ForeignMessageArenaLite", [
            { no: 1, name: "c", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForeignMessageArenaLite>): ForeignMessageArenaLite {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ForeignMessageArenaLite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForeignMessageArenaLite): ForeignMessageArenaLite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 c */ 1:
                    message.c = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForeignMessageArenaLite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 c = 1; */
        if (message.c !== undefined)
            writer.tag(1, WireType.Varint).int32(message.c);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protobuf_unittest.ForeignMessageArenaLite
 */
export const ForeignMessageArenaLite = new ForeignMessageArenaLite$Type();
