// @generated by protobuf-ts 2.11.1 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/protobuf/api.proto" (package "google.protobuf", syntax proto3)
// tslint:disable
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Syntax } from "./type";
import { SourceContext } from "./source_context";
import { Option } from "./type";
/**
 * Api is a light-weight descriptor for an API Interface.
 *
 * Interfaces are also described as "protocol buffer services" in some contexts,
 * such as by the "service" keyword in a .proto file, but they are different
 * from API Services, which represent a concrete implementation of an interface
 * as opposed to simply a description of methods and bindings. They are also
 * sometimes simply referred to as "APIs" in other contexts, such as the name of
 * this message itself. See https://cloud.google.com/apis/design/glossary for
 * detailed terminology.
 *
 * @generated from protobuf message google.protobuf.Api
 */
export interface Api {
    /**
     * The fully qualified name of this interface, including package name
     * followed by the interface's simple name.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * The methods of this interface, in unspecified order.
     *
     * @generated from protobuf field: repeated google.protobuf.Method methods = 2
     */
    methods: Method[];
    /**
     * Any metadata attached to the interface.
     *
     * @generated from protobuf field: repeated google.protobuf.Option options = 3
     */
    options: Option[];
    /**
     * A version string for this interface. If specified, must have the form
     * `major-version.minor-version`, as in `1.10`. If the minor version is
     * omitted, it defaults to zero. If the entire version field is empty, the
     * major version is derived from the package name, as outlined below. If the
     * field is not empty, the version in the package name will be verified to be
     * consistent with what is provided here.
     *
     * The versioning schema uses [semantic
     * versioning](http://semver.org) where the major version number
     * indicates a breaking change and the minor version an additive,
     * non-breaking change. Both version numbers are signals to users
     * what to expect from different versions, and should be carefully
     * chosen based on the product plan.
     *
     * The major version is also reflected in the package name of the
     * interface, which must end in `v<major-version>`, as in
     * `google.feature.v1`. For major versions 0 and 1, the suffix can
     * be omitted. Zero major versions must only be used for
     * experimental, non-GA interfaces.
     *
     *
     * @generated from protobuf field: string version = 4
     */
    version: string;
    /**
     * Source context for the protocol buffer service represented by this
     * message.
     *
     * @generated from protobuf field: google.protobuf.SourceContext source_context = 5
     */
    sourceContext?: SourceContext;
    /**
     * Included interfaces. See [Mixin][].
     *
     * @generated from protobuf field: repeated google.protobuf.Mixin mixins = 6
     */
    mixins: Mixin[];
    /**
     * The source syntax of the service.
     *
     * @generated from protobuf field: google.protobuf.Syntax syntax = 7
     */
    syntax: Syntax;
}
/**
 * Method represents a method of an API interface.
 *
 * @generated from protobuf message google.protobuf.Method
 */
export interface Method {
    /**
     * The simple name of this method.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * A URL of the input message type.
     *
     * @generated from protobuf field: string request_type_url = 2
     */
    requestTypeUrl: string;
    /**
     * If true, the request is streamed.
     *
     * @generated from protobuf field: bool request_streaming = 3
     */
    requestStreaming: boolean;
    /**
     * The URL of the output message type.
     *
     * @generated from protobuf field: string response_type_url = 4
     */
    responseTypeUrl: string;
    /**
     * If true, the response is streamed.
     *
     * @generated from protobuf field: bool response_streaming = 5
     */
    responseStreaming: boolean;
    /**
     * Any metadata attached to the method.
     *
     * @generated from protobuf field: repeated google.protobuf.Option options = 6
     */
    options: Option[];
    /**
     * The source syntax of this method.
     *
     * @generated from protobuf field: google.protobuf.Syntax syntax = 7
     */
    syntax: Syntax;
}
/**
 * Declares an API Interface to be included in this interface. The including
 * interface must redeclare all the methods from the included interface, but
 * documentation and options are inherited as follows:
 *
 * - If after comment and whitespace stripping, the documentation
 *   string of the redeclared method is empty, it will be inherited
 *   from the original method.
 *
 * - Each annotation belonging to the service config (http,
 *   visibility) which is not set in the redeclared method will be
 *   inherited.
 *
 * - If an http annotation is inherited, the path pattern will be
 *   modified as follows. Any version prefix will be replaced by the
 *   version of the including interface plus the [root][] path if
 *   specified.
 *
 * Example of a simple mixin:
 *
 *     package google.acl.v1;
 *     service AccessControl {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = "/v1/{resource=**}:getAcl";
 *       }
 *     }
 *
 *     package google.storage.v2;
 *     service Storage {
 *       rpc GetAcl(GetAclRequest) returns (Acl);
 *
 *       // Get a data record.
 *       rpc GetData(GetDataRequest) returns (Data) {
 *         option (google.api.http).get = "/v2/{resource=**}";
 *       }
 *     }
 *
 * Example of a mixin configuration:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *
 * The mixin construct implies that all methods in `AccessControl` are
 * also declared with same name and request/response types in
 * `Storage`. A documentation generator or annotation processor will
 * see the effective `Storage.GetAcl` method after inheriting
 * documentation and annotations as follows:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = "/v2/{resource=**}:getAcl";
 *       }
 *       ...
 *     }
 *
 * Note how the version in the path pattern changed from `v1` to `v2`.
 *
 * If the `root` field in the mixin is specified, it should be a
 * relative path under which inherited HTTP paths are placed. Example:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *         root: acls
 *
 * This implies the following inherited HTTP annotation:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
 *       }
 *       ...
 *     }
 *
 * @generated from protobuf message google.protobuf.Mixin
 */
export interface Mixin {
    /**
     * The fully qualified name of the interface which is included.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * If non-empty specifies a path under which inherited HTTP paths
     * are rooted.
     *
     * @generated from protobuf field: string root = 2
     */
    root: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Api$Type extends MessageType<Api> {
    constructor() {
        super("google.protobuf.Api", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "methods", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Method },
            { no: 3, name: "options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Option },
            { no: 4, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "source_context", kind: "message", T: () => SourceContext },
            { no: 6, name: "mixins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Mixin },
            { no: 7, name: "syntax", kind: "enum", T: () => ["google.protobuf.Syntax", Syntax, "SYNTAX_"] }
        ]);
    }
    create(value?: PartialMessage<Api>): Api {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.methods = [];
        message.options = [];
        message.version = "";
        message.mixins = [];
        message.syntax = 0;
        if (value !== undefined)
            reflectionMergePartial<Api>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Api): Api {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated google.protobuf.Method methods */ 2:
                    message.methods.push(Method.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Option options */ 3:
                    message.options.push(Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string version */ 4:
                    message.version = reader.string();
                    break;
                case /* google.protobuf.SourceContext source_context */ 5:
                    message.sourceContext = SourceContext.internalBinaryRead(reader, reader.uint32(), options, message.sourceContext);
                    break;
                case /* repeated google.protobuf.Mixin mixins */ 6:
                    message.mixins.push(Mixin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Syntax syntax */ 7:
                    message.syntax = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Api, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated google.protobuf.Method methods = 2; */
        for (let i = 0; i < message.methods.length; i++)
            Method.internalBinaryWrite(message.methods[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Option options = 3; */
        for (let i = 0; i < message.options.length; i++)
            Option.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string version = 4; */
        if (message.version !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* google.protobuf.SourceContext source_context = 5; */
        if (message.sourceContext)
            SourceContext.internalBinaryWrite(message.sourceContext, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Mixin mixins = 6; */
        for (let i = 0; i < message.mixins.length; i++)
            Mixin.internalBinaryWrite(message.mixins[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Syntax syntax = 7; */
        if (message.syntax !== 0)
            writer.tag(7, WireType.Varint).int32(message.syntax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.protobuf.Api
 */
export const Api = new Api$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Method$Type extends MessageType<Method> {
    constructor() {
        super("google.protobuf.Method", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request_type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "request_streaming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "response_type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "response_streaming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Option },
            { no: 7, name: "syntax", kind: "enum", T: () => ["google.protobuf.Syntax", Syntax, "SYNTAX_"] }
        ]);
    }
    create(value?: PartialMessage<Method>): Method {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.requestTypeUrl = "";
        message.requestStreaming = false;
        message.responseTypeUrl = "";
        message.responseStreaming = false;
        message.options = [];
        message.syntax = 0;
        if (value !== undefined)
            reflectionMergePartial<Method>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Method): Method {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string request_type_url */ 2:
                    message.requestTypeUrl = reader.string();
                    break;
                case /* bool request_streaming */ 3:
                    message.requestStreaming = reader.bool();
                    break;
                case /* string response_type_url */ 4:
                    message.responseTypeUrl = reader.string();
                    break;
                case /* bool response_streaming */ 5:
                    message.responseStreaming = reader.bool();
                    break;
                case /* repeated google.protobuf.Option options */ 6:
                    message.options.push(Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Syntax syntax */ 7:
                    message.syntax = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Method, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string request_type_url = 2; */
        if (message.requestTypeUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.requestTypeUrl);
        /* bool request_streaming = 3; */
        if (message.requestStreaming !== false)
            writer.tag(3, WireType.Varint).bool(message.requestStreaming);
        /* string response_type_url = 4; */
        if (message.responseTypeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.responseTypeUrl);
        /* bool response_streaming = 5; */
        if (message.responseStreaming !== false)
            writer.tag(5, WireType.Varint).bool(message.responseStreaming);
        /* repeated google.protobuf.Option options = 6; */
        for (let i = 0; i < message.options.length; i++)
            Option.internalBinaryWrite(message.options[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Syntax syntax = 7; */
        if (message.syntax !== 0)
            writer.tag(7, WireType.Varint).int32(message.syntax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.protobuf.Method
 */
export const Method = new Method$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mixin$Type extends MessageType<Mixin> {
    constructor() {
        super("google.protobuf.Mixin", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "root", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Mixin>): Mixin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.root = "";
        if (value !== undefined)
            reflectionMergePartial<Mixin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mixin): Mixin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string root */ 2:
                    message.root = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Mixin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string root = 2; */
        if (message.root !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.root);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.protobuf.Mixin
 */
export const Mixin = new Mixin$Type();
