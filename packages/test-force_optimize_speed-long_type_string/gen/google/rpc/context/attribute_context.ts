// @generated by protobuf-ts 2.9.5 with parameter force_optimize_speed,long_type_string
// @generated from protobuf file "google/rpc/context/attribute_context.proto" (package "google.rpc.context", syntax proto3)
// tslint:disable
//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../protobuf/timestamp";
import { Struct } from "../../protobuf/struct";
/**
 * This message defines the standard attribute vocabulary for Google APIs.
 *
 * An attribute is a piece of metadata that describes an activity on a network
 * service. For example, the size of an HTTP request, or the status code of
 * an HTTP response.
 *
 * Each attribute has a type and a name, which is logically defined as
 * a proto message field in `AttributeContext`. The field type becomes the
 * attribute type, and the field path becomes the attribute name. For example,
 * the attribute `source.ip` maps to field `AttributeContext.source.ip`.
 *
 * This message definition is guaranteed not to have any wire breaking change.
 * So you can use it directly for passing attributes across different systems.
 *
 * NOTE: Different system may generate different subset of attributes. Please
 * verify the system specification before relying on an attribute generated
 * a system.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext
 */
export interface AttributeContext {
    /**
     * The origin of a network activity. In a multi hop network activity,
     * the origin represents the sender of the first hop. For the first hop,
     * the `source` and the `origin` must have the same content.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Peer origin = 7;
     */
    origin?: AttributeContext_Peer;
    /**
     * The source of a network activity, such as starting a TCP connection.
     * In a multi hop network activity, the source represents the sender of the
     * last hop.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Peer source = 1;
     */
    source?: AttributeContext_Peer;
    /**
     * The destination of a network activity, such as accepting a TCP connection.
     * In a multi hop network activity, the destination represents the receiver of
     * the last hop.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Peer destination = 2;
     */
    destination?: AttributeContext_Peer;
    /**
     * Represents a network request, such as an HTTP request.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Request request = 3;
     */
    request?: AttributeContext_Request;
    /**
     * Represents a network response, such as an HTTP response.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Response response = 4;
     */
    response?: AttributeContext_Response;
    /**
     * Represents a target resource that is involved with a network activity.
     * If multiple resources are involved with an activity, this must be the
     * primary one.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Resource resource = 5;
     */
    resource?: AttributeContext_Resource;
    /**
     * Represents an API operation that is involved to a network activity.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Api api = 6;
     */
    api?: AttributeContext_Api;
}
/**
 * This message defines attributes for a node that handles a network request.
 * The node can be either a service or an application that sends, forwards,
 * or receives the request. Service peers should fill in
 * `principal` and `labels` as appropriate.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Peer
 */
export interface AttributeContext_Peer {
    /**
     * The IP address of the peer.
     *
     * @generated from protobuf field: string ip = 1;
     */
    ip: string;
    /**
     * The network port of the peer.
     *
     * @generated from protobuf field: int64 port = 2;
     */
    port: string;
    /**
     * The labels associated with the peer.
     *
     * @generated from protobuf field: map<string, string> labels = 6;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * The identity of this peer. Similar to `Request.auth.principal`, but
     * relative to the peer instead of the request. For example, the
     * idenity associated with a load balancer that forwared the request.
     *
     * @generated from protobuf field: string principal = 7;
     */
    principal: string;
    /**
     * The CLDR country/region code associated with the above IP address.
     * If the IP address is private, the `region_code` should reflect the
     * physical location where this peer is running.
     *
     * @generated from protobuf field: string region_code = 8;
     */
    regionCode: string;
}
/**
 * This message defines attributes associated with API operations, such as
 * a network API request. The terminology is based on the conventions used
 * by Google APIs, Istio, and OpenAPI.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Api
 */
export interface AttributeContext_Api {
    /**
     * The API service name. It is a logical identifier for a networked API,
     * such as "pubsub.googleapis.com". The naming syntax depends on the
     * API management system being used for handling the request.
     *
     * @generated from protobuf field: string service = 1;
     */
    service: string;
    /**
     * The API operation name. For gRPC requests, it is the fully qualified API
     * method name, such as "google.pubsub.v1.Publisher.Publish". For OpenAPI
     * requests, it is the `operationId`, such as "getPet".
     *
     * @generated from protobuf field: string operation = 2;
     */
    operation: string;
    /**
     * The API protocol used for sending the request, such as "http", "https",
     * "grpc", or "internal".
     *
     * @generated from protobuf field: string protocol = 3;
     */
    protocol: string;
    /**
     * The API version associated with the API operation above, such as "v1" or
     * "v1alpha1".
     *
     * @generated from protobuf field: string version = 4;
     */
    version: string;
}
/**
 * This message defines request authentication attributes. Terminology is
 * based on the JSON Web Token (JWT) standard, but the terms also
 * correlate to concepts in other standards.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Auth
 */
export interface AttributeContext_Auth {
    /**
     * The authenticated principal. Reflects the issuer (`iss`) and subject
     * (`sub`) claims within a JWT. The issuer and subject should be `/`
     * delimited, with `/` percent-encoded within the subject fragment. For
     * Google accounts, the principal format is:
     * "https://accounts.google.com/{id}"
     *
     * @generated from protobuf field: string principal = 1;
     */
    principal: string;
    /**
     * The intended audience(s) for this authentication information. Reflects
     * the audience (`aud`) claim within a JWT. The audience
     * value(s) depends on the `issuer`, but typically include one or more of
     * the following pieces of information:
     *
     * *  The services intended to receive the credential such as
     *    ["pubsub.googleapis.com", "storage.googleapis.com"]
     * *  A set of service-based scopes. For example,
     *    ["https://www.googleapis.com/auth/cloud-platform"]
     * *  The client id of an app, such as the Firebase project id for JWTs
     *    from Firebase Auth.
     *
     * Consult the documentation for the credential issuer to determine the
     * information provided.
     *
     * @generated from protobuf field: repeated string audiences = 2;
     */
    audiences: string[];
    /**
     * The authorized presenter of the credential. Reflects the optional
     * Authorized Presenter (`azp`) claim within a JWT or the
     * OAuth client id. For example, a Google Cloud Platform client id looks
     * as follows: "123456789012.apps.googleusercontent.com".
     *
     * @generated from protobuf field: string presenter = 3;
     */
    presenter: string;
    /**
     * Structured claims presented with the credential. JWTs include
     * `{key: value}` pairs for standard and private claims. The following
     * is a subset of the standard required and optional claims that would
     * typically be presented for a Google-based JWT:
     *
     *    {'iss': 'accounts.google.com',
     *     'sub': '113289723416554971153',
     *     'aud': ['123456789012', 'pubsub.googleapis.com'],
     *     'azp': '123456789012.apps.googleusercontent.com',
     *     'email': 'jsmith@example.com',
     *     'iat': 1353601026,
     *     'exp': 1353604926}
     *
     * SAML assertions are similarly specified, but with an identity provider
     * dependent structure.
     *
     * @generated from protobuf field: google.protobuf.Struct claims = 4;
     */
    claims?: Struct;
    /**
     * A list of access level resource names that allow resources to be
     * accessed by authenticated requester. It is part of Secure GCP processing
     * for the incoming request. An access level string has the format:
     * "//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}"
     *
     * Example:
     * "//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL"
     *
     * @generated from protobuf field: repeated string access_levels = 5;
     */
    accessLevels: string[];
}
/**
 * This message defines attributes for an HTTP request. If the actual
 * request is not an HTTP request, the runtime system should try to map
 * the actual request to an equivalent HTTP request.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Request
 */
export interface AttributeContext_Request {
    /**
     * The unique ID for a request, which can be propagated to downstream
     * systems. The ID should have low probability of collision
     * within a single day for a specific service.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The HTTP request method, such as `GET`, `POST`.
     *
     * @generated from protobuf field: string method = 2;
     */
    method: string;
    /**
     * The HTTP request headers. If multiple headers share the same key, they
     * must be merged according to the HTTP spec. All header keys must be
     * lowercased, because HTTP header keys are case-insensitive.
     *
     * @generated from protobuf field: map<string, string> headers = 3;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * The HTTP URL path.
     *
     * @generated from protobuf field: string path = 4;
     */
    path: string;
    /**
     * The HTTP request `Host` header value.
     *
     * @generated from protobuf field: string host = 5;
     */
    host: string;
    /**
     * The HTTP URL scheme, such as `http` and `https`.
     *
     * @generated from protobuf field: string scheme = 6;
     */
    scheme: string;
    /**
     * The HTTP URL query in the format of `name1=value1&name2=value2`, as it
     * appears in the first line of the HTTP request. No decoding is performed.
     *
     * @generated from protobuf field: string query = 7;
     */
    query: string;
    /**
     * The timestamp when the `destination` service receives the first byte of
     * the request.
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 9;
     */
    time?: Timestamp;
    /**
     * The HTTP request size in bytes. If unknown, it must be -1.
     *
     * @generated from protobuf field: int64 size = 10;
     */
    size: string;
    /**
     * The network protocol used with the request, such as "http/1.1",
     * "spdy/3", "h2", "h2c", "webrtc", "tcp", "udp", "quic". See
     * https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
     * for details.
     *
     * @generated from protobuf field: string protocol = 11;
     */
    protocol: string;
    /**
     * A special parameter for request reason. It is used by security systems
     * to associate auditing information with a request.
     *
     * @generated from protobuf field: string reason = 12;
     */
    reason: string;
    /**
     * The request authentication. May be absent for unauthenticated requests.
     * Derived from the HTTP request `Authorization` header or equivalent.
     *
     * @generated from protobuf field: google.rpc.context.AttributeContext.Auth auth = 13;
     */
    auth?: AttributeContext_Auth;
}
/**
 * This message defines attributes for a typical network response. It
 * generally models semantics of an HTTP response.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Response
 */
export interface AttributeContext_Response {
    /**
     * The HTTP response status code, such as `200` and `404`.
     *
     * @generated from protobuf field: int64 code = 1;
     */
    code: string;
    /**
     * The HTTP response size in bytes. If unknown, it must be -1.
     *
     * @generated from protobuf field: int64 size = 2;
     */
    size: string;
    /**
     * The HTTP response headers. If multiple headers share the same key, they
     * must be merged according to HTTP spec. All header keys must be
     * lowercased, because HTTP header keys are case-insensitive.
     *
     * @generated from protobuf field: map<string, string> headers = 3;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * The timestamp when the `destination` service generates the first byte of
     * the response.
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 4;
     */
    time?: Timestamp;
}
/**
 * This message defines core attributes for a resource. A resource is an
 * addressable (named) entity provided by the destination service. For
 * example, a file stored on a network storage service.
 *
 * @generated from protobuf message google.rpc.context.AttributeContext.Resource
 */
export interface AttributeContext_Resource {
    /**
     * The name of the service that this resource belongs to, such as
     * `pubsub.googleapis.com`. The service may be different from the DNS
     * hostname that actually serves the request.
     *
     * @generated from protobuf field: string service = 1;
     */
    service: string;
    /**
     * The stable identifier (name) of a resource on the `service`. A resource
     * can be logically identified as "//{resource.service}/{resource.name}".
     * The differences between a resource name and a URI are:
     *
     * *   Resource name is a logical identifier, independent of network
     *     protocol and API version. For example,
     *     `//pubsub.googleapis.com/projects/123/topics/news-feed`.
     * *   URI often includes protocol and version information, so it can
     *     be used directly by applications. For example,
     *     `https://pubsub.googleapis.com/v1/projects/123/topics/news-feed`.
     *
     * See https://cloud.google.com/apis/design/resource_names for details.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The type of the resource. The syntax is platform-specific because
     * different platforms define their resources differently.
     *
     * For Google APIs, the type format must be "{service}/{kind}".
     *
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * The labels or tags on the resource, such as AWS resource tags and
     * Kubernetes resource labels.
     *
     * @generated from protobuf field: map<string, string> labels = 4;
     */
    labels: {
        [key: string]: string;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext$Type extends MessageType<AttributeContext> {
    constructor() {
        super("google.rpc.context.AttributeContext", [
            { no: 7, name: "origin", kind: "message", T: () => AttributeContext_Peer },
            { no: 1, name: "source", kind: "message", T: () => AttributeContext_Peer },
            { no: 2, name: "destination", kind: "message", T: () => AttributeContext_Peer },
            { no: 3, name: "request", kind: "message", T: () => AttributeContext_Request },
            { no: 4, name: "response", kind: "message", T: () => AttributeContext_Response },
            { no: 5, name: "resource", kind: "message", T: () => AttributeContext_Resource },
            { no: 6, name: "api", kind: "message", T: () => AttributeContext_Api }
        ]);
    }
    create(value?: PartialMessage<AttributeContext>): AttributeContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttributeContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext): AttributeContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.context.AttributeContext.Peer origin */ 7:
                    message.origin = AttributeContext_Peer.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* google.rpc.context.AttributeContext.Peer source */ 1:
                    message.source = AttributeContext_Peer.internalBinaryRead(reader, reader.uint32(), options, message.source);
                    break;
                case /* google.rpc.context.AttributeContext.Peer destination */ 2:
                    message.destination = AttributeContext_Peer.internalBinaryRead(reader, reader.uint32(), options, message.destination);
                    break;
                case /* google.rpc.context.AttributeContext.Request request */ 3:
                    message.request = AttributeContext_Request.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* google.rpc.context.AttributeContext.Response response */ 4:
                    message.response = AttributeContext_Response.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                case /* google.rpc.context.AttributeContext.Resource resource */ 5:
                    message.resource = AttributeContext_Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* google.rpc.context.AttributeContext.Api api */ 6:
                    message.api = AttributeContext_Api.internalBinaryRead(reader, reader.uint32(), options, message.api);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.context.AttributeContext.Peer origin = 7; */
        if (message.origin)
            AttributeContext_Peer.internalBinaryWrite(message.origin, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Peer source = 1; */
        if (message.source)
            AttributeContext_Peer.internalBinaryWrite(message.source, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Peer destination = 2; */
        if (message.destination)
            AttributeContext_Peer.internalBinaryWrite(message.destination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Request request = 3; */
        if (message.request)
            AttributeContext_Request.internalBinaryWrite(message.request, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Response response = 4; */
        if (message.response)
            AttributeContext_Response.internalBinaryWrite(message.response, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Resource resource = 5; */
        if (message.resource)
            AttributeContext_Resource.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.context.AttributeContext.Api api = 6; */
        if (message.api)
            AttributeContext_Api.internalBinaryWrite(message.api, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext
 */
export const AttributeContext = new AttributeContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Peer$Type extends MessageType<AttributeContext_Peer> {
    constructor() {
        super("google.rpc.context.AttributeContext.Peer", [
            { no: 1, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 7, name: "principal", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "region_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Peer>): AttributeContext_Peer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = "";
        message.port = "0";
        message.labels = {};
        message.principal = "";
        message.regionCode = "";
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Peer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Peer): AttributeContext_Peer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip */ 1:
                    message.ip = reader.string();
                    break;
                case /* int64 port */ 2:
                    message.port = reader.int64().toString();
                    break;
                case /* map<string, string> labels */ 6:
                    this.binaryReadMap6(message.labels, reader, options);
                    break;
                case /* string principal */ 7:
                    message.principal = reader.string();
                    break;
                case /* string region_code */ 8:
                    message.regionCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AttributeContext_Peer["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_Peer["labels"] | undefined, val: AttributeContext_Peer["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.rpc.context.AttributeContext.Peer.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip = 1; */
        if (message.ip !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ip);
        /* int64 port = 2; */
        if (message.port !== "0")
            writer.tag(2, WireType.Varint).int64(message.port);
        /* map<string, string> labels = 6; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* string principal = 7; */
        if (message.principal !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.principal);
        /* string region_code = 8; */
        if (message.regionCode !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.regionCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Peer
 */
export const AttributeContext_Peer = new AttributeContext_Peer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Api$Type extends MessageType<AttributeContext_Api> {
    constructor() {
        super("google.rpc.context.AttributeContext.Api", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Api>): AttributeContext_Api {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.service = "";
        message.operation = "";
        message.protocol = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Api>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Api): AttributeContext_Api {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* string operation */ 2:
                    message.operation = reader.string();
                    break;
                case /* string protocol */ 3:
                    message.protocol = reader.string();
                    break;
                case /* string version */ 4:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeContext_Api, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.service);
        /* string operation = 2; */
        if (message.operation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operation);
        /* string protocol = 3; */
        if (message.protocol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.protocol);
        /* string version = 4; */
        if (message.version !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Api
 */
export const AttributeContext_Api = new AttributeContext_Api$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Auth$Type extends MessageType<AttributeContext_Auth> {
    constructor() {
        super("google.rpc.context.AttributeContext.Auth", [
            { no: 1, name: "principal", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audiences", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "presenter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "claims", kind: "message", T: () => Struct },
            { no: 5, name: "access_levels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Auth>): AttributeContext_Auth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.principal = "";
        message.audiences = [];
        message.presenter = "";
        message.accessLevels = [];
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Auth): AttributeContext_Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string principal */ 1:
                    message.principal = reader.string();
                    break;
                case /* repeated string audiences */ 2:
                    message.audiences.push(reader.string());
                    break;
                case /* string presenter */ 3:
                    message.presenter = reader.string();
                    break;
                case /* google.protobuf.Struct claims */ 4:
                    message.claims = Struct.internalBinaryRead(reader, reader.uint32(), options, message.claims);
                    break;
                case /* repeated string access_levels */ 5:
                    message.accessLevels.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeContext_Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string principal = 1; */
        if (message.principal !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.principal);
        /* repeated string audiences = 2; */
        for (let i = 0; i < message.audiences.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.audiences[i]);
        /* string presenter = 3; */
        if (message.presenter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.presenter);
        /* google.protobuf.Struct claims = 4; */
        if (message.claims)
            Struct.internalBinaryWrite(message.claims, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string access_levels = 5; */
        for (let i = 0; i < message.accessLevels.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.accessLevels[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Auth
 */
export const AttributeContext_Auth = new AttributeContext_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Request$Type extends MessageType<AttributeContext_Request> {
    constructor() {
        super("google.rpc.context.AttributeContext.Request", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "time", kind: "message", T: () => Timestamp },
            { no: 10, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "auth", kind: "message", T: () => AttributeContext_Auth }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Request>): AttributeContext_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.method = "";
        message.headers = {};
        message.path = "";
        message.host = "";
        message.scheme = "";
        message.query = "";
        message.size = "0";
        message.protocol = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Request): AttributeContext_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string method */ 2:
                    message.method = reader.string();
                    break;
                case /* map<string, string> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                case /* string path */ 4:
                    message.path = reader.string();
                    break;
                case /* string host */ 5:
                    message.host = reader.string();
                    break;
                case /* string scheme */ 6:
                    message.scheme = reader.string();
                    break;
                case /* string query */ 7:
                    message.query = reader.string();
                    break;
                case /* google.protobuf.Timestamp time */ 9:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 size */ 10:
                    message.size = reader.int64().toString();
                    break;
                case /* string protocol */ 11:
                    message.protocol = reader.string();
                    break;
                case /* string reason */ 12:
                    message.reason = reader.string();
                    break;
                case /* google.rpc.context.AttributeContext.Auth auth */ 13:
                    message.auth = AttributeContext_Auth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AttributeContext_Request["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_Request["headers"] | undefined, val: AttributeContext_Request["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.rpc.context.AttributeContext.Request.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string method = 2; */
        if (message.method !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.method);
        /* map<string, string> headers = 3; */
        for (let k of globalThis.Object.keys(message.headers))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* string path = 4; */
        if (message.path !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.path);
        /* string host = 5; */
        if (message.host !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.host);
        /* string scheme = 6; */
        if (message.scheme !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.scheme);
        /* string query = 7; */
        if (message.query !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.query);
        /* google.protobuf.Timestamp time = 9; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 size = 10; */
        if (message.size !== "0")
            writer.tag(10, WireType.Varint).int64(message.size);
        /* string protocol = 11; */
        if (message.protocol !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.protocol);
        /* string reason = 12; */
        if (message.reason !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.reason);
        /* google.rpc.context.AttributeContext.Auth auth = 13; */
        if (message.auth)
            AttributeContext_Auth.internalBinaryWrite(message.auth, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Request
 */
export const AttributeContext_Request = new AttributeContext_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Response$Type extends MessageType<AttributeContext_Response> {
    constructor() {
        super("google.rpc.context.AttributeContext.Response", [
            { no: 1, name: "code", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Response>): AttributeContext_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "0";
        message.size = "0";
        message.headers = {};
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Response): AttributeContext_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 code */ 1:
                    message.code = reader.int64().toString();
                    break;
                case /* int64 size */ 2:
                    message.size = reader.int64().toString();
                    break;
                case /* map<string, string> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                case /* google.protobuf.Timestamp time */ 4:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AttributeContext_Response["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_Response["headers"] | undefined, val: AttributeContext_Response["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.rpc.context.AttributeContext.Response.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 code = 1; */
        if (message.code !== "0")
            writer.tag(1, WireType.Varint).int64(message.code);
        /* int64 size = 2; */
        if (message.size !== "0")
            writer.tag(2, WireType.Varint).int64(message.size);
        /* map<string, string> headers = 3; */
        for (let k of globalThis.Object.keys(message.headers))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* google.protobuf.Timestamp time = 4; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Response
 */
export const AttributeContext_Response = new AttributeContext_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Resource$Type extends MessageType<AttributeContext_Resource> {
    constructor() {
        super("google.rpc.context.AttributeContext.Resource", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_Resource>): AttributeContext_Resource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.service = "";
        message.name = "";
        message.type = "";
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Resource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Resource): AttributeContext_Resource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* map<string, string> labels */ 4:
                    this.binaryReadMap4(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: AttributeContext_Resource["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_Resource["labels"] | undefined, val: AttributeContext_Resource["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.rpc.context.AttributeContext.Resource.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_Resource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.service);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* map<string, string> labels = 4; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.rpc.context.AttributeContext.Resource
 */
export const AttributeContext_Resource = new AttributeContext_Resource$Type();
